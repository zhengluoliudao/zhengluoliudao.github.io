<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风连广宇的萌萌哒小博客</title>
  
  
  <link href="https://zhengluoliudao.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhengluoliudao.github.io/"/>
  <updated>2022-01-02T13:35:22.599Z</updated>
  <id>https://zhengluoliudao.github.io/</id>
  
  <author>
    <name>momentum</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高级数据库知识点汇总</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</id>
    <published>2022-01-02T13:32:53.000Z</published>
    <updated>2022-01-02T13:35:22.599Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据模型和概念模型"><a href="#数据模型和概念模型" class="headerlink" title="数据模型和概念模型"></a>数据模型和概念模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据模型：表达数据/计算机世界的模型</span><br><span class="line">概念模型：表达观念/信息世界的模型</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211124195224828.png" alt="image-20211124195224828"></p><h4 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ER图基本概念：实体，属性，联系，关键字</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211124201401352.png" alt="image-20211124201401352"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IDEF1X图：</span><br><span class="line">独立实体用直角方形框，从属实体用圆角方形框表示</span><br><span class="line">独立实体的主关键字没有外键，从属实体的主关键字含有外键</span><br><span class="line">标定联系：子实体的实例都是由它与父实体的联系而确定。父实体的主关键字是子实体主关键字的一部分</span><br><span class="line">非标定联系：子实体的实例能够被唯一标识而无需依赖与其实体的联系。父实体的主关键字不是子实体的主关键字。</span><br><span class="line">非确定联系：即实体之间的多对多的联系，必须分解为若干个一对多的联系来表达，通过引入相交实体来分解</span><br><span class="line">分类联系：一个实体实例是由一个一般实体实例及多个分类实体实例构成的</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211129145504409.png" alt="image-20211129145504409"></p><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211129150007952.png" alt="image-20211129150007952"></p><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211129150203529.png" alt="image-20211129150203529"></p><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211129150447665.png" alt="image-20211129150447665"></p><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非平凡函数依赖：X-&gt;Y, Y不属于X</span><br><span class="line">完全/部分函数依赖： X-&gt;Y, X的部分能/不能-&gt;Y</span><br><span class="line">传递函数依赖：若X-&gt;Y, Y-&gt;Z, 且Y不属于X, Y不能-&gt;X, 则x-&gt;Z</span><br></pre></td></tr></table></figure><h4 id="Armstrong公理"><a href="#Armstrong公理" class="headerlink" title="Armstrong公理"></a>Armstrong公理</h4><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211125221655094.png" alt="image-20211125221655094"></p><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211125221755033.png" alt="image-20211125221755033"></p><h4 id="属性集闭包"><a href="#属性集闭包" class="headerlink" title="属性集闭包"></a>属性集闭包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X在R(U,F)上的闭包：X能决定的集合</span><br></pre></td></tr></table></figure><h4 id="最小覆盖"><a href="#最小覆盖" class="headerlink" title="最小覆盖"></a>最小覆盖</h4><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211125224439208.png" alt="image-20211125224439208"></p><h4 id="关系模式的范式"><a href="#关系模式的范式" class="headerlink" title="关系模式的范式"></a>关系模式的范式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一范式  属性不可分</span><br><span class="line">第二范式    每个非主属性完全函数依赖于候选键</span><br><span class="line">第三范式    每个非主属性不传递函数依赖于候选键</span><br><span class="line">BCNF       任意主属性都完全函数依赖于候选键</span><br></pre></td></tr></table></figure><h4 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="关系模式分解"></a>关系模式分解</h4><p>无损连接性，函数依赖保持性</p><h4 id="存储体系回顾"><a href="#存储体系回顾" class="headerlink" title="存储体系回顾"></a>存储体系回顾</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">操作系统对磁盘管理：FAT(文件分配表)+目录+磁盘块     操作系统将文件保存在多个不连续磁盘块，目录/文件夹保存第一个磁盘块编号，FAT表格保存每个磁盘块的下一个磁盘块编号</span><br><span class="line">操作系统对内存管理：内存页对应磁盘块，记录地址=页面+页内偏移量，页面的分配与替换</span><br><span class="line"></span><br><span class="line">磁盘：盘面--磁道--扇区--磁盘块</span><br><span class="line">磁盘读取时间=寻道时间+旋转时间+传输时间</span><br><span class="line">RAID(独立磁盘冗余阵列)技术：</span><br><span class="line">并行处理：并行读取多个磁盘</span><br><span class="line">可靠性：奇偶检验与纠错</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211126160757699.png" alt="image-20211126160757699"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表所占磁盘块的分配方法：连续分配，链接分配，按簇分配，索引分配</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211126192807043.png" alt="image-20211126192807043"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">四种文件组织方法：</span><br><span class="line">无序记录文件（堆文件）：需要数据库重组</span><br><span class="line">有序记录文件：对排序字段检索效率高，更新效率低（可以用溢出文件）</span><br><span class="line">散列文件：查找和更新效率都高</span><br><span class="line">聚簇文件：将具有相同或相似属性值的记录存放于连续的磁盘簇块中；多表聚簇</span><br><span class="line"></span><br><span class="line">性能降低：数据库重组</span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211127100744041.png" alt="image-20211127100744041"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">稠密索引：索引中包含了主文件对应字段的所有不同值</span><br><span class="line">候选键的稠密索引   非候选键的稠密索引</span><br><span class="line">稀疏索引：主文件中只有部分记录有索引项对应    ----要求主文件按照索引值顺序存储</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主索引</span><br><span class="line">辅助索引</span><br></pre></td></tr></table></figure><h4 id="连接算法"><a href="#连接算法" class="headerlink" title="连接算法"></a>连接算法</h4><table><thead><tr><th></th><th>I/O代价</th><th>可用内存页数要求</th><th>适用条件</th></tr></thead><tbody><tr><td>一趟连接算法</td><td>B(R) + B(S)</td><td>B(S) &lt; M − 1</td><td></td></tr><tr><td>基于元组的嵌套循环连接算法</td><td>T(S)(T(R) + 1)</td><td>M &gt;= 2</td><td></td></tr><tr><td>基于块的嵌套循环连接算法</td><td>B(S) + B(R)B(S)/(M-1)</td><td>M &gt;= 2</td><td></td></tr><tr><td>排序归并连接算法</td><td>3B(R) + 3B(S)</td><td>B(R) + B(S) &lt;= M^2</td><td>有序</td></tr><tr><td>基于哈希的连接算法</td><td>3B(R) + 3B(S)</td><td>B(S) &lt;= (M-1)^2</td><td></td></tr><tr><td>基于索引的连接算法</td><td>B(R) + T(R)T(S)/V(S,Y)   非聚簇索引  B(R) + T(R)B(S)/V(S,Y)   聚簇索引</td><td>M &gt;= 2</td><td>有索引</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何判断使用哪种算法以及代价：先看R和S的大小是否超过M，超过则一趟连接算法不可用；无索引，则索引连接不可用；无序，则排序归并不可用。优先哈希</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逻辑查询优化：改写成关系代数表达式（投影操作（选择操作（连接操作）））---尽可能早做选择投影操作</span><br><span class="line">物理查询优化：对不同操作选取不同算法</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211128211339391.png" alt="image-20211128211339391"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关系代数操作次序交换的等价性：</span><br><span class="line">连接，笛卡尔积满足交换律    连接和笛卡儿积满足结合律   投影合并律   选择串接律</span><br><span class="line">选择和投影交换律：若选择操作只涉及投影属性，则可交换顺序</span><br><span class="line">选择和积的交换律：若选择操作只涉及E1中的属性，则 选择(E1*E2) = 选择(E1)*E2</span><br><span class="line">   若F1和F2分别只涉及E1和E2，则  选择F1^F2(E1*E2) = 选择F1(E1)*选择F2(E2)</span><br><span class="line"></span><br><span class="line">优化语法树步骤：</span><br><span class="line">1. 选择条件拆分</span><br><span class="line">2. 对每个选择尽可能移动到下方(看条件的属性涉及到几张表，基本可以直接移动到涉及的表上方)</span><br><span class="line">3. 对每个投影尽可能移动到下方(基本是拆分每个表的投影属性，然后下移)</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211128235519219.png" alt="image-20211128235519219"></p><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211128235657959.png" alt="image-20211128235657959"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理查询代价估计</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211129104017060.png" alt="image-20211129104017060"></p><h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冲突条件：两个操作属于不同事务；两个操作涉及相同对象，且至少一个是写</span><br><span class="line">优先图：操作Oi和Oj冲突（Oi在Oj前），则有一条Oi指向Oj的边；优先图无环等价于冲突可串行化调度。</span><br></pre></td></tr></table></figure><p>2PL(两阶段锁)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">增长阶段：事务申请锁</span><br><span class="line">萎缩阶段：事务只能释放锁，不能申请</span><br><span class="line">优点：冲突可串行化</span><br><span class="line">缺点：面临级联中止和死锁  </span><br><span class="line"></span><br><span class="line">SS2PL（强两阶段锁）</span><br><span class="line">增长阶段：同2PL</span><br><span class="line">萎缩阶段：事务结束释放所有锁</span><br><span class="line">优点：避免级联中止</span><br><span class="line"></span><br><span class="line">死锁</span><br><span class="line">死锁的形成条件：</span><br><span class="line">1、互斥条件：一个资源每次只能被一个进程使用；</span><br><span class="line">2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</span><br><span class="line">3、不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺；</span><br><span class="line">4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系；</span><br><span class="line">死锁检测：超时检测，等待图检测</span><br><span class="line">死锁预防：设置优先级</span><br></pre></td></tr></table></figure><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">undo：撤销未完成事务对数据库的修改</span><br><span class="line">redo：重做已提交事务对数据库的修改</span><br><span class="line">steal：允许未提交事务所做修改提交到磁盘</span><br><span class="line">froce：事务提交前必须将所做修改提交到磁盘</span><br><span class="line"></span><br><span class="line">NO-Steal+Force     无需undo,redo</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211128185010593.png" alt="image-20211128185010593"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WAL（预写式日志）：&lt;tid 事务id, O_id 修改对象id, before 修改前值, after 修改后值&gt;</span><br><span class="line">基于WAL的故障恢复</span><br><span class="line">检查点：&lt;BEGIN CHECKPOINT (T1,T2, . . . ,Tn)&gt;    T1到Tn是检查点开始时的未提交未中止事务</span><br><span class="line">故障恢复：redo找提交的，从检查点开始向下找；undo从后往前找未提交的，直到检查点</span><br><span class="line">（只需要从检查点后开始redo）</span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211128185711006.png" alt="image-20211128185711006"></p><h4 id="各数据库模型对比"><a href="#各数据库模型对比" class="headerlink" title="各数据库模型对比"></a>各数据库模型对比</h4><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>网状/层次模型</td><td>以图/树为操控手段，以记录型和系型为基本数据结构，维护困难</td></tr><tr><td>关系模型</td><td>以表为操作手段，通过5种基本运算对表操作，使用SQL语句查询，结构简单但是数据表达能力差</td></tr><tr><td>面向对象模型</td><td>以对象为操作手段，使用对象封装技术将复合属性及聚集类型属性封装为对象，使用OQL语句进行查询，可读性强，易于扩展，但是执行速度慢</td></tr><tr><td>XML模型</td><td>多用于描述半结构化数据，将数据的语义格式和数据通过标记和可分词字符串组合成一个元素放在XML文档中，通过Xpath/Xquery语言检索，可以嵌套描述，XML的数据结构是一棵树</td></tr><tr><td>NoSQL模型</td><td>泛指非关系型数据库，有多种存储方式，高性能易扩展</td></tr></tbody></table><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211129001732627.png" alt="image-20211129001732627"></p><p><img src="/../images/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211129002255479.png" alt="image-20211129002255479"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数据模型和概念模型&quot;&gt;&lt;a href=&quot;#数据模型和概念模型&quot; class=&quot;headerlink&quot; title=&quot;数据模型和概念模型&quot;&gt;&lt;/a&gt;数据模型和概念模型&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
    <category term="DataBase" scheme="https://zhengluoliudao.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>2020年组合数学考试题</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/</id>
    <published>2022-01-02T13:30:51.000Z</published>
    <updated>2022-01-02T13:31:56.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="D:\Documents\研一上-组合数学\2020试卷.jpg" alt="2020试卷"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4男4女围圆桌交替就座，请向有多少种就座方式? (10分)</span><br></pre></td></tr></table></figure><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211224090722371.png" alt="image-20211224090722371"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某车站有1到6个人口，每个人口每次只能进入一个人，一个小组共有9人组成，请问这个小组有多少种不同的进站方案?</span><br></pre></td></tr></table></figure><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211224090703314.png" alt="image-20211224090703314"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用鸽笼原理证明Fermat小定理:设p是-个素数,a是一个整数,并且(a,p)=1。证明: a^(P-1)=== 1(mod p)。(10分)</span><br></pre></td></tr></table></figure><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211225153424621.png" alt="image-20211225153424621"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211225185102042.png" alt="image-20211225185102042"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211225181551284.png" alt="image-20211225181551284"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211225182033835.png" alt="image-20211225182033835"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211225234532669.png" alt="image-20211225234532669"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211227134905188.png" alt="image-20211227134905188"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211228222442853.png" alt="image-20211228222442853"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211226234131963.png" alt="image-20211226234131963"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211227135013728.png" alt="image-20211227135013728"></p><p><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211228001721575.png" alt="image-20211228001721575"></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/image-20211228004319028.png" alt="image-20211228004319028"></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;D:\Documents\研一上-组合数学\2020试卷.jpg&quot; alt=&quot;2020试卷&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    
    <category term="组合数学" scheme="https://zhengluoliudao.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合数学知识点汇总</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</id>
    <published>2022-01-02T13:29:43.000Z</published>
    <updated>2022-01-02T13:30:54.633Z</updated>
    
    <content type="html"><![CDATA[<center>组合数学</center><h3 id="第一章-排列与组合"><a href="#第一章-排列与组合" class="headerlink" title="第一章 排列与组合"></a>第一章 排列与组合</h3><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从n 个不同的元素中不重复的选取r(1 &lt;= r &lt;= n) 个元素并将其排成一排称为n个元素的r排列, 其方法数记为P(n, r) 或Prn.</span><br><span class="line">重点：有序，不同元素，n!/(n-m)!</span><br><span class="line"></span><br><span class="line">题目：这部分题目都比较简单，可以用排除取补，分割问题等办法</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如n，r包含于N 且n &gt;= r &gt;= 2，则P(n, r) = n * P(n - 1, r - 1)</span><br><span class="line">如n，r包含于N 且n &gt;= r &gt;= 2，则P(n, r) = r * P(n - 1, r - 1) + P(n - 1, r)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">圆排列：从n 个不同的元素中选取r(1 &lt;= r &lt;= n) 个元素的园排列数为 p(n, r)/r</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211220183106133.png" alt="image-20211220183106133"></p><h4 id="多重集的排列"><a href="#多重集的排列" class="headerlink" title="多重集的排列"></a>多重集的排列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1-an互不相同，无限多重集选取r个元素的排列方式有n^r种</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211220184030608.png" alt="image-20211220184030608"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有限多重集全排总数为 (K1+K2+...+Kn)!/K1!K2!...Kn!</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211223231035392.png" alt="image-20211223231035392"></p><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组合：只选不排，C(n,r)=n!/(n-r)!r!</span><br><span class="line">C(n, r) = C(n, n-r)</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211223232011988.png" alt="image-20211223232011988"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">杨辉三角</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211223232355369.png" alt="image-20211223232355369"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211223234420209.png" alt="image-20211223234420209"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211223234359056.png" alt="image-20211223234359056"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211223235856807.png" alt="image-20211223235856807"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211224000846557.png" alt="image-20211224000846557"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211224001049670.png" alt="image-20211224001049670"></p><h4 id="多重组合"><a href="#多重组合" class="headerlink" title="多重组合"></a>多重组合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多重组合：</span><br><span class="line">对无限多重集，r-组合数有 F(n, r) = C(n+r-1, r)</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211224112037700.png" alt="image-20211224112037700"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211224161801046.png" alt="image-20211224161801046"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225181537051.png" alt="image-20211225181537051"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226222046303.png" alt="image-20211226222046303"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不相邻组合：从集合A = &#123;1，2，3，，，n&#125; 中选取r个元素做组合，其中不存在i, i + 1 两个相邻的数同时出现于一个组合的组合，被称为不相邻组合。，其组合数为 C(n - r + 1, r)</span><br></pre></td></tr></table></figure><h4 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211224202015632.png" alt="image-20211224202015632"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227141149039.png" alt="image-20211227141149039"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211224202230730.png" alt="image-20211224202230730"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227161458162.png" alt="image-20211227161458162"></p><h4 id="组合恒等式"><a href="#组合恒等式" class="headerlink" title="组合恒等式"></a>组合恒等式</h4><h3 id="第二章-鸽巢原理与Ramsey-理论"><a href="#第二章-鸽巢原理与Ramsey-理论" class="headerlink" title="第二章 鸽巢原理与Ramsey 理论"></a>第二章 鸽巢原理与Ramsey 理论</h3><h4 id="鸽笼原理基本形式"><a href="#鸽笼原理基本形式" class="headerlink" title="鸽笼原理基本形式"></a>鸽笼原理基本形式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225003410004.png" alt="image-20211225003410004"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225151339899.png" alt="image-20211225151339899"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225152828465.png" alt="image-20211225152828465"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225153325924.png" alt="image-20211225153325924"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225153439940.png" alt="image-20211225153439940"></p><h4 id="鸽笼原理加强形式"><a href="#鸽笼原理加强形式" class="headerlink" title="鸽笼原理加强形式"></a>鸽笼原理加强形式</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225210545743.png" alt="image-20211225210545743"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225210516273.png" alt="image-20211225210516273"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225223724906.png" alt="image-20211225223724906"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225224253509.png" alt="image-20211225224253509"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225225322255.png" alt="image-20211225225322255"></p><h4 id="Ramsey理论"><a href="#Ramsey理论" class="headerlink" title="Ramsey理论"></a>Ramsey理论</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225225452976.png" alt="image-20211225225452976"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225225515398.png" alt="image-20211225225515398"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225225534699.png" alt="image-20211225225534699"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225232146325.png" alt="image-20211225232146325"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211225235910190.png" alt="image-20211225235910190"></p><h3 id="第三章-容斥原理"><a href="#第三章-容斥原理" class="headerlink" title="第三章 容斥原理"></a>第三章 容斥原理</h3><h4 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226134138774.png" alt="image-20211226134138774"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226134802763.png" alt="image-20211226134802763"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226135136865.png" alt="image-20211226135136865"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226190935630.png" alt="image-20211226190935630"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226200403927.png" alt="image-20211226200403927"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226200509353.png" alt="image-20211226200509353"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226215800840.png" alt="image-20211226215800840"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226221130299.png" alt="image-20211226221130299"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226222755375.png" alt="image-20211226222755375"></p><h4 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226223846372.png" alt="image-20211226223846372"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226230244819.png" alt="image-20211226230244819"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226230440794.png" alt="image-20211226230440794"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226230903851.png" alt="image-20211226230903851"></p><h4 id="限位排列"><a href="#限位排列" class="headerlink" title="限位排列"></a>限位排列</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226232152277.png" alt="image-20211226232152277"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226232124707.png" alt="image-20211226232124707"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226232748066.png" alt="image-20211226232748066"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226233451466.png" alt="image-20211226233451466"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226234149754.png" alt="image-20211226234149754"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211226235909814.png" alt="image-20211226235909814"></p><h4 id="广义容斥原理"><a href="#广义容斥原理" class="headerlink" title="广义容斥原理"></a>广义容斥原理</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211229163127509.png" alt="image-20211229163127509"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227000733734.png" alt="image-20211227000733734"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227000843748.png" alt="image-20211227000843748"></p><h3 id="第四章-母函数"><a href="#第四章-母函数" class="headerlink" title="第四章 母函数"></a>第四章 母函数</h3><h4 id="普通母函数"><a href="#普通母函数" class="headerlink" title="普通母函数"></a>普通母函数</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227135359847.png" alt="image-20211227135359847"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227142855595.png" alt="image-20211227142855595"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227145003102.png" alt="image-20211227145003102"></p><h4 id="指数母函数"><a href="#指数母函数" class="headerlink" title="指数母函数"></a>指数母函数</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227145055341.png" alt="image-20211227145055341"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227151526326.png" alt="image-20211227151526326"></p><h4 id="母函数的基本运算"><a href="#母函数的基本运算" class="headerlink" title="母函数的基本运算"></a>母函数的基本运算</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227152123637.png" alt="image-20211227152123637"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227155128898.png" alt="image-20211227155128898"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227184144605.png" alt="image-20211227184144605"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227184717986.png" alt="image-20211227184717986"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227185614073.png" alt="image-20211227185614073"></p><h4 id="母函数的应用"><a href="#母函数的应用" class="headerlink" title="母函数的应用"></a>母函数的应用</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227201840762.png" alt="image-20211227201840762"></p><p>正确答案是 3328</p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227211021936.png" alt="image-20211227211021936"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227213012792.png" alt="image-20211227213012792"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227222020925.png" alt="image-20211227222020925"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227224850721.png" alt="image-20211227224850721"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227230120072.png" alt="image-20211227230120072"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227231045805.png" alt="image-20211227231045805"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227231854917.png" alt="image-20211227231854917"></p><h4 id="在组合恒等式中的应用"><a href="#在组合恒等式中的应用" class="headerlink" title="在组合恒等式中的应用"></a>在组合恒等式中的应用</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227233858910.png" alt="image-20211227233858910"></h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211227234004435.png" alt="image-20211227234004435"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228001711832.png" alt="image-20211228001711832"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228003412718.png" alt="image-20211228003412718"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228003900687.png" alt="image-20211228003900687"></p><h3 id="第五章-递推关系"><a href="#第五章-递推关系" class="headerlink" title="第五章 递推关系"></a>第五章 递推关系</h3><h4 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h4><h4 id="常系数线性齐次递推关系"><a href="#常系数线性齐次递推关系" class="headerlink" title="常系数线性齐次递推关系"></a>常系数线性齐次递推关系</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228134205022.png" alt="image-20211228134205022"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228134843099.png" alt="image-20211228134843099"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228133825567.png" alt="image-20211228133825567"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228202057015.png" alt="image-20211228202057015"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228204412120.png" alt="image-20211228204412120"></p><h4 id="非齐次常系数线性递推关系"><a href="#非齐次常系数线性递推关系" class="headerlink" title="非齐次常系数线性递推关系"></a>非齐次常系数线性递推关系</h4><h4 id="迭代法与归纳法"><a href="#迭代法与归纳法" class="headerlink" title="迭代法与归纳法"></a>迭代法与归纳法</h4><h4 id="母函数在递推关系中的应用"><a href="#母函数在递推关系中的应用" class="headerlink" title="母函数在递推关系中的应用"></a>母函数在递推关系中的应用</h4><h3 id="第六章-特殊计数"><a href="#第六章-特殊计数" class="headerlink" title="第六章  特殊计数"></a>第六章  特殊计数</h3><h4 id="Fibonacci数"><a href="#Fibonacci数" class="headerlink" title="Fibonacci数"></a>Fibonacci数</h4><h4 id="Catalan-数"><a href="#Catalan-数" class="headerlink" title="Catalan 数"></a>Catalan 数</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228184224636.png" alt="image-20211228184224636"></p><h4 id="Stirling-数"><a href="#Stirling-数" class="headerlink" title="Stirling 数"></a>Stirling 数</h4><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228143948706.png" alt="image-20211228143948706"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228150050480.png" alt="image-20211228150050480"></p><p><img src="/../images/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211228143811239.png" alt="image-20211228143811239"></p><h4 id="Bell-数"><a href="#Bell-数" class="headerlink" title="Bell 数"></a>Bell 数</h4><h4 id="差分序列"><a href="#差分序列" class="headerlink" title="差分序列"></a>差分序列</h4><h4 id="分拆数"><a href="#分拆数" class="headerlink" title="分拆数"></a>分拆数</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;组合数学&lt;/center&gt;

&lt;h3 id=&quot;第一章-排列与组合&quot;&gt;&lt;a href=&quot;#第一章-排列与组合&quot; class=&quot;headerlink&quot; title=&quot;第一章 排列与组合&quot;&gt;&lt;/a&gt;第一章 排列与组合&lt;/h3&gt;&lt;h4 id=&quot;排列&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="组合数学" scheme="https://zhengluoliudao.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JZ_Offer</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/JZ-Offer/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/JZ-Offer/</id>
    <published>2022-01-02T09:49:40.000Z</published>
    <updated>2022-01-02T09:51:12.579Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br><span class="line">2237</span><br><span class="line">2238</span><br><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br><span class="line">2257</span><br><span class="line">2258</span><br><span class="line">2259</span><br><span class="line">2260</span><br><span class="line">2261</span><br><span class="line">2262</span><br><span class="line">2263</span><br><span class="line">2264</span><br><span class="line">2265</span><br><span class="line">2266</span><br><span class="line">2267</span><br><span class="line">2268</span><br><span class="line">2269</span><br><span class="line">2270</span><br><span class="line">2271</span><br><span class="line">2272</span><br><span class="line">2273</span><br><span class="line">2274</span><br><span class="line">2275</span><br><span class="line">2276</span><br><span class="line">2277</span><br><span class="line">2278</span><br><span class="line">2279</span><br><span class="line">2280</span><br><span class="line">2281</span><br><span class="line">2282</span><br><span class="line">2283</span><br><span class="line">2284</span><br><span class="line">2285</span><br><span class="line">2286</span><br><span class="line">2287</span><br><span class="line">2288</span><br><span class="line">2289</span><br><span class="line">2290</span><br><span class="line">2291</span><br><span class="line">2292</span><br><span class="line">2293</span><br><span class="line">2294</span><br><span class="line">2295</span><br><span class="line">2296</span><br><span class="line">2297</span><br><span class="line">2298</span><br><span class="line">2299</span><br><span class="line">2300</span><br><span class="line">2301</span><br><span class="line">2302</span><br><span class="line">2303</span><br><span class="line">2304</span><br><span class="line">2305</span><br><span class="line">2306</span><br><span class="line">2307</span><br><span class="line">2308</span><br><span class="line">2309</span><br><span class="line">2310</span><br><span class="line">2311</span><br><span class="line">2312</span><br><span class="line">2313</span><br><span class="line">2314</span><br><span class="line">2315</span><br><span class="line">2316</span><br><span class="line">2317</span><br><span class="line">2318</span><br><span class="line">2319</span><br><span class="line">2320</span><br><span class="line">2321</span><br><span class="line">2322</span><br><span class="line">2323</span><br><span class="line">2324</span><br><span class="line">2325</span><br><span class="line">2326</span><br><span class="line">2327</span><br><span class="line">2328</span><br><span class="line">2329</span><br><span class="line">2330</span><br><span class="line">2331</span><br><span class="line">2332</span><br><span class="line">2333</span><br><span class="line">2334</span><br><span class="line">2335</span><br><span class="line">2336</span><br><span class="line">2337</span><br><span class="line">2338</span><br><span class="line">2339</span><br><span class="line">2340</span><br><span class="line">2341</span><br><span class="line">2342</span><br><span class="line">2343</span><br><span class="line">2344</span><br><span class="line">2345</span><br><span class="line">2346</span><br><span class="line">2347</span><br><span class="line">2348</span><br><span class="line">2349</span><br><span class="line">2350</span><br><span class="line">2351</span><br><span class="line">2352</span><br><span class="line">2353</span><br><span class="line">2354</span><br><span class="line">2355</span><br><span class="line">2356</span><br><span class="line">2357</span><br><span class="line">2358</span><br><span class="line">2359</span><br><span class="line">2360</span><br><span class="line">2361</span><br><span class="line">2362</span><br><span class="line">2363</span><br><span class="line">2364</span><br><span class="line">2365</span><br><span class="line">2366</span><br><span class="line">2367</span><br><span class="line">2368</span><br><span class="line">2369</span><br><span class="line">2370</span><br><span class="line">2371</span><br><span class="line">2372</span><br><span class="line">2373</span><br><span class="line">2374</span><br><span class="line">2375</span><br><span class="line">2376</span><br><span class="line">2377</span><br><span class="line">2378</span><br><span class="line">2379</span><br><span class="line">2380</span><br><span class="line">2381</span><br><span class="line">2382</span><br><span class="line">2383</span><br><span class="line">2384</span><br><span class="line">2385</span><br><span class="line">2386</span><br><span class="line">2387</span><br><span class="line">2388</span><br><span class="line">2389</span><br><span class="line">2390</span><br><span class="line">2391</span><br><span class="line">2392</span><br><span class="line">2393</span><br><span class="line">2394</span><br><span class="line">2395</span><br><span class="line">2396</span><br><span class="line">2397</span><br><span class="line">2398</span><br><span class="line">2399</span><br><span class="line">2400</span><br><span class="line">2401</span><br><span class="line">2402</span><br><span class="line">2403</span><br><span class="line">2404</span><br><span class="line">2405</span><br><span class="line">2406</span><br><span class="line">2407</span><br><span class="line">2408</span><br><span class="line">2409</span><br><span class="line">2410</span><br><span class="line">2411</span><br><span class="line">2412</span><br><span class="line">2413</span><br><span class="line">2414</span><br><span class="line">2415</span><br><span class="line">2416</span><br><span class="line">2417</span><br><span class="line">2418</span><br><span class="line">2419</span><br><span class="line">2420</span><br><span class="line">2421</span><br><span class="line">2422</span><br><span class="line">2423</span><br><span class="line">2424</span><br><span class="line">2425</span><br><span class="line">2426</span><br><span class="line">2427</span><br><span class="line">2428</span><br><span class="line">2429</span><br><span class="line">2430</span><br><span class="line">2431</span><br><span class="line">2432</span><br><span class="line">2433</span><br><span class="line">2434</span><br><span class="line">2435</span><br><span class="line">2436</span><br><span class="line">2437</span><br><span class="line">2438</span><br><span class="line">2439</span><br><span class="line">2440</span><br><span class="line">2441</span><br><span class="line">2442</span><br><span class="line">2443</span><br><span class="line">2444</span><br><span class="line">2445</span><br><span class="line">2446</span><br><span class="line">2447</span><br><span class="line">2448</span><br><span class="line">2449</span><br><span class="line">2450</span><br><span class="line">2451</span><br><span class="line">2452</span><br><span class="line">2453</span><br><span class="line">2454</span><br><span class="line">2455</span><br><span class="line">2456</span><br><span class="line">2457</span><br><span class="line">2458</span><br><span class="line">2459</span><br><span class="line">2460</span><br><span class="line">2461</span><br><span class="line">2462</span><br><span class="line">2463</span><br><span class="line">2464</span><br><span class="line">2465</span><br><span class="line">2466</span><br><span class="line">2467</span><br><span class="line">2468</span><br><span class="line">2469</span><br><span class="line">2470</span><br><span class="line">2471</span><br><span class="line">2472</span><br><span class="line">2473</span><br><span class="line">2474</span><br><span class="line">2475</span><br><span class="line">2476</span><br><span class="line">2477</span><br><span class="line">2478</span><br><span class="line">2479</span><br><span class="line">2480</span><br><span class="line">2481</span><br><span class="line">2482</span><br><span class="line">2483</span><br><span class="line">2484</span><br><span class="line">2485</span><br><span class="line">2486</span><br><span class="line">2487</span><br><span class="line">2488</span><br><span class="line">2489</span><br><span class="line">2490</span><br><span class="line">2491</span><br><span class="line">2492</span><br><span class="line">2493</span><br><span class="line">2494</span><br><span class="line">2495</span><br><span class="line">2496</span><br><span class="line">2497</span><br><span class="line">2498</span><br><span class="line">2499</span><br><span class="line">2500</span><br><span class="line">2501</span><br><span class="line">2502</span><br><span class="line">2503</span><br><span class="line">2504</span><br><span class="line">2505</span><br><span class="line">2506</span><br><span class="line">2507</span><br><span class="line">2508</span><br><span class="line">2509</span><br><span class="line">2510</span><br><span class="line">2511</span><br><span class="line">2512</span><br><span class="line">2513</span><br><span class="line">2514</span><br><span class="line">2515</span><br><span class="line">2516</span><br><span class="line">2517</span><br><span class="line">2518</span><br><span class="line">2519</span><br><span class="line">2520</span><br><span class="line">2521</span><br><span class="line">2522</span><br><span class="line">2523</span><br><span class="line">2524</span><br><span class="line">2525</span><br><span class="line">2526</span><br><span class="line">2527</span><br><span class="line">2528</span><br><span class="line">2529</span><br><span class="line">2530</span><br><span class="line">2531</span><br><span class="line">2532</span><br><span class="line">2533</span><br><span class="line">2534</span><br><span class="line">2535</span><br><span class="line">2536</span><br><span class="line">2537</span><br><span class="line">2538</span><br><span class="line">2539</span><br><span class="line">2540</span><br><span class="line">2541</span><br><span class="line">2542</span><br><span class="line">2543</span><br><span class="line">2544</span><br><span class="line">2545</span><br><span class="line">2546</span><br><span class="line">2547</span><br><span class="line">2548</span><br><span class="line">2549</span><br><span class="line">2550</span><br><span class="line">2551</span><br><span class="line">2552</span><br><span class="line">2553</span><br><span class="line">2554</span><br><span class="line">2555</span><br><span class="line">2556</span><br><span class="line">2557</span><br><span class="line">2558</span><br><span class="line">2559</span><br><span class="line">2560</span><br><span class="line">2561</span><br><span class="line">2562</span><br><span class="line">2563</span><br><span class="line">2564</span><br><span class="line">2565</span><br><span class="line">2566</span><br><span class="line">2567</span><br><span class="line">2568</span><br><span class="line">2569</span><br><span class="line">2570</span><br><span class="line">2571</span><br><span class="line">2572</span><br><span class="line">2573</span><br><span class="line">2574</span><br><span class="line">2575</span><br><span class="line">2576</span><br><span class="line">2577</span><br><span class="line">2578</span><br><span class="line">2579</span><br><span class="line">2580</span><br><span class="line">2581</span><br><span class="line">2582</span><br><span class="line">2583</span><br><span class="line">2584</span><br><span class="line">2585</span><br><span class="line">2586</span><br><span class="line">2587</span><br><span class="line">2588</span><br><span class="line">2589</span><br><span class="line">2590</span><br><span class="line">2591</span><br><span class="line">2592</span><br><span class="line">2593</span><br><span class="line">2594</span><br><span class="line">2595</span><br><span class="line">2596</span><br><span class="line">2597</span><br><span class="line">2598</span><br><span class="line">2599</span><br><span class="line">2600</span><br><span class="line">2601</span><br><span class="line">2602</span><br><span class="line">2603</span><br><span class="line">2604</span><br><span class="line">2605</span><br><span class="line">2606</span><br><span class="line">2607</span><br><span class="line">2608</span><br><span class="line">2609</span><br><span class="line">2610</span><br><span class="line">2611</span><br><span class="line">2612</span><br><span class="line">2613</span><br><span class="line">2614</span><br><span class="line">2615</span><br><span class="line">2616</span><br><span class="line">2617</span><br><span class="line">2618</span><br><span class="line">2619</span><br><span class="line">2620</span><br><span class="line">2621</span><br><span class="line">2622</span><br><span class="line">2623</span><br><span class="line">2624</span><br><span class="line">2625</span><br><span class="line">2626</span><br><span class="line">2627</span><br><span class="line">2628</span><br><span class="line">2629</span><br><span class="line">2630</span><br><span class="line">2631</span><br><span class="line">2632</span><br><span class="line">2633</span><br><span class="line">2634</span><br><span class="line">2635</span><br><span class="line">2636</span><br><span class="line">2637</span><br><span class="line">2638</span><br><span class="line">2639</span><br><span class="line">2640</span><br><span class="line">2641</span><br><span class="line">2642</span><br><span class="line">2643</span><br><span class="line">2644</span><br><span class="line">2645</span><br><span class="line">2646</span><br><span class="line">2647</span><br><span class="line">2648</span><br><span class="line">2649</span><br><span class="line">2650</span><br><span class="line">2651</span><br><span class="line">2652</span><br><span class="line">2653</span><br><span class="line">2654</span><br><span class="line">2655</span><br><span class="line">2656</span><br><span class="line">2657</span><br><span class="line">2658</span><br><span class="line">2659</span><br><span class="line">2660</span><br><span class="line">2661</span><br><span class="line">2662</span><br><span class="line">2663</span><br><span class="line">2664</span><br><span class="line">2665</span><br><span class="line">2666</span><br><span class="line">2667</span><br><span class="line">2668</span><br><span class="line">2669</span><br><span class="line">2670</span><br><span class="line">2671</span><br><span class="line">2672</span><br><span class="line">2673</span><br><span class="line">2674</span><br><span class="line">2675</span><br><span class="line">2676</span><br><span class="line">2677</span><br><span class="line">2678</span><br><span class="line">2679</span><br><span class="line">2680</span><br><span class="line">2681</span><br><span class="line">2682</span><br><span class="line">2683</span><br><span class="line">2684</span><br><span class="line">2685</span><br><span class="line">2686</span><br><span class="line">2687</span><br><span class="line">2688</span><br><span class="line">2689</span><br><span class="line">2690</span><br><span class="line">2691</span><br><span class="line">2692</span><br><span class="line">2693</span><br><span class="line">2694</span><br><span class="line">2695</span><br><span class="line">2696</span><br><span class="line">2697</span><br><span class="line">2698</span><br><span class="line">2699</span><br><span class="line">2700</span><br><span class="line">2701</span><br><span class="line">2702</span><br><span class="line">2703</span><br><span class="line">2704</span><br><span class="line">2705</span><br><span class="line">2706</span><br><span class="line">2707</span><br><span class="line">2708</span><br><span class="line">2709</span><br><span class="line">2710</span><br><span class="line">2711</span><br><span class="line">2712</span><br><span class="line">2713</span><br><span class="line">2714</span><br><span class="line">2715</span><br><span class="line">2716</span><br><span class="line">2717</span><br><span class="line">2718</span><br><span class="line">2719</span><br><span class="line">2720</span><br><span class="line">2721</span><br><span class="line">2722</span><br><span class="line">2723</span><br><span class="line">2724</span><br><span class="line">2725</span><br><span class="line">2726</span><br><span class="line">2727</span><br><span class="line">2728</span><br><span class="line">2729</span><br><span class="line">2730</span><br><span class="line">2731</span><br><span class="line">2732</span><br><span class="line">2733</span><br><span class="line">2734</span><br><span class="line">2735</span><br><span class="line">2736</span><br><span class="line">2737</span><br><span class="line">2738</span><br><span class="line">2739</span><br><span class="line">2740</span><br><span class="line">2741</span><br><span class="line">2742</span><br><span class="line">2743</span><br><span class="line">2744</span><br><span class="line">2745</span><br><span class="line">2746</span><br><span class="line">2747</span><br><span class="line">2748</span><br><span class="line">2749</span><br><span class="line">2750</span><br><span class="line">2751</span><br><span class="line">2752</span><br><span class="line">2753</span><br><span class="line">2754</span><br><span class="line">2755</span><br><span class="line">2756</span><br><span class="line">2757</span><br><span class="line">2758</span><br><span class="line">2759</span><br><span class="line">2760</span><br><span class="line">2761</span><br><span class="line">2762</span><br><span class="line">2763</span><br><span class="line">2764</span><br><span class="line">2765</span><br><span class="line">2766</span><br><span class="line">2767</span><br><span class="line">2768</span><br><span class="line">2769</span><br><span class="line">2770</span><br><span class="line">2771</span><br><span class="line">2772</span><br><span class="line">2773</span><br><span class="line">2774</span><br><span class="line">2775</span><br><span class="line">2776</span><br><span class="line">2777</span><br><span class="line">2778</span><br><span class="line">2779</span><br><span class="line">2780</span><br><span class="line">2781</span><br><span class="line">2782</span><br><span class="line">2783</span><br><span class="line">2784</span><br><span class="line">2785</span><br><span class="line">2786</span><br><span class="line">2787</span><br><span class="line">2788</span><br><span class="line">2789</span><br><span class="line">2790</span><br><span class="line">2791</span><br><span class="line">2792</span><br><span class="line">2793</span><br><span class="line">2794</span><br><span class="line">2795</span><br><span class="line">2796</span><br><span class="line">2797</span><br><span class="line">2798</span><br><span class="line">2799</span><br><span class="line">2800</span><br><span class="line">2801</span><br><span class="line">2802</span><br><span class="line">2803</span><br><span class="line">2804</span><br><span class="line">2805</span><br><span class="line">2806</span><br><span class="line">2807</span><br><span class="line">2808</span><br><span class="line">2809</span><br><span class="line">2810</span><br><span class="line">2811</span><br><span class="line">2812</span><br><span class="line">2813</span><br><span class="line">2814</span><br><span class="line">2815</span><br><span class="line">2816</span><br><span class="line">2817</span><br><span class="line">2818</span><br><span class="line">2819</span><br><span class="line">2820</span><br><span class="line">2821</span><br><span class="line">2822</span><br><span class="line">2823</span><br><span class="line">2824</span><br><span class="line">2825</span><br><span class="line">2826</span><br><span class="line">2827</span><br><span class="line">2828</span><br><span class="line">2829</span><br><span class="line">2830</span><br><span class="line">2831</span><br><span class="line">2832</span><br><span class="line">2833</span><br><span class="line">2834</span><br><span class="line">2835</span><br><span class="line">2836</span><br><span class="line">2837</span><br><span class="line">2838</span><br><span class="line">2839</span><br><span class="line">2840</span><br><span class="line">2841</span><br><span class="line">2842</span><br><span class="line">2843</span><br><span class="line">2844</span><br><span class="line">2845</span><br><span class="line">2846</span><br><span class="line">2847</span><br><span class="line">2848</span><br><span class="line">2849</span><br><span class="line">2850</span><br><span class="line">2851</span><br><span class="line">2852</span><br><span class="line">2853</span><br><span class="line">2854</span><br><span class="line">2855</span><br><span class="line">2856</span><br><span class="line">2857</span><br><span class="line">2858</span><br><span class="line">2859</span><br><span class="line">2860</span><br><span class="line">2861</span><br><span class="line">2862</span><br><span class="line">2863</span><br><span class="line">2864</span><br><span class="line">2865</span><br><span class="line">2866</span><br><span class="line">2867</span><br><span class="line">2868</span><br><span class="line">2869</span><br><span class="line">2870</span><br><span class="line">2871</span><br><span class="line">2872</span><br><span class="line">2873</span><br><span class="line">2874</span><br><span class="line">2875</span><br><span class="line">2876</span><br><span class="line">2877</span><br><span class="line">2878</span><br><span class="line">2879</span><br><span class="line">2880</span><br><span class="line">2881</span><br><span class="line">2882</span><br><span class="line">2883</span><br><span class="line">2884</span><br><span class="line">2885</span><br><span class="line">2886</span><br><span class="line">2887</span><br><span class="line">2888</span><br><span class="line">2889</span><br><span class="line">2890</span><br><span class="line">2891</span><br><span class="line">2892</span><br><span class="line">2893</span><br><span class="line">2894</span><br><span class="line">2895</span><br><span class="line">2896</span><br><span class="line">2897</span><br><span class="line">2898</span><br><span class="line">2899</span><br><span class="line">2900</span><br><span class="line">2901</span><br><span class="line">2902</span><br><span class="line">2903</span><br><span class="line">2904</span><br><span class="line">2905</span><br><span class="line">2906</span><br><span class="line">2907</span><br><span class="line">2908</span><br><span class="line">2909</span><br><span class="line">2910</span><br><span class="line">2911</span><br><span class="line">2912</span><br><span class="line">2913</span><br><span class="line">2914</span><br><span class="line">2915</span><br><span class="line">2916</span><br><span class="line">2917</span><br><span class="line">2918</span><br><span class="line">2919</span><br><span class="line">2920</span><br><span class="line">2921</span><br><span class="line">2922</span><br><span class="line">2923</span><br><span class="line">2924</span><br><span class="line">2925</span><br><span class="line">2926</span><br><span class="line">2927</span><br><span class="line">2928</span><br><span class="line">2929</span><br><span class="line">2930</span><br><span class="line">2931</span><br><span class="line">2932</span><br><span class="line">2933</span><br><span class="line">2934</span><br><span class="line">2935</span><br><span class="line">2936</span><br><span class="line">2937</span><br><span class="line">2938</span><br><span class="line">2939</span><br><span class="line">2940</span><br><span class="line">2941</span><br><span class="line">2942</span><br><span class="line">2943</span><br><span class="line">2944</span><br><span class="line">2945</span><br><span class="line">2946</span><br><span class="line">2947</span><br><span class="line">2948</span><br><span class="line">2949</span><br><span class="line">2950</span><br><span class="line">2951</span><br><span class="line">2952</span><br><span class="line">2953</span><br><span class="line">2954</span><br><span class="line">2955</span><br><span class="line">2956</span><br><span class="line">2957</span><br><span class="line">2958</span><br><span class="line">2959</span><br><span class="line">2960</span><br><span class="line">2961</span><br><span class="line">2962</span><br><span class="line">2963</span><br><span class="line">2964</span><br><span class="line">2965</span><br><span class="line">2966</span><br><span class="line">2967</span><br><span class="line">2968</span><br><span class="line">2969</span><br><span class="line">2970</span><br><span class="line">2971</span><br><span class="line">2972</span><br><span class="line">2973</span><br><span class="line">2974</span><br><span class="line">2975</span><br><span class="line">2976</span><br><span class="line">2977</span><br><span class="line">2978</span><br><span class="line">2979</span><br><span class="line">2980</span><br><span class="line">2981</span><br><span class="line">2982</span><br><span class="line">2983</span><br><span class="line">2984</span><br><span class="line">2985</span><br><span class="line">2986</span><br><span class="line">2987</span><br><span class="line">2988</span><br><span class="line">2989</span><br><span class="line">2990</span><br><span class="line">2991</span><br><span class="line">2992</span><br><span class="line">2993</span><br><span class="line">2994</span><br><span class="line">2995</span><br></pre></td><td class="code"><pre><span class="line">#给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？</span><br><span class="line">#输出需要删除的字符个数</span><br><span class="line"></span><br><span class="line">#解题思路：回文串的特点，想到将源字符串逆转后，“回文串”（不一定连续）相当于顺序没变</span><br><span class="line">#求原字符串和其反串的最大公共子序列（不是子串，因为可以不连续）的长度，然后用原字符串的长度减去这个最大公共子串的长度就得到了最小编辑长度。</span><br><span class="line">#用dp解决lcs: 相等  dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">#           不相等  dp[i][j] = max&#123;dp[i-1][j], dp[i][j-1]&#125;</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def lcs(line):</span><br><span class="line">    if line==None or len(line) == 0:</span><br><span class="line">        return 0</span><br><span class="line">    line_reverse = line[::-1]</span><br><span class="line">    line_len = len(line)</span><br><span class="line">    #注意，这样申请二维数组是错误的，因为[0] * 5是一个一维数组的对象，* 3的话只是把对象的引用复制了3次，还是同一个地址，修改会一起被修改</span><br><span class="line">    #错误！！！  dp = [[0] * (line_len+1)] * (line_len + 1)  </span><br><span class="line">    dp =[[0] *(line_len+1) for _ in range(line_len+1)]</span><br><span class="line">    for i in range(1, line_len+1):</span><br><span class="line">        for j in range(1, line_len+1):</span><br><span class="line">            if line[i-1] == line_reverse[j-1]:</span><br><span class="line">                dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span><br><span class="line">    lcs_len = dp[-1][-1]</span><br><span class="line">    return lcs_len</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try:</span><br><span class="line">        for line in sys.stdin:</span><br><span class="line">            line = line.strip()</span><br><span class="line">            line_len = len(line)</span><br><span class="line">            if line_len == 0:</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                lcs_len = lcs(line)</span><br><span class="line">                drop_len =  line_len - lcs_len</span><br><span class="line">            print(drop_len)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#注意：碰到了楼上Python解法同样的问题，没把循环过程放到name中，一直说是过90% </span><br><span class="line">#然后超时，放进去就好了。猜一下：是不是给了程序入口能加快解析  # -*- coding:utf-8 -*-</span><br><span class="line">import sys</span><br><span class="line">def maxlcp(s):</span><br><span class="line">    if s==None or len(s)==0:</span><br><span class="line">        return 0</span><br><span class="line">    leng = len(s)</span><br><span class="line">    dp =[]</span><br><span class="line">    dp =[[0] *(leng+1) for _ in range(leng+1)]</span><br><span class="line">    for i in range(1,lens+1):</span><br><span class="line">        for j in range(1,lens+1):</span><br><span class="line">            if s[i-1] == s[leng-j]: #not include i,j</span><br><span class="line">                dp[i][j] = dp[i-1][j-1] +1</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = max(dp[i-1][j],dp[i][j-1])</span><br><span class="line">    return dp[-1][-1]</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    while True:</span><br><span class="line">        line = sys.stdin.readline().strip()</span><br><span class="line">        lens = len(line)</span><br><span class="line">        if not line:</span><br><span class="line">            break</span><br><span class="line">        maxLcp = maxlcp(line)</span><br><span class="line">        print(lens - maxLcp)</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。</span><br><span class="line">#你能帮帮小Q吗？</span><br><span class="line"></span><br><span class="line">#解题思想：冒泡</span><br><span class="line">try:</span><br><span class="line">    while True:</span><br><span class="line">        s = input().strip()</span><br><span class="line">        if s == &#x27;&#x27;:</span><br><span class="line">            break</span><br><span class="line">        for i in s:</span><br><span class="line">            if i.isupper():</span><br><span class="line">                s = s+i</span><br><span class="line">                s = s[0:s.index(i)] + s[s.index(i)+1 : ]</span><br><span class="line">        print(s)</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#小Q今天在上厕所时想到了这个问题：有n个数，两两组成二元组，相差最小的有多少对呢？相差最大呢？</span><br><span class="line">#解题思路：先排序， 1.差值最大的好求，看有序数组有几个最小值和几个最大值，相乘即可</span><br><span class="line">#                  2. 差值最小的，由有序数组生成差值数组</span><br><span class="line">import sys</span><br><span class="line">try:</span><br><span class="line">    #for line in sys.stdin:</span><br><span class="line">    while True:</span><br><span class="line">        N = input().strip()</span><br><span class="line">        nums = input().strip().split(&quot; &quot;)</span><br><span class="line">        nums = [(int)(i) for i in nums]</span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        Dict = &#123;&#125;</span><br><span class="line">        for i in nums:</span><br><span class="line">            if i in Dict.keys():</span><br><span class="line">                Dict[i] += 1</span><br><span class="line">            else:</span><br><span class="line">                Dict[i] = 1</span><br><span class="line">        num_max = Dict[nums[0]] * Dict[nums[-1]]</span><br><span class="line">        num_min = 0</span><br><span class="line">        for i in Dict.values():</span><br><span class="line">            if i &gt;= 2:</span><br><span class="line">                tmp = i*(i-1)/2</span><br><span class="line">                num_min += tmp</span><br><span class="line">        if num_min == 0: #说明没有相同的数字，即不存在差值为0</span><br><span class="line">            nums_2 = []</span><br><span class="line">            for i in range(len(nums)-1):</span><br><span class="line">                nums_2.append(nums[i+1]-nums[i])</span><br><span class="line">            nums_2.sort()</span><br><span class="line">            num_min = nums_2.count(nums_2[0])</span><br><span class="line">        num_min = (int)(num_min)</span><br><span class="line">        print((str)(num_min) + &quot; &quot; + (str)(num_max))</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    temp = [int(i) for i in line.split()]</span><br><span class="line">    if len(temp) == 1:</span><br><span class="line">        # 把N跳过</span><br><span class="line">        continue</span><br><span class="line">    temp.sort()</span><br><span class="line">    Dict = &#123;&#125;</span><br><span class="line">    for i in temp:</span><br><span class="line">        if i in Dict:</span><br><span class="line">            Dict[i] += 1</span><br><span class="line">        else:</span><br><span class="line">            Dict[i] = 1</span><br><span class="line">    res = 0</span><br><span class="line">    for k in Dict.keys():</span><br><span class="line">        if Dict[k] &gt;= 2:</span><br><span class="line">            temp2 = [i for i in range(Dict[k])]</span><br><span class="line">            res += sum(temp2)</span><br><span class="line">    if res == 0: </span><br><span class="line">        # 没重复的情况，比如[1,2,3,9]这种</span><br><span class="line">        temp3 = []</span><br><span class="line">        for j in range(len(temp)-1):</span><br><span class="line">            temp3.append(temp[j+1] - temp[j])</span><br><span class="line">        temp3.sort()</span><br><span class="line">        # print()会换行，算例通不过，加了end就不会换行</span><br><span class="line">        print(temp3.count(temp3[0]), end=&quot; &quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(res, end=&quot; &quot;)</span><br><span class="line">    num_max, num_min = Dict[temp[-1]], Dict[temp[0]]</span><br><span class="line">    print(num_max*num_min)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#链接：https://www.nowcoder.com/questionTerminal/11ee0516a988421abf40b315a2b28d08?answerType=1&amp;f=discussion</span><br><span class="line">#现在有107个用户，编号为1- 107，现在已知有m对关系，每一对关系给你两个数x和y，代表编号为x的用户和编号为y的用户是在一个圈子中，</span><br><span class="line"># 例如：A和B在一个圈子中，B和C在一个圈子中，那么A,B,C就在一个圈子中。现在想知道最多的一个圈子内有多少个用户。 </span><br><span class="line"></span><br><span class="line">#解题思路：并查集</span><br><span class="line">#         并查集：要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可</span><br><span class="line">import sys</span><br><span class="line">class unionfind():</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.father = list(range(n+1))</span><br><span class="line">        self.size = [1] * (n+1)</span><br><span class="line">    def find(self, x):</span><br><span class="line">        if self.father[x] == x:</span><br><span class="line">            return x</span><br><span class="line">        self.father[x] = self.find(self.father[x])</span><br><span class="line">        return self.father[x]</span><br><span class="line">    def merge(self,x,y):</span><br><span class="line">        fx = self.find(x)</span><br><span class="line">        fy = self.find(y)</span><br><span class="line">        if fx != fy:</span><br><span class="line">            self.father[fy] = fx</span><br><span class="line">            self.size[fx] += self.size[fy]</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try:</span><br><span class="line">        T = (int)(input().strip())</span><br><span class="line">        for i in range(T):</span><br><span class="line">            n = (int)(input().strip())</span><br><span class="line">            un = unionfind(1000000)</span><br><span class="line">            max_size = 1</span><br><span class="line">            for j in range(n):</span><br><span class="line">                x,y = [(int)(a) for a in input().strip().split()]</span><br><span class="line">                un.merge(x,y)</span><br><span class="line">                max_size = max(max_size, un.size[un.find(x)])</span><br><span class="line">            print(max_size)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">import sys</span><br><span class="line">class unionfind():</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.father = list(range(n+1))</span><br><span class="line">        self.size = [1] * (n+1)</span><br><span class="line">    def find(self, x):</span><br><span class="line">        if self.father[x] == x:</span><br><span class="line">            return x</span><br><span class="line">        self.father[x] = self.find(self.father[x])</span><br><span class="line">        return self.father[x]</span><br><span class="line">    def merge(self,x,y):</span><br><span class="line">        fx = self.find(x)</span><br><span class="line">        fy = self.find(y)</span><br><span class="line">        if fx != fy:</span><br><span class="line">            self.father[fy] = fx</span><br><span class="line">            self.size[fx] += self.size[fy]</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">n1 = int(input())</span><br><span class="line">for i in range(n1):</span><br><span class="line">    n2 = int(input())</span><br><span class="line">    un = unionfind(1000000)</span><br><span class="line">    res = 1</span><br><span class="line">    for j in range(n2):</span><br><span class="line">        line = sys.stdin.readline().strip()</span><br><span class="line">        a,b = list(map(int, line.split()))</span><br><span class="line">        un.merge(a,b)</span><br><span class="line">        res = max(res,un.size[un.find(a)])</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#输入一个字符串 s，s 由小写英文字母组成，保证 s 长度小于等于 5000 并且大于等于 1。在 s 的所有不同的子串中，输出字典序第 k 小的字符串。</span><br><span class="line">#字符串中任意个连续的字符组成的子序列称为该字符串的子串。字母序表示英文单词在字典中的先后顺序，</span><br><span class="line">#即先比较第一个字母，若第一个字母相同，则比较第二个字母的字典序，依次类推，则可比较出该字符串的字典序大小</span><br><span class="line"></span><br><span class="line">#解题思路：字典序第k小, 投机取巧真的爽，首先肯定长度为k（不然减少或到不了第k个），那么可以把所有连续的长度为k的子串都截取出来，</span><br><span class="line"># 然后根据前k个字符串排序</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try: </span><br><span class="line">        s = input().strip()</span><br><span class="line">        k = (int)(input())</span><br><span class="line">        str_set = []</span><br><span class="line">        for i in range(len(s)-k):</span><br><span class="line">            str_set.append(s[i:i+k])</span><br><span class="line">        </span><br><span class="line">        res = sorted(str_set)</span><br><span class="line">        print(res[0])</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try: </span><br><span class="line">        s = input().strip()</span><br><span class="line">        k = (int)(input())</span><br><span class="line">        str_set = []</span><br><span class="line">        for i in range(len(s)-k):</span><br><span class="line">            str_set.append(s[i:i+k])</span><br><span class="line">        </span><br><span class="line">        if k == 1:</span><br><span class="line">            #sort和sorted不同，前者会改变原字符串            </span><br><span class="line">            res = sorted(str_set, key = lambda x:(x[0]))</span><br><span class="line">        elif k == 2:</span><br><span class="line">            res = sorted(str_set, key = lambda x:(x[0], x[1]))</span><br><span class="line">        elif k == 3:</span><br><span class="line">            res = sorted(str_set, key = lambda x:(x[0], x[1], x[2]))</span><br><span class="line">        elif k == 4:</span><br><span class="line">            res = sorted(str_set, key = lambda x:(x[0], x[1], x[2], x[3]))</span><br><span class="line">        else:</span><br><span class="line">            res = sorted(str_set, key = lambda x:(x[0], x[1], x[2], x[3], x[4]))</span><br><span class="line">        print(res[0])</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">#投机取巧，nb</span><br><span class="line">s=input().strip()</span><br><span class="line">k=int(input())</span><br><span class="line">A=[]</span><br><span class="line">for i in range(len(s)-k):</span><br><span class="line">    A.append(s[i:i+k])</span><br><span class="line">if k==1:</span><br><span class="line">    A=sorted(A,key=lambda x:(x[0]))</span><br><span class="line">elif k==2:</span><br><span class="line">    A=sorted(A,key=lambda x:(x[0],x[1]))</span><br><span class="line">elif k==3:</span><br><span class="line">    A=sorted(A,key=lambda x:(x[0],x[1],x[2]))</span><br><span class="line">elif k==4:</span><br><span class="line">    A=sorted(A,key=lambda x:(x[0],x[1],x[2],x[3]))</span><br><span class="line">else:</span><br><span class="line">    A=sorted(A,key=lambda x:(x[0],x[1],x[2],x[3],x[4]))</span><br><span class="line">print(A[0])</span><br><span class="line"></span><br><span class="line">#暴力枚举</span><br><span class="line">s = input()</span><br><span class="line">k = int(input())</span><br><span class="line">k_str = [0 for i in range(k)]</span><br><span class="line">for i in range(len(s)):</span><br><span class="line">    for j in range(i,min(i+k,len(s))):</span><br><span class="line">        for kk in range(k):</span><br><span class="line">            if k_str[kk]==s[i:j+1]:</span><br><span class="line">                break</span><br><span class="line">            if k_str[kk]==0:</span><br><span class="line">                k_str[kk]=s[i:j+1]</span><br><span class="line">                break</span><br><span class="line">            elif k_str[kk]&gt;s[i:j+1]:</span><br><span class="line">                k_str[kk+1:]=k_str[kk:-1]</span><br><span class="line">                k_str[kk]=s[i:j+1]</span><br><span class="line">                break</span><br><span class="line">print(k_str[-1])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#求抛物线y^2 = 2Ax 与直线y = Bx+ C 所围成的封闭图形面积.若图形不存在,则输出0</span><br><span class="line">#解题思路：数学题，对(f1(x) - f2(x))dy积分，积分上下限为交点y坐标</span><br><span class="line">import math</span><br><span class="line">def get_area(A,B,C,y):</span><br><span class="line">    res = (-1/(6*A)) * y*y*y + (1/(2*B))*y*y - (C/B)*y</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    T = (int)(input().strip())</span><br><span class="line">    for i in range(T):</span><br><span class="line">        </span><br><span class="line">        A,B,C = [(int)(i) for i in input().strip().split()]</span><br><span class="line">        #巨坑，python里的平方不是^2而是**2</span><br><span class="line">        if (A*A - 2*A*B*C)&lt;0:</span><br><span class="line">            print(0)</span><br><span class="line">        else:</span><br><span class="line">            y_up = (1/B)*(A + math.sqrt(A*A-2*A*B*C))</span><br><span class="line">            y_down = (1/B)*(A - math.sqrt(A*A-2*A*B*C))</span><br><span class="line">            res = get_area(A,B,C,y_up) - get_area(A,B,C,y_down)</span><br><span class="line">            print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">samples_num = int(input())  # 测试的样例数</span><br><span class="line"></span><br><span class="line">list_A_B_C = []</span><br><span class="line">for i in range(samples_num):</span><br><span class="line">    list_A_B_C.append(input().split(&quot; &quot;))</span><br><span class="line"></span><br><span class="line">def f(y):</span><br><span class="line">    return -y * y * y / (6 * A) + y * y / (2 * B) - C * y / B</span><br><span class="line"></span><br><span class="line">for A_B_C in list_A_B_C:</span><br><span class="line">    A = int(A_B_C[0])</span><br><span class="line">    B = int(A_B_C[1])</span><br><span class="line">    C = int(A_B_C[-1])</span><br><span class="line">    if A * A - 2 * A * B * C &lt; 0:</span><br><span class="line">        print(0)</span><br><span class="line">    else:</span><br><span class="line">        lb = (A - math.sqrt(A * A - 2 * A * B * C)) / B</span><br><span class="line">        ub = (A + math.sqrt(A * A - 2 * A * B * C)) / B</span><br><span class="line"></span><br><span class="line">        print(f(ub)- f(lb))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#定积分，我靠</span><br><span class="line">from scipy.integrate import quad</span><br><span class="line">from sympy import *</span><br><span class="line">from sympy.core.add import add</span><br><span class="line"></span><br><span class="line">def area_compute():</span><br><span class="line">    t = int(input(&#x27;输入次数t:&#x27;))</span><br><span class="line">    while t:</span><br><span class="line">        t -= 1</span><br><span class="line">        A,B,C = map(float,(input(&#x27;输入三个数:&#x27;).split()))</span><br><span class="line">        </span><br><span class="line">        def func(x):</span><br><span class="line">            y1 = x ** 2 / 2 / A</span><br><span class="line">            y2 = (x - C) / B</span><br><span class="line">            return y2 - y1</span><br><span class="line"></span><br><span class="line">        x = symbols(&#x27;x&#x27;)</span><br><span class="line">        expre = x ** 2 / 2 / A - (x - C) / B</span><br><span class="line">        res = solve(expre, x)  # 计算两线交点</span><br><span class="line">        if isinstance(res[0], Add):  # 解为复数</span><br><span class="line">            print(0)</span><br><span class="line">            continue</span><br><span class="line">        elif len(res)==1:   # 只有一个解</span><br><span class="line">            print(0)</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            fA,err = quad(func,res[0],res[1])   # 用定积分求包含部分的面积</span><br><span class="line">            print(fA)</span><br><span class="line"></span><br><span class="line">area_compute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#数据结构基础之一——队列。队列有五种基本操作，插入队尾、取出队首、删除队首、队列大小、清空队列。</span><br><span class="line">#现在让你模拟一个队列的操作，具体格式参考输入。</span><br><span class="line"></span><br><span class="line">#解题思路: 构建队列</span><br><span class="line">class my_queue():  #其实隐式继承了object，不然是class my_queue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.A = []</span><br><span class="line"></span><br><span class="line">    def my_push(self, i):</span><br><span class="line">        self.A.append(i)</span><br><span class="line"></span><br><span class="line">    def my_top(self):</span><br><span class="line">        if len(self.A) == 0:</span><br><span class="line">            print(-1)</span><br><span class="line">        else:</span><br><span class="line">            print(self.A[0])</span><br><span class="line"></span><br><span class="line">    def my_pop(self):</span><br><span class="line">        if len(self.A) == 0:</span><br><span class="line">            print(-1)</span><br><span class="line">        else:</span><br><span class="line">            self.A = self.A[1:]</span><br><span class="line"></span><br><span class="line">    def my_size(self):</span><br><span class="line">        print(len(self.A))</span><br><span class="line"></span><br><span class="line">    def my_clear(self):</span><br><span class="line">        self.A = []</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    T = (int)(input().strip())</span><br><span class="line">    for i in range(T):</span><br><span class="line">        Q = (int)(input().strip())</span><br><span class="line">        A = my_queue()</span><br><span class="line">        for j in range(Q):</span><br><span class="line">            line = input().strip().split()</span><br><span class="line">            if line[0] == &#x27;PUSH&#x27;:</span><br><span class="line">                A.my_push((int)(line[1]))</span><br><span class="line">            elif line[0] == &#x27;TOP&#x27;:</span><br><span class="line">                A.my_top()</span><br><span class="line">            elif line[0] == &#x27;POP&#x27;:</span><br><span class="line">                A.my_pop()</span><br><span class="line">            elif line[0] == &#x27;SIZE&#x27;:</span><br><span class="line">                A.my_size()</span><br><span class="line">            elif line[0] == &#x27;CLEAR&#x27;:</span><br><span class="line">                A.my_clear()</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">T=int(input())</span><br><span class="line">for i in range(T):  #有T组测试数据</span><br><span class="line">    Q=int(input())  #改组测试数据有Q次操作</span><br><span class="line">    q=[]</span><br><span class="line">    for j in range(Q):</span><br><span class="line">        s = input().strip().split()</span><br><span class="line">        if len(s)==2:     #入队操作</span><br><span class="line">            q.append(s[1])</span><br><span class="line">        else:             #其他操作</span><br><span class="line">            if s[0]==&#x27;TOP&#x27;:          #查看队首</span><br><span class="line">                if len(q)==0:print(-1)</span><br><span class="line">                else:print(q[0])</span><br><span class="line">            elif s[0]==&#x27;SIZE&#x27;:</span><br><span class="line">                print(len(q))</span><br><span class="line">            elif s[0]==&#x27;POP&#x27;:        #出队</span><br><span class="line">                if len(q)==0:print(-1)</span><br><span class="line">                else:del q[0]</span><br><span class="line">            else:                    #clear清空操作</span><br><span class="line">                while len(q)!=0:q.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#界面中存在id=jsContainer的节点A，系统会随机生成id为jsLayout的 m行 x n列 表格(m &gt;= 3, n &gt;= 3)，并随机选中一个td节点，请按照如下需求实现bind函数</span><br><span class="line">#1、bind 函数为每个td节点绑定click事件，当某个td节点被点击时class变为current，同时以该td为中心的同一行和同一列td节点class变为wrap，具体效果参考以下图片</span><br><span class="line">#2、每次click后，请清空所有不需要变动的td节点的class</span><br><span class="line">#3、请不要手动调用bind函数</span><br><span class="line">#4、当前界面为系统生成 9 * 9 表格，执行 bind 函数，并点击其中td后的效果</span><br><span class="line">#5、请不要手动修改html和css</span><br><span class="line">#6、不要使用第三方插件</span><br><span class="line"></span><br><span class="line">#解题思路：JS的题目，不懂</span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">function bind() &#123;</span><br><span class="line">    var tr = document.querySelectorAll(&#x27;tr&#x27;)</span><br><span class="line">        var td =document.querySelectorAll(&#x27;td&#x27;) </span><br><span class="line">        for(var i=0;i&lt;td.length;i++)&#123;</span><br><span class="line">            td[i].addEventListener(&#x27;click&#x27;,function()&#123;</span><br><span class="line">                for(var i =0;i&lt;td.length;i++)&#123;</span><br><span class="line">                    td[i].className =&quot;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">                var trC = this.parentNode.children</span><br><span class="line">                for(var i =0;i&lt;trC.length;i++)&#123;</span><br><span class="line">                    trC[i].className=&quot;wrap&quot;</span><br><span class="line">                &#125;</span><br><span class="line">                for(var i = 0;i&lt;tr.length;i++)&#123;</span><br><span class="line">                    tr[i].children[this.cellIndex].className=&quot;wrap&quot;</span><br><span class="line">                &#125;</span><br><span class="line">                this.className=&quot;current&quot;</span><br><span class="line">            &#125;)</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，</span><br><span class="line"># 对于字符串中连续的m个相同字符串S将会压缩为[m|S](m为一个整数且1&lt;=m&lt;=100)，</span><br><span class="line"># 例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？ </span><br><span class="line"></span><br><span class="line">#解题思路：正则表达式,永远的神</span><br><span class="line">import re</span><br><span class="line">class Solution:</span><br><span class="line">    def compress(self, s):</span><br><span class="line">        #r 表示原生字符串, 不加的话/前面还要加/，麻烦，建议加上r</span><br><span class="line">        match_pattern = re.compile(r&#x27;\[(\d+)\|([a-zA-Z]+)\]&#x27;)</span><br><span class="line">        while re.findall(match_pattern, s):</span><br><span class="line">            s = re.sub(match_pattern, lambda match : match.group(2)*(int)(match.group(1)), s)</span><br><span class="line">        return s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">import re</span><br><span class="line">class Solution:</span><br><span class="line">    def compress(self , s):</span><br><span class="line">        # write code here</span><br><span class="line">        while re.findall(r&#x27;\[(\d+)\|([a-zA-Z]+)\]&#x27;,s):</span><br><span class="line">            s = re.sub(r&#x27;\[(\d+)\|([a-zA-Z]+)\]&#x27;,lambda match:match.group(2)*int(match.group(1)),s)</span><br><span class="line">        return s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。</span><br><span class="line">#小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？</span><br><span class="line">#（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） </span><br><span class="line"></span><br><span class="line">#解题思路：#看到的唯一条件，没有被挡到，即前面没有更大的。</span><br><span class="line"># 对时间复杂度要求高，时间换空间, 对最近的更高的建立表格可以加速搜索，把O(n)变成O(1)</span><br><span class="line">class Solution:</span><br><span class="line">    def findBuilding(self , heights ):</span><br><span class="line">        n = len(heights)</span><br><span class="line">        #表示每个元素前面的，最近的更高的位置</span><br><span class="line">        forward_i = [-1]*n</span><br><span class="line">        #表示每个元素后面的，最近的更高的位置</span><br><span class="line">        backward_i = [-1]*n</span><br><span class="line">        # 第 k 个表示在 k 前能看到的</span><br><span class="line">        res_forward = [0]*n</span><br><span class="line">        # 第 k 个表示在 k 后能看到的</span><br><span class="line">        res_backward = [0]*n</span><br><span class="line">        # 初始化，给backward和forward数组初始化</span><br><span class="line">        if heights[-2] &lt; heights[-1]: #初始化forward[-1]和[-2]</span><br><span class="line">            forward_i[-2] = n - 1</span><br><span class="line">        if heights[1] &lt; heights[0]:   #初始化backward[0]和[1]</span><br><span class="line">            backward_i[1] = 0</span><br><span class="line">        res_forward[-2] = res_backward[1] = 1  #初始化res_forward和res_backward</span><br><span class="line"></span><br><span class="line">        for k in range(3, n+1):</span><br><span class="line">            i = n-k</span><br><span class="line">            #更新forward表</span><br><span class="line">            j = i + 1</span><br><span class="line">            while 0 &lt;= j &lt; len(heights) and heights[i] &gt;= heights[j]:  #从j开始一直先前找最近的更高的，直到比i高，即找到i最近的更高的</span><br><span class="line">                j = forward_i[j]</span><br><span class="line">            forward_i[i] = j</span><br><span class="line">            </span><br><span class="line">            #找到最近的比i+1高的</span><br><span class="line">            j = forward_i[i+1]</span><br><span class="line">            while 0 &lt;= j &lt; n and heights[i+1] &gt;= heights[j]:</span><br><span class="line">                j = forward_i[j]</span><br><span class="line">            res_forward[i] = 1 if j&lt;0 else res_forward[j-1]+1 </span><br><span class="line">        </span><br><span class="line">        for i in range(2, len(heights)):</span><br><span class="line">            # 更新backward列表,指向最近的更高的位置</span><br><span class="line">            # 根据其指向最快找到比自己高的</span><br><span class="line">            j = i - 1</span><br><span class="line">            while 0 &lt;= j &lt; n and heights[i] &gt;= heights[j]:</span><br><span class="line">                j = backward_i[j]</span><br><span class="line">            backward_i[i] = j</span><br><span class="line"></span><br><span class="line">            #找到最近的比i-1高的</span><br><span class="line">            j = backward_i[i-1]</span><br><span class="line">            while 0 &lt;= j &lt; n and heights[i-1] &gt;= heights[j]:</span><br><span class="line">                j = backward_i[j]</span><br><span class="line">            # 从邻居前面看,等价于 从比邻居高的最近的位置之后看</span><br><span class="line">            # 多看了一个邻居</span><br><span class="line">            res_backward[i] = 1 if j &lt; 0 else res_backward[j+1] + 1</span><br><span class="line">        return [i+j+1 for i, j in zip(res_forward, res_backward)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这样会超时，时间复杂度为n^2，需要利用前后邻居的信息，用空间换时间降低时间复杂度</span><br><span class="line">class Solution:</span><br><span class="line">    def findBuilding(self,heights):</span><br><span class="line">        left=[]</span><br><span class="line">        right=[]</span><br><span class="line">        result=[]</span><br><span class="line">        for i in range(0,len(heights)):</span><br><span class="line">            count=1</span><br><span class="line">            right=heights[i+1:]</span><br><span class="line">            left=heights[0:i]</span><br><span class="line">            if right:</span><br><span class="line">                count=count+1</span><br><span class="line">                max = right[0]</span><br><span class="line">                for j in range(1,len(right)):</span><br><span class="line">                    if right[j]&gt;max:</span><br><span class="line">                        count=count+1</span><br><span class="line">                        max = right[j]</span><br><span class="line">            if left:</span><br><span class="line">                count = count + 1</span><br><span class="line">                left.reverse()</span><br><span class="line">                max = left[0]</span><br><span class="line">                for j in range(1,len(left)):</span><br><span class="line">                    if left[j]&gt;max:</span><br><span class="line">                        count=count+1</span><br><span class="line">                        max = left[j]</span><br><span class="line">            result.append(count)</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">class Solution:</span><br><span class="line">    def findBuilding(self , heights ):</span><br><span class="line">        forward_i = [-1 for _ in heights]</span><br><span class="line">        backward_i = [-1 for _ in heights]</span><br><span class="line">        # 第 k 个表示在 k 后能看到的</span><br><span class="line">        res_forward = [0 for _ in heights]</span><br><span class="line">        # 第 k 个表示在 k 前能看到的</span><br><span class="line">        res_backward = [0 for _ in heights]</span><br><span class="line">        # 头尾处理</span><br><span class="line">        if heights[-2] &lt; heights[-1]:</span><br><span class="line">            forward_i[-2] = len(heights) - 1</span><br><span class="line">        if heights[1] &lt; heights[0]:</span><br><span class="line">            backward_i[1] = 0</span><br><span class="line">        res_forward[-2] = res_backward[1] = 1</span><br><span class="line">        for k in range(3, len(heights)+1):</span><br><span class="line">            i = len(heights) - k   #从最后面开始更新，n-1和n-2初始化了。从n-3开始更新</span><br><span class="line">            # 更新指向列表,指向最近的更高的位置</span><br><span class="line">            # 根据其指向最快找到比自己高的</span><br><span class="line">            j = i + 1</span><br><span class="line">            while 0 &lt;= j &lt; len(heights) and heights[i] &gt;= heights[j]:  #从j开始一直先前找最近的更高的，直到比i高，即找到i最近的更高的</span><br><span class="line">                j = forward_i[j]</span><br><span class="line">            forward_i[i] = j</span><br><span class="line">            # 更新计数列表，优化子结构，开始迭代</span><br><span class="line">            if heights[i+1] &lt; heights[i+2]:</span><br><span class="line">                # 如果邻居的邻居比邻居高,则能比邻居多看1（因为i+2之后的更高的i和i+1都能看到，低于i+2的都看不到，i只比i+1多看到一个）</span><br><span class="line">                res_forward[i] = res_forward[i+1] + 1</span><br><span class="line">                continue</span><br><span class="line">            # 根据其指向最快找到比邻居高的</span><br><span class="line">            j = forward_i[i+2]     #最近的更高的，这个数据结构加速了查找，降低了时间复杂度</span><br><span class="line">            while 0 &lt;= j &lt; len(heights) and heights[i+1] &gt;= heights[j]: #本质都是找到最近的比邻居更高的，因为之后的看到与否都一样了</span><br><span class="line">                j = forward_i[j]</span><br><span class="line">            # 从邻居后面看,等价于 从比邻居高的最近的位置之前看</span><br><span class="line">            # 多看了一个邻居</span><br><span class="line">            res_forward[i] = 1 if j &lt; 0 else res_forward[j-1] + 1</span><br><span class="line">            </span><br><span class="line">        for i in range(2, len(heights)):</span><br><span class="line">            # 更新指向列表,指向最近的更高的位置</span><br><span class="line">            # 根据其指向最快找到比自己高的</span><br><span class="line">            j = i - 1</span><br><span class="line">            while 0 &lt;= j &lt; len(heights) and heights[i] &gt;= heights[j]:</span><br><span class="line">                j = backward_i[j]</span><br><span class="line">            backward_i[i] = j</span><br><span class="line">            # 更新计数列表</span><br><span class="line">            if heights[i-1] &lt; heights[i-2]:</span><br><span class="line">                # 如果邻居的邻居比邻居高,则能比邻居多看1</span><br><span class="line">                res_backward[i] = res_backward[i-1] + 1</span><br><span class="line">                continue</span><br><span class="line">            # 根据其指向最快找到比邻居高的</span><br><span class="line">            j = backward_i[i-2]</span><br><span class="line">            while 0 &lt;= j &lt; len(heights) and heights[i-1] &gt;= heights[j]:</span><br><span class="line">                j = backward_i[j]</span><br><span class="line">            # 从邻居前面看,等价于 从比邻居高的最近的位置之后看</span><br><span class="line">            # 多看了一个邻居</span><br><span class="line">            res_backward[i] = 1 if j &lt; 0 else res_backward[j+1] + 1</span><br><span class="line">        return [i+j+1 for i, j in zip(res_forward, res_backward)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P 。</span><br><span class="line"># 并将P对1000000007取模的结果输出。</span><br><span class="line"></span><br><span class="line">#解题思路：归并排序求逆序对，本质是分治思想，每部分分别统计逆序对，部分内部排序后不影响部分间逆序对的求解，其实这个过程就是归并排序</span><br><span class="line">count  =0</span><br><span class="line">class Solution:</span><br><span class="line">    global count </span><br><span class="line">    def InversePairs(self, data):</span><br><span class="line">        self.MergeSort(data)</span><br><span class="line">        return count % 1000000007</span><br><span class="line">    </span><br><span class="line">    def MergeSort(self, list):</span><br><span class="line">        global count</span><br><span class="line">        len_list = len(list)</span><br><span class="line">        if len_list &lt;= 1:</span><br><span class="line">            return list</span><br><span class="line">        middle = (int)(len_list/2)</span><br><span class="line">        left = self.MergeSort(list[ : middle])</span><br><span class="line">        right = self.MergeSort(list[middle : ])  #[middle : len_list]也行，[middle : (len_list-1)]是错的，sb</span><br><span class="line"></span><br><span class="line">        l_num = r_num = 0</span><br><span class="line">        res = []</span><br><span class="line">        while l_num &lt; len(left) and r_num &lt; len(right):</span><br><span class="line">            if left[l_num] &gt; right[r_num]:   #说明出现逆序对</span><br><span class="line">                count += len(left) - l_num</span><br><span class="line">                res.append(right[r_num])</span><br><span class="line">                r_num += 1</span><br><span class="line">            else:</span><br><span class="line">                res.append(left[l_num])</span><br><span class="line">                l_num += 1</span><br><span class="line">        res += left[l_num:]</span><br><span class="line">        res += right[r_num:]</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">count = 0</span><br><span class="line">class Solution:</span><br><span class="line">    def InversePairs(self, data):</span><br><span class="line">        global count</span><br><span class="line">        def MergeSort(lists):</span><br><span class="line">            global count</span><br><span class="line">            if len(lists) &lt;= 1:</span><br><span class="line">                return lists</span><br><span class="line">            num = int( len(lists)/2 )</span><br><span class="line">            left = MergeSort(lists[:num])</span><br><span class="line">            right = MergeSort(lists[num:])</span><br><span class="line">            r, l=0, 0</span><br><span class="line">            result=[]</span><br><span class="line">            while l&lt;len(left) and r&lt;len(right):</span><br><span class="line">                if left[l] &lt; right[r]:</span><br><span class="line">                    result.append(left[l])</span><br><span class="line">                    l += 1</span><br><span class="line">                else:</span><br><span class="line">                    result.append(right[r])</span><br><span class="line">                    r += 1</span><br><span class="line">                    count += len(left)-l</span><br><span class="line">            result += right[r:]</span><br><span class="line">            result += left[l:]</span><br><span class="line">            return result</span><br><span class="line">        MergeSort(data)</span><br><span class="line">        return count%1000000007</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def InversePairs(self, data):</span><br><span class="line">        #发现可以用归并排序，归并拼接后用计算排序时元素的index变动了多少</span><br><span class="line">        #两个有序序列，每个元素移动index数（严格来说不是移动，这里不知怎么表达）之和好像刚好等于逆序对的个数</span><br><span class="line">        #我也不知为什么，找了半天发现了这个规律</span><br><span class="line">        _,s=self.MergeSort(data)</span><br><span class="line">        return s%1000000007</span><br><span class="line">    </span><br><span class="line">    def MergeSort(self,data):</span><br><span class="line">        n=len(data)</span><br><span class="line">        #递归基</span><br><span class="line">        if n==1:return data, 0</span><br><span class="line">        #分两半来排序</span><br><span class="line">        part1,part2=data[:n//2],data[n//2:]</span><br><span class="line">        sorted_part1,s1=self.MergeSort(part1)</span><br><span class="line">        sorted_part2,s2=self.MergeSort(part2)</span><br><span class="line">        #排序后拼接这两半，拼接后先计数，然后将两个有序序列合并</span><br><span class="line">        s,sorted_temp=0,sorted_part1+sorted_part2</span><br><span class="line">        #用p、q两个指针指向两段，计算q中每个元素离插入点的index差</span><br><span class="line">        p,q,len1,len_all=0,sorted_temp.index(sorted_part2[0]),len(sorted_part1),len(sorted_temp)</span><br><span class="line">        while p&lt;len1 and q&lt;len_all:</span><br><span class="line">            #移动p使p成为插入排序的插入点，计算要移动多少个位置</span><br><span class="line">            while p&lt;len1:</span><br><span class="line">                if sorted_temp[q]&lt;sorted_temp[p]:</span><br><span class="line">                    s+=len1-p</span><br><span class="line">                    break</span><br><span class="line">                p+=1</span><br><span class="line">            q+=1</span><br><span class="line">        #完成排序，并把排序后的内容回溯给上一级做准备</span><br><span class="line">        l=[]</span><br><span class="line">        p,q=0,sorted_temp.index(sorted_part2[0])</span><br><span class="line">        while p&lt;len1 and q&lt;len_all:</span><br><span class="line">            if sorted_temp[p]&lt;sorted_temp[q]:</span><br><span class="line">                l.append(sorted_temp[p])</span><br><span class="line">                p+=1</span><br><span class="line">            else:</span><br><span class="line">                l.append(sorted_temp[q])</span><br><span class="line">                q+=1</span><br><span class="line">        if p==len1:l+=sorted_temp[q:]</span><br><span class="line">        if q==len_all:l+=sorted_part1[p:]</span><br><span class="line">        return l,s+s1+s2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#链接：https://www.nowcoder.com/questionTerminal/8fe007e54fc04b5e82089aaa71ba3553?f=discussion</span><br><span class="line">#作为程序员的小Q，他的数列和其他人的不太一样，他有2^n个数。</span><br><span class="line">#老板问了小Q一共 m次，每次给出一个整数qi(1 &lt;= i &lt;= m), 要求小Q把这些数每2^&#123;qi&#125;分为一组，然后把每组进行翻转，</span><br><span class="line">#小Q想知道每次操作后整个序列中的逆序对个数是多少呢？</span><br><span class="line">#例如:</span><br><span class="line">#对于序列1 3 4 2，逆序对有(4, 2),(3, 2),总数量为2。</span><br><span class="line">#翻转之后为2 4 3 1，逆序对有(2, 1),(4, 3), (4, 1), (3, 1),总数量为4。</span><br><span class="line"></span><br><span class="line">#解题思路: 归并排序求逆序对</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    n = (int)(input().strip())</span><br><span class="line">    nums_init = [(int)(i) for i in input().strip().split()]</span><br><span class="line">    if len(nums_init) != (2**n):</span><br><span class="line">        print(-1)</span><br><span class="line">        exit()</span><br><span class="line">    m = (int)(input().strip())</span><br><span class="line">    nums_q = [(int)(i) for i in input().strip().split()]</span><br><span class="line">    if len(nums_q) != m:</span><br><span class="line">        print(-1)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    for i in range(m):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#链接：https://www.nowcoder.com/questionTerminal/7cd9a140387e455a972e8fea0e74be2c?f=discussion</span><br><span class="line">#由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：</span><br><span class="line">#不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。</span><br><span class="line">#给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。</span><br><span class="line"></span><br><span class="line">#解题思路：三个状态：工作锻炼休息，状态转移，联想到动态规划中的状态转移方程,</span><br><span class="line">#可以用dp[i][0]、dp[i][1]、dp[i][2]分别表示第i天小Q处于休息、工作、锻炼时最少的休息天数</span><br><span class="line">#//1. 选择休息，故天数多1</span><br><span class="line">#dp[i][0] = min(dp[i-1][0], min(dp[i-1][1], dp[i-1][2])) + 1; </span><br><span class="line">#//2. 不休息，选择工作</span><br><span class="line">#dp[i][1] = min(dp[i-1][0], dp[i-1][2]); </span><br><span class="line">#//3. 不休息，选择锻炼</span><br><span class="line">#dp[i][2] = min(dp[i-1][0], dp[i-1][1]); </span><br><span class="line">#//边界：第0天休息天数为0</span><br><span class="line">#dp[0][i] = 0 (i = 1, 2, 3) </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    n = (int)(input().strip())</span><br><span class="line">    company = [(int)(i) for i in input().strip().split()]</span><br><span class="line">    exercise = [(int)(i) for i in input().strip().split()]</span><br><span class="line"></span><br><span class="line">    #dp[i][0/1/2]为第i天休息/工作/锻炼对应的最少休息天数</span><br><span class="line">    dp = [[100000]*3 for i in range(n+1)]  </span><br><span class="line">    dp[0][0] = dp[0][1] = dp[0][2] = 0</span><br><span class="line">    for i in range(1, n+1):</span><br><span class="line">        if company[i-1] == 1:</span><br><span class="line">            dp[i][1] = min(dp[i-1][0], dp[i-1][2])</span><br><span class="line">        if exercise[i-1] == 1:</span><br><span class="line">            dp[i][2] = min(dp[i-1][0], dp[i-1][1])</span><br><span class="line">        dp[i][0] = min(dp[i-1][0], dp[i-1][1], dp[i-1][2]) + 1</span><br><span class="line">        </span><br><span class="line">    res = min(dp[n][0], dp[n][1], dp[n][2])</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">n = int(input())</span><br><span class="line">a = [int(value) for value in input().split()]</span><br><span class="line">b = [int(value) for value in input().split()]</span><br><span class="line">result = 0</span><br><span class="line">previous_a = 0</span><br><span class="line">previous_b = 0</span><br><span class="line"> </span><br><span class="line">for i in range(n):</span><br><span class="line">    if a[i] == 0 and b[i] == 0:</span><br><span class="line">        result += 1</span><br><span class="line">        previous_a = previous_b = 0</span><br><span class="line">        continue</span><br><span class="line">         </span><br><span class="line">    if a[i] == 1 and b[i] == 0:</span><br><span class="line">        if previous_a == 1:</span><br><span class="line">            result += 1</span><br><span class="line">            previous_a = previous_b = 0</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            previous_a = 1</span><br><span class="line">            previous_b = 0</span><br><span class="line">            continue</span><br><span class="line">             </span><br><span class="line">    if a[i] == 0 and b[i] == 1:</span><br><span class="line">        if previous_b == 1:</span><br><span class="line">            result += 1</span><br><span class="line">            previous_a = previous_b = 0</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            previous_a = 0</span><br><span class="line">            previous_b = 1</span><br><span class="line">            continue</span><br><span class="line">     </span><br><span class="line">    if a[i] == 1 and b[i] == 1:</span><br><span class="line">        if previous_a == 1:</span><br><span class="line">            previous_a = 0</span><br><span class="line">            previous_b = 1</span><br><span class="line">            continue</span><br><span class="line">        if previous_b == 1:</span><br><span class="line">            previous_b = 0</span><br><span class="line">            previous_a = 1</span><br><span class="line">            continue</span><br><span class="line">        if previous_b == 0 and previous_a == 0:</span><br><span class="line">            continue</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">day=int(input())</span><br><span class="line">_C=input()</span><br><span class="line">c=[int(i) for i in _C.split()]</span><br><span class="line">_G=input()</span><br><span class="line">g=[int(i) for i in _G.split()]</span><br><span class="line"> </span><br><span class="line">a=[c.copy(),g.copy()]</span><br><span class="line"> </span><br><span class="line">for i in range(day-1):</span><br><span class="line">    if c[i]==0:</span><br><span class="line">        a[0][i+1]+=a[0][i] if a[0][i] &gt; a[1][i] else a[1][i]</span><br><span class="line">    else:</span><br><span class="line">        a[0][i+1]+=a[1][i]</span><br><span class="line">    if g[i]==0:</span><br><span class="line">        a[1][i+1]+=a[0][i] if a[0][i] &gt; a[1][i] else a[1][i]</span><br><span class="line">    else:</span><br><span class="line">        a[1][i+1]+=a[0][i]</span><br><span class="line"> </span><br><span class="line">print(day-(a[0][day-1] if a[0][day-1]&gt;a[1][day-1] else a[1][day-1]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># https://www.nowcoder.com/questionTerminal/61e1e66e39f348cdb6495de91ac36a41?f=discussion</span><br><span class="line"># 小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。</span><br><span class="line">#这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。</span><br><span class="line">#现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。</span><br><span class="line"></span><br><span class="line">#解题思路：贪心, 每次都选择可以覆盖到最远距离的地方</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    n,L = [(int)(i) for i in input().strip().split()]</span><br><span class="line">    x_y = []</span><br><span class="line">    for i in range(n):</span><br><span class="line">        x_y.append([(int)(i) for i in input().strip().split()])</span><br><span class="line">    x_y.sort(key = lambda x:x[0])</span><br><span class="line"></span><br><span class="line">    if x_y[0][0] &lt; 0:</span><br><span class="line">        print(-1)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    last_reach = 0  #上一次抵达的</span><br><span class="line">    max_reach = 0   #可能抵达的</span><br><span class="line">    cnt = 1         #一定要记得加上第一个，因为开始计数时已经到了第二个</span><br><span class="line">    for i in range(n):</span><br><span class="line">        if max_reach &gt;= L:</span><br><span class="line">            break</span><br><span class="line">        if x_y[i][0] &gt; max_reach:</span><br><span class="line">            print(-1)</span><br><span class="line">            exit()</span><br><span class="line">        if x_y[i][0] &lt;= last_reach and x_y[i][1] &gt; max_reach:</span><br><span class="line">            max_reach = x_y[i][1]</span><br><span class="line">        if x_y[i][0] &gt; last_reach:</span><br><span class="line">            last_reach = max_reach</span><br><span class="line">            max_reach = max(x_y[i][1], max_reach)</span><br><span class="line">            cnt += 1</span><br><span class="line"></span><br><span class="line">    if max_reach &gt;= L:</span><br><span class="line">        print(cnt)</span><br><span class="line">    else:</span><br><span class="line">        print(-1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#别人的题解</span><br><span class="line">#贪心选择</span><br><span class="line">n,L = map(int,input().split())</span><br><span class="line">xy = []</span><br><span class="line">for _ in range(n):</span><br><span class="line">    xy.append(list(map(int,input().split())))</span><br><span class="line">xy.sort(key = lambda x : x[0])</span><br><span class="line">last = 0#当前已选尾部位置</span><br><span class="line">max_reach = 0#当前可选最大到达位置</span><br><span class="line">cnt = 1#ans 先加最后一个</span><br><span class="line">for i in range(n):</span><br><span class="line">    if max_reach &gt;= L:</span><br><span class="line">        break#一定要加，不然初始化1可能会重复</span><br><span class="line">    if xy[i][0] &gt; max_reach:</span><br><span class="line">        print(-1)</span><br><span class="line">        exit()</span><br><span class="line">    if xy[i][0]&gt;last:#此时需要更新last</span><br><span class="line">        last = max_reach#确定选择max_reach</span><br><span class="line">        cnt+=1</span><br><span class="line">        #max_reach = max(xy[i][1],max_reach)#勿忘更新max</span><br><span class="line">        #continue</span><br><span class="line">    max_reach = max(xy[i][1],max_reach)#日常更新max</span><br><span class="line">if max_reach &gt;= L:</span><br><span class="line">    print(cnt)</span><br><span class="line">else:</span><br><span class="line">    print(-1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ1</span><br><span class="line">#在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</span><br><span class="line"># 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"># 时间复杂度O(m+n)</span><br><span class="line">class Solution:</span><br><span class="line">    def Find(self, target, array):</span><br><span class="line">        if array == None or array[0] == None:</span><br><span class="line">            return False</span><br><span class="line">        row = len(array)</span><br><span class="line">        col = len(array[0])</span><br><span class="line">        i = 0</span><br><span class="line">        j = col-1</span><br><span class="line"></span><br><span class="line">        #这里很精妙，从右上角出发，对于每一步，如果目标更大只有向下走，如果目标更小只有向左走</span><br><span class="line">        #因为没有回退，路线最大长度为row+col，复杂度为O(m+n)</span><br><span class="line">        while(i&gt;=0 and i&lt;row and j&gt;=0 and j&lt;col):</span><br><span class="line">            if array[i][j] == target:</span><br><span class="line">                return True</span><br><span class="line">            elif target &gt; array[i][j]:</span><br><span class="line">                i+=1</span><br><span class="line">            elif target &lt; array[i][j]:</span><br><span class="line">                j-=1</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ2</span><br><span class="line">#请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</span><br><span class="line">import re</span><br><span class="line">class Solution:</span><br><span class="line">    def replaceSpace(self , s ):</span><br><span class="line">        pattern = re.compile(r&quot; &quot;)</span><br><span class="line">        </span><br><span class="line">        while(re.findall(pattern, s)):</span><br><span class="line">            s = re.sub(pattern, &quot;%20&quot;, s)</span><br><span class="line">        return s</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ3</span><br><span class="line">#输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</span><br><span class="line">    def printListFromTailToHead(self, listNode):</span><br><span class="line">        res = []</span><br><span class="line">        if listNode == None:</span><br><span class="line">            return []</span><br><span class="line">        while listNode:</span><br><span class="line">            res.append(listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        return res[::-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ14</span><br><span class="line">#输入一个长度为的链表，设链表中的元素的值为a_i，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。</span><br><span class="line">#如果该链表长度小于k，请返回一个长度为 0 的链表。</span><br><span class="line"></span><br><span class="line">#解题思路：1. 一般链表题，我们都可以考虑双指针的解题思路</span><br><span class="line">#         2. 变成数组，直接切分</span><br><span class="line">class Solution:</span><br><span class="line">    def FindKthToTail(self , pHead , k ):</span><br><span class="line">        if pHead == None:</span><br><span class="line">            return None</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        while pHead:</span><br><span class="line">            #注意是要返回链表，即头指针，因此数组存储头指针</span><br><span class="line">            res.append(pHead)</span><br><span class="line">            pHead = pHead.next</span><br><span class="line">        if len(res) &lt; k or k == 0:</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            return res[-k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def FindKthToTail(self , pHead , k ):</span><br><span class="line">        # write code here</span><br><span class="line">        #首先初始化两个指针，都指向头节点</span><br><span class="line">        first, second = pHead, pHead</span><br><span class="line">        #当first不存在的时候，直接返回None</span><br><span class="line">        for i in range(k):</span><br><span class="line">            if first == None:</span><br><span class="line">                return None</span><br><span class="line">            #否则节点存在，开始移动first指针走动k步</span><br><span class="line">            first = first.next</span><br><span class="line">        #当first走完k步后，此时first、second指针开始同步移动，当first移出链表到null的位置，second指针停止移动;此时返回second指针所在位置就是我们要找的倒数最后K个节点值</span><br><span class="line">        while first:</span><br><span class="line">            first = first.next</span><br><span class="line">            second = second.next</span><br><span class="line">        return second</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ15</span><br><span class="line">#输入一个长度为n链表，反转链表后，输出新链表的表头。</span><br><span class="line">#解题思路：双指针法：一般链表题，我们都可以考虑双指针的解题思路</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回ListNode</span><br><span class="line">    def ReverseList(self, pHead):</span><br><span class="line">        if pHead == None:</span><br><span class="line">            return None</span><br><span class="line">        if pHead.next == None:</span><br><span class="line">            return pHead</span><br><span class="line">        </span><br><span class="line">        cur_node = pHead</span><br><span class="line">        pre_node = None</span><br><span class="line">        while cur_node:</span><br><span class="line">            temp = cur_node.next</span><br><span class="line">            cur_node.next = pre_node</span><br><span class="line">            pre_node = cur_node</span><br><span class="line">            cur_node = temp</span><br><span class="line">        return pre_node</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ16</span><br><span class="line">#输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</span><br><span class="line"># 解题思路：排序想到归并排序，链表想到双指针</span><br><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        if pHead1 == None:</span><br><span class="line">            return pHead2</span><br><span class="line">        elif pHead2 == None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        ListSorted = ListNode(0)</span><br><span class="line">        res = ListSorted</span><br><span class="line">        while pHead1 and pHead2:</span><br><span class="line">            if pHead1.val &gt; pHead2.val:</span><br><span class="line">                ListSorted.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">                ListSorted = ListSorted.next</span><br><span class="line">            else:</span><br><span class="line">                ListSorted.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">                ListSorted = ListSorted.next</span><br><span class="line">        if pHead1 == None:</span><br><span class="line">            ListSorted.next = pHead2</span><br><span class="line">        else:</span><br><span class="line">            ListSorted.next = pHead1</span><br><span class="line">        return res.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ16</span><br><span class="line">#输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），</span><br><span class="line"># 请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 </span><br><span class="line"># 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出</span><br><span class="line"></span><br><span class="line">#解题思路：</span><br><span class="line">class RandomListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = None</span><br><span class="line">        self.random = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回 RandomListNode</span><br><span class="line">    def Clone(self, pHead):</span><br><span class="line">        if pHead==None:</span><br><span class="line">            return None</span><br><span class="line"> </span><br><span class="line">        cur = pHead</span><br><span class="line">        node_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        while cur:</span><br><span class="line">            new_node = RandomListNode(cur.label)</span><br><span class="line">            node_map[cur] = new_node</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur = pHead</span><br><span class="line">        while cur:</span><br><span class="line">            node = node_map[cur]</span><br><span class="line">            if cur.next:</span><br><span class="line">                node.next = node_map[cur.next]</span><br><span class="line">            else:</span><br><span class="line">                node.next = None</span><br><span class="line">            if cur.random:</span><br><span class="line">                node.random = node_map[cur.random]</span><br><span class="line">            else:</span><br><span class="line">                node.random = None</span><br><span class="line">            cur = cur.next</span><br><span class="line">        return node_map[pHead]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ36  两个链表的第一个公共结点</span><br><span class="line">#输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。</span><br><span class="line"># （注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</span><br><span class="line">#解题思路：1. 对于链表，想到双指针（这里注意，画图应该是丫形，因为公共结点后都应该相同）</span><br><span class="line">#               p1遍历完后跳到p2，这样如果没有公共结点，M+N后都为None结束循环，如果有公共结点那么在M+N-L处有公共结点</span><br><span class="line">#         2. 对于寻找公共结点，想到哈希，常规思路就是用一个哈希集合来存储第一个链表遍历后的所有节点；</span><br><span class="line">#           接着遍历第二个链表，与哈希集合中的节点进行比较：</span><br><span class="line">class Solution:</span><br><span class="line">    def FindFirstCommonNode(self , pHead1 , pHead2 ):</span><br><span class="line">        if pHead1 == None or pHead2 == None:</span><br><span class="line">            return None</span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line"></span><br><span class="line">        while p1 != p2:</span><br><span class="line">            if p1:</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            else:</span><br><span class="line">                p1 = pHead2</span><br><span class="line">            if p2:</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            else:</span><br><span class="line">                p2 = pHead1</span><br><span class="line">        return p1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def FindFirstCommonNode(self , pHead1 , pHead2 ):</span><br><span class="line">        # write code here</span><br><span class="line">        #首先判断两个链表是否为空</span><br><span class="line">        if pHead1 is None or pHead2 is None:</span><br><span class="line">            return None</span><br><span class="line">        #定义链表1 的集合</span><br><span class="line">        set_A = set()</span><br><span class="line">        node1, node2 = pHead1, pHead2 #定义两个节点</span><br><span class="line">        #遍历链表 1 ，把每个节点加入集合中</span><br><span class="line">        while node1:</span><br><span class="line">            set_A.add(node1)</span><br><span class="line">            node1 = node1.next</span><br><span class="line">        #遍历链表2 看当前节点是否在 集合中；如果存在，当前节点就是要找的第一个公共节点；否则继续比较下一个节点。</span><br><span class="line">        #这里还要注意，如果遍历完链表 B，发现所有节点都不在集合中，则说明两个链表不相交，返回None。</span><br><span class="line">        while node2:</span><br><span class="line">            if node2 in set_A:</span><br><span class="line">                return node2</span><br><span class="line">            node2 = node2.next</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ55 链表中环的入口结点</span><br><span class="line">#给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</span><br><span class="line">#解题思路：用哈希set</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def EntryNodeOfLoop(self, pHead):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead == None:</span><br><span class="line">            return None</span><br><span class="line">        set_A = set()</span><br><span class="line">        while pHead:</span><br><span class="line">            if pHead in set_A:</span><br><span class="line">                return pHead</span><br><span class="line">            else:</span><br><span class="line">                set_A.add(pHead)</span><br><span class="line">            pHead = pHead.next</span><br><span class="line">        return pHead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ56 删除链表中重复的结点</span><br><span class="line">#在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 </span><br><span class="line"># 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</span><br><span class="line">#解题思路：删除重复节点，注意这里的重复指的是val一样, 链表想到双指针</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteDuplication(self, pHead):</span><br><span class="line">        # write code here</span><br><span class="line">        preHead = ListNode(-1)</span><br><span class="line">        preHead.next = pHead</span><br><span class="line">        cur = pHead</span><br><span class="line">        pre = preHead</span><br><span class="line">        while cur:</span><br><span class="line">            if cur.next and cur.val == cur.next.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                while cur.next and cur.val == cur.next.val:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">                pre.next = cur</span><br><span class="line">            else:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">        return preHead.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ5 用两个栈实现队列</span><br><span class="line">#用两个栈来实现一个队列，完成 n 次在队列尾部插入整数(push)和在队列头部删除整数(pop)的功能。 </span><br><span class="line"># 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</span><br><span class="line"></span><br><span class="line">#解题思路：模拟push和pop函数的实现过程，push只需将节点送入stack1，pop如果stack2有元素则只需弹出stack2栈顶的，</span><br><span class="line"># stack2没有则将stack1中元素逐一pop进stack2,再弹出stack2栈顶元素</span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    def push(self, node):</span><br><span class="line">        # write code here</span><br><span class="line">        return self.stack1.append(node)</span><br><span class="line">    def pop(self):</span><br><span class="line">        # return xx</span><br><span class="line">        if self.stack2:</span><br><span class="line">            return self.stack2.pop()</span><br><span class="line">        else:</span><br><span class="line">            for i in range(len(self.stack1)):</span><br><span class="line">                temp = self.stack1.pop()</span><br><span class="line">                self.stack2.append(temp)</span><br><span class="line">            return self.stack2.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ20 包含min函数的栈</span><br><span class="line">#定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数，并且调用 min函数、push函数 及 pop函数 的时间复杂度都是 O(1)</span><br><span class="line"></span><br><span class="line">#解题思路： 双栈法：在返回栈中的min值时，如果仅仅使用一个辅助变量min，则其值可能因为min元素被出栈而失效，</span><br><span class="line"># 常规的做法是额外添加一个同步栈（min栈），以保存记录之前所有的min值</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack = []</span><br><span class="line">        #注意不要随意命名，一些关键字可能会导致意想不到的问题</span><br><span class="line">        self.stack_min = []</span><br><span class="line">        </span><br><span class="line">    def push(self, node):</span><br><span class="line">        # write code here</span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        #特殊情况处理，初始值处理</span><br><span class="line">        if not self.stack_min:</span><br><span class="line">            self.stack_min.append(node)</span><br><span class="line">        elif node &lt; self.stack_min[-1]:</span><br><span class="line">            self.stack_min.append(node)</span><br><span class="line">        else:</span><br><span class="line">            self.stack_min.append(self.stack_min[-1])</span><br><span class="line">            </span><br><span class="line">    def pop(self):</span><br><span class="line">        # write code here</span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.stack_min.pop()</span><br><span class="line">        </span><br><span class="line">    def top(self):</span><br><span class="line">        # write code here</span><br><span class="line">        if self.stack:</span><br><span class="line">            return self.stack[-1]</span><br><span class="line">        </span><br><span class="line">    def min(self):</span><br><span class="line">        # write code here</span><br><span class="line">        return self.stack_min[-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ21 栈的压入、弹出序列</span><br><span class="line">#输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。</span><br><span class="line"># 例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</span><br><span class="line"># （注意：这两个序列的长度是相等的）</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def IsPopOrder(self, pushV, popV):</span><br><span class="line">        j=0</span><br><span class="line">        temp = []</span><br><span class="line">        for i in range(len(pushV)):</span><br><span class="line">            temp.append(pushV[i])</span><br><span class="line">            while len(temp) &gt; 0 and temp[-1] == popV[j]:</span><br><span class="line">                j+=1</span><br><span class="line">                temp.pop()</span><br><span class="line"></span><br><span class="line">        if len(temp) == 0:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ44  翻转单词序列</span><br><span class="line">#牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，</span><br><span class="line"># 有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，</span><br><span class="line"># 正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def ReverseSentence(self, s):</span><br><span class="line">        return &#x27; &#x27;.join(s.split(&quot; &quot;)[::-1])</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def ReverseSentence(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        s_word = s.strip().split()</span><br><span class="line">        s_word = s_word[::-1]</span><br><span class="line">        res = &#x27;&#x27;</span><br><span class="line">        for i in range(len(s_word)):</span><br><span class="line">            res += s_word[i]</span><br><span class="line">            if i != (len(s_word)-1):</span><br><span class="line">                res += &#x27; &#x27;</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ64 滑动窗口的最大值</span><br><span class="line">#给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</span><br><span class="line">class Solution:</span><br><span class="line">    def get_max(self, num):</span><br><span class="line">        size = len(num)</span><br><span class="line">        max_num = num[0]</span><br><span class="line">        for i in range(size):</span><br><span class="line">            max_num = max(num[i], max_num)</span><br><span class="line">        return max_num</span><br><span class="line">    </span><br><span class="line">    def maxInWindows(self, num, size):</span><br><span class="line">        # write code here</span><br><span class="line">        if size == 0:</span><br><span class="line">            return []</span><br><span class="line">        n = len(num)</span><br><span class="line">        res = []</span><br><span class="line">        for i in range(n-size+1):</span><br><span class="line">            slide_window = num[i:i+size]</span><br><span class="line">            res.append(self.get_max(slide_window))</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ30 连续子数组的最大和</span><br><span class="line">#输入一个长度为n的整型数组a，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</span><br><span class="line">#解题思路：典型的动态规划。</span><br><span class="line"># dp[n]代表以当前元素为截止点的连续子序列的最大和，如果dp[n-1]&gt;0，dp[n]=A[n]+dp[n-1]，因为当前数字加上一个正数一定会变大；</span><br><span class="line"># 如果dp[n-1]&lt;0，dp[n]=A[n]，因为当前数字加上一个负数一定会变小。</span><br><span class="line"># 使用一个变量max记录最大的dp值返回即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def FindGreatestSumOfSubArray(self, array):</span><br><span class="line">        # write code here</span><br><span class="line">        l=len(array)</span><br><span class="line">        dp=[array[0]]</span><br><span class="line">        for i in range(1,l):</span><br><span class="line">            dp.append(max(dp[-1]+array[i],array[i]))</span><br><span class="line">        return max(dp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ8 跳台阶</span><br><span class="line">#一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</span><br><span class="line">#解题思路：动态规划   </span><br><span class="line">#由于它可以跳1级台阶或者2级台阶，所以它上一步必定在第n-1,或者第n-2级台阶，也就是说它跳上n级台阶的跳法数是跳上n-1和跳上n-2级台阶的跳法数之和。</span><br><span class="line"># dp[n] = dp[n-1]+dp[n-2]</span><br><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number == 1:</span><br><span class="line">            return 1</span><br><span class="line">        if number == 2:</span><br><span class="line">            return 2</span><br><span class="line">        a = 1</span><br><span class="line">        b = 2</span><br><span class="line">        c = 0</span><br><span class="line">        for i in range(number-2):</span><br><span class="line">            c = a + b </span><br><span class="line">            a = b </span><br><span class="line">            b = c </span><br><span class="line">        return c</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ7 斐波那契数列</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ52 正则表达式匹配</span><br><span class="line">#请实现一个函数用来匹配包括&#x27;.&#x27;和&#x27;*&#x27;的正则表达式。模式中的字符&#x27;.&#x27;表示任意一个字符，而&#x27;*&#x27;表示它前面的字符可以出现任意次（包含0次）。 </span><br><span class="line"># 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配</span><br><span class="line"></span><br><span class="line">#解题思路：首先想到双指针，可以用动态规划（因为存在优化子结构），</span><br><span class="line">class Solution:</span><br><span class="line">    def match(self , str , pattern ):</span><br><span class="line">        m = len(str)+1</span><br><span class="line">        n = len(pattern)+1</span><br><span class="line">        dp = [[False] * n for _ in range(m)]</span><br><span class="line">        dp[0][0] = True</span><br><span class="line">        #*代表0次时</span><br><span class="line">        for j in range(1, n):</span><br><span class="line">            if pattern[j-1] == &#x27;*&#x27;:</span><br><span class="line">                dp[0][j] = dp[0][j-2]</span><br><span class="line">        #</span><br><span class="line">        for i in range(1, m):</span><br><span class="line">            for j in range(1, n):</span><br><span class="line">                if pattern[j-1] != &#x27;*&#x27;:</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] and pattern[j-1] in (str[i-1], &#x27;.&#x27;)</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j] = dp[i][j-2] or dp[i-1][j] and pattern[j-2] in (str[i-1], &#x27;.&#x27;)</span><br><span class="line">        return dp[-1][-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ9 跳台阶扩展问题</span><br><span class="line">#一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">#解题思路：跳台阶问题：可以根据最后一次跳的台阶数分解</span><br><span class="line"># 设n级台阶有f(n) 种跳法，根据最后一次跳台阶的数目可以分解为最后一次一级，则前面需要跳n−1 级，</span><br><span class="line"># 有f(n-1)种跳法；最后一次跳两级，则前面需要跳n- 2级，有f(n-2)种跳法。以此类推 易知，f(n) = 2f(n−1)</span><br><span class="line">class Solution:</span><br><span class="line">    def jumpFloorII(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        ans = 2 ** (number-1)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ10 矩形覆盖</span><br><span class="line">#我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，</span><br><span class="line"># 从同一个方向看总共有多少种不同的方法？</span><br><span class="line"></span><br><span class="line">#解题思路：同样考虑最后一步，因为是2*1，最后一步只有长度为1和长度为2两种，因此f(n) = f(n−1) +f(n−2)</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def rectCover(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        a = 0</span><br><span class="line">        b = 1</span><br><span class="line">        c = 0</span><br><span class="line">        for i in range(number):</span><br><span class="line">            c = a+b</span><br><span class="line">            a  = b</span><br><span class="line">            b = c </span><br><span class="line">        return c  </span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ11 旋转数组的最小数字</span><br><span class="line">#有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，</span><br><span class="line"># 比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</span><br><span class="line"></span><br><span class="line">#解题思路：二分</span><br><span class="line">#递归；非递归则应该有low、mid、high三个指针</span><br><span class="line">class Solution:</span><br><span class="line">    def minNumberInRotateArray(self, A):</span><br><span class="line">        if len(A) &lt;= 0:</span><br><span class="line">            return 0</span><br><span class="line">        low = 0</span><br><span class="line">        high = len(A)-1</span><br><span class="line">        mid = low + (high-low)//2</span><br><span class="line"></span><br><span class="line">        while low &lt; high:</span><br><span class="line">            if A[low]&lt;A[high]:</span><br><span class="line">                return A[low]</span><br><span class="line">            mid = low + (high-low)//2</span><br><span class="line">            if A[low] &lt; A[mid]:</span><br><span class="line">                low = mid+1</span><br><span class="line">            elif A[mid] &lt; A[high]:</span><br><span class="line">                high = mid</span><br><span class="line">            else:</span><br><span class="line">                low+=1</span><br><span class="line">        return A[low]</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ38 字符串的排列</span><br><span class="line">#输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</span><br><span class="line"></span><br><span class="line">#解题思路：递归，就要写出递归方程</span><br><span class="line"># ss的排列组合，等价于ss中不重复的字母拼接除去该字母的子集的排列组合</span><br><span class="line">#例如对&quot;aab&quot;做递归: func(&quot;aab&quot;) = [&#x27;a&#x27;+func(&quot;ab&quot;), &#x27;b&#x27;+func(&quot;aa&quot;)] </span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def Permutation(self, ss):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(ss) &lt;= 1:</span><br><span class="line">            return [ss]</span><br><span class="line"></span><br><span class="line">        results = []</span><br><span class="line">        unique_ss = list(set([c for c in ss]))</span><br><span class="line">        unique_ss.sort()</span><br><span class="line">        for c in unique_ss:</span><br><span class="line">            children_results = self.Permutation(ss.replace(c, &quot;&quot;, 1))</span><br><span class="line">            results.extend([c+r for r in children_results])</span><br><span class="line">        return results</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ72 数字在升序数组中出现的次数</span><br><span class="line">#给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数</span><br><span class="line"></span><br><span class="line">#解题思路：func[12345] = func[123] + func[45]</span><br><span class="line"></span><br><span class="line">#递归写法，简单，但是递归深度太长会爆内存</span><br><span class="line">class Solution:</span><br><span class="line">    def GetNumberOfK(self, data, k):</span><br><span class="line">        # write code here</span><br><span class="line">        </span><br><span class="line">        if len(data) == 1:</span><br><span class="line">            if data[0]==k:</span><br><span class="line">                return 1</span><br><span class="line">            else:</span><br><span class="line">                return 0</span><br><span class="line">        low = 0</span><br><span class="line">        high = len(data)</span><br><span class="line">        mid = low + (high-low)//2</span><br><span class="line">        #直接翻译递归方程</span><br><span class="line">        count = self.GetNumberOfK(data[low:mid], k) + self.GetNumberOfK(data[mid:high], k)</span><br><span class="line">        </span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">#一种非递归写法，但是对于k出现很多次的情况收敛太慢（时间复杂度On）</span><br><span class="line">class Solution:</span><br><span class="line">    def GetNumberOfK(self, data, k):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(data) == 1:</span><br><span class="line">            if data[0]==k:</span><br><span class="line">                return 1</span><br><span class="line">            else:</span><br><span class="line">                return 0</span><br><span class="line">        count = 0</span><br><span class="line">        low = 0</span><br><span class="line">        high = len(data)</span><br><span class="line">        mid = low + (high-low)//2</span><br><span class="line">        </span><br><span class="line">        while low &lt; high:</span><br><span class="line">            mid = low + (high-low)//2</span><br><span class="line">            if k &lt; data[mid]:</span><br><span class="line">                high = mid</span><br><span class="line">            elif k &gt; data[mid]:</span><br><span class="line">                low = mid </span><br><span class="line">            else:</span><br><span class="line">                count += 1</span><br><span class="line">                del data[mid]</span><br><span class="line">                high -= 1</span><br><span class="line">                </span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">#但是实际上，解法异常简单，吐</span><br><span class="line">class Solution:</span><br><span class="line">    def GetNumberOfK(self, data, k):</span><br><span class="line">        num = 0</span><br><span class="line">        for i in range (0,len(data)):</span><br><span class="line">            if data[i] &gt; k :</span><br><span class="line">                break</span><br><span class="line">            if data[i] == k:</span><br><span class="line">                num = num + 1</span><br><span class="line">        return num</span><br><span class="line">        # write code here</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ40 最小的K个数</span><br><span class="line">#给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。</span><br><span class="line"># 例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</span><br><span class="line">class Solution:</span><br><span class="line">    def GetLeastNumbers_Solution(self, tinput, k):</span><br><span class="line">        # write code here</span><br><span class="line">        tinput.sort()</span><br><span class="line">        return tinput[0:k]</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ51 数组中的逆序对</span><br><span class="line">#在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</span><br><span class="line"># 输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</span><br><span class="line"></span><br><span class="line">count = 0</span><br><span class="line">class Solution:</span><br><span class="line">    def InversePairs(self, data):</span><br><span class="line">        # write code here</span><br><span class="line">        global count</span><br><span class="line">        </span><br><span class="line">        def MergeSort(data_list):</span><br><span class="line">            if len(data_list) &lt;= 1:</span><br><span class="line">                return data_list</span><br><span class="line"></span><br><span class="line">            global count</span><br><span class="line">            low = 0</span><br><span class="line">            high = len(data_list)</span><br><span class="line">            mid = low + (high-low)//2</span><br><span class="line"></span><br><span class="line">            left = MergeSort(data_list[low:mid])</span><br><span class="line">            right = MergeSort(data_list[mid: high])</span><br><span class="line"></span><br><span class="line">            l_point = 0</span><br><span class="line">            r_point = 0</span><br><span class="line">            list_sorted = []</span><br><span class="line"></span><br><span class="line">            while l_point &lt; len(left) and r_point &lt; len(right):</span><br><span class="line">                if left[l_point] &gt; right[r_point]:</span><br><span class="line">                    list_sorted.append(right[r_point])</span><br><span class="line">                    count += len(left)- l_point</span><br><span class="line">                    r_point += 1</span><br><span class="line">                else:</span><br><span class="line">                    list_sorted.append(left[l_point])</span><br><span class="line">                    l_point += 1</span><br><span class="line">            list_sorted.extend(left[l_point:])</span><br><span class="line">            list_sorted.extend(right[r_point:])</span><br><span class="line">            return list_sorted</span><br><span class="line">        MergeSort(data)</span><br><span class="line">        return count % 1000000007</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ3 数组中重复的数字</span><br><span class="line">#在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。</span><br><span class="line"># 也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，</span><br><span class="line"># 那么对应的输出是2或者3。存在不合法的输入的话输出-1</span><br><span class="line">class Solution:</span><br><span class="line">    def duplicate(self , numbers ):</span><br><span class="line">        # write code here</span><br><span class="line">        numbers = sorted(numbers)</span><br><span class="line">        n = len(numbers)</span><br><span class="line">        if n == 0: </span><br><span class="line">            return -1</span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            if numbers[i-1] == numbers[i]:</span><br><span class="line">                return numbers[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ41 数据流中的中位数</span><br><span class="line">#如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。</span><br><span class="line"># 如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，</span><br><span class="line"># 使用GetMedian()方法获取当前读取数据的中位数。</span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.s = []</span><br><span class="line">    def Insert(self, num):</span><br><span class="line">        # write code here</span><br><span class="line">        self.s.append(num)</span><br><span class="line">    def GetMedian(self):</span><br><span class="line">        # write code here</span><br><span class="line">        self.s.sort()</span><br><span class="line">        n = len(self.s)</span><br><span class="line">        if n % 2 == 0:</span><br><span class="line">            return (self.s[n//2] + self.s[n//2-1]) / 2</span><br><span class="line">        else:</span><br><span class="line">            return self.s[n//2]</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ15 二进制中1的个数</span><br><span class="line">#输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。</span><br><span class="line"></span><br><span class="line">#解题思路：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，</span><br><span class="line"># 原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</span><br><span class="line"># xx100 &amp; xx011 = xx000     对负数，n&amp;0xffffffff 可以获得和负数补码相同的的位形式（直接的话无法获得相应位形式）</span><br><span class="line">class Solution:</span><br><span class="line">    def NumberOf1(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n == 0:</span><br><span class="line">            return 0</span><br><span class="line">        count = 0</span><br><span class="line">        if n &lt; 0:</span><br><span class="line">            n = n&amp;0xffffffff</span><br><span class="line">        while n:</span><br><span class="line">            count += 1</span><br><span class="line">            n = n &amp; (n-1)</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">#直接获得位形式</span><br><span class="line">class Solution:</span><br><span class="line">    def NumberOf1(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n&lt;0:</span><br><span class="line">            n=n&amp;0xffffffff</span><br><span class="line">        return bin(n).count(&#x27;1&#x27;)   #bin转化为str数组，如‘0b10101’</span><br><span class="line"></span><br><span class="line">#移位操作</span><br><span class="line">class Solution:</span><br><span class="line">    def NumberOf1(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n&lt;0:</span><br><span class="line">            n=n&amp;0xffffffff</span><br><span class="line">        count = 0</span><br><span class="line">        flag = 1</span><br><span class="line">        for i in range(32):</span><br><span class="line">            if (n &amp; flag):</span><br><span class="line">                count += 1</span><br><span class="line">            flag = flag &lt;&lt; 1</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def NumberOf1(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        count = 0</span><br><span class="line">        if n&lt;0:</span><br><span class="line">            n=n&amp;0xffffffff</span><br><span class="line">            count += 1</span><br><span class="line">        </span><br><span class="line">        flag = 1</span><br><span class="line">        while flag != 0x80000000:</span><br><span class="line">            if (n &amp; flag):</span><br><span class="line">                count += 1</span><br><span class="line">            flag = flag &lt;&lt; 1</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ65 不用加减乘除做加法</span><br><span class="line">#写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</span><br><span class="line"></span><br><span class="line">#解题思路：第一步：相加各位的值，不算进位，二进制每位相加就相当于各位做异或操作；</span><br><span class="line"># 第二步：计算进位值，相当于各位做与操作，再向左移一位。</span><br><span class="line"># 第三步重复上述两步， 各位相加 ，计算进位值。进位值为0，跳出循环。</span><br><span class="line">class Solution:</span><br><span class="line">    def Add(self, num1, num2):</span><br><span class="line">        while num2 != 0:</span><br><span class="line">            sum = num1 ^ num2</span><br><span class="line">            num2 = (num1 &amp; num2)&lt;&lt;1</span><br><span class="line">            num1 = sum &amp;(0xffffffff)</span><br><span class="line">        return num1 if num1 &gt;&gt;31 == 0 else num1-2**32   #python负数表示的问题，0b8fffffff第一位为1不认为是负数，有-0b1，因此-2^32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ16 数值的整数次方</span><br><span class="line">#给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def Power(self, base, exponent):</span><br><span class="line">        # write code here</span><br><span class="line">        return base**exponent</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ56 数组中只出现一次的两个数字</span><br><span class="line">#一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def FindNumsAppearOnce(self , array ):</span><br><span class="line">        # write code here</span><br><span class="line">        nums = set()</span><br><span class="line">        </span><br><span class="line">        twice_nums = set()</span><br><span class="line">        for i in array:</span><br><span class="line">            if i in nums:</span><br><span class="line">                twice_nums.add(i)</span><br><span class="line">            else:</span><br><span class="line">                nums.add(i)</span><br><span class="line">        res = list(nums - twice_nums)</span><br><span class="line">        res.sort()</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def FindNumsAppearOnce(self , array ):</span><br><span class="line">        # write code here</span><br><span class="line">        res = []</span><br><span class="line">        for n in array:</span><br><span class="line">            if n not in res:</span><br><span class="line">                res.append(n)</span><br><span class="line">            else:</span><br><span class="line">                res.remove(n)</span><br><span class="line">        res.sort()</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ64 求1+2+3+...+n</span><br><span class="line">#求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）</span><br><span class="line">class Solution:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        #(n+1)n/2 = (n**2+n)/2</span><br><span class="line">        res = n**2 + n</span><br><span class="line">        return res&gt;&gt;1</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ29 顺时针打印矩阵</span><br><span class="line"># 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</span><br><span class="line"></span><br><span class="line">#解题思路： 简单来说，就是不断地收缩矩阵的边界    定义四个变量代表范围，up、down、left、right</span><br><span class="line">#向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错</span><br><span class="line">#向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错</span><br><span class="line">#向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错</span><br><span class="line">#向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</span><br><span class="line">class Solution:</span><br><span class="line">    # matrix类型为二维列表，需要返回列表</span><br><span class="line">    def printMatrix(self, matrix):</span><br><span class="line">        # write code here</span><br><span class="line">        if matrix == None or len(matrix)==0 or len(matrix[0])==0:</span><br><span class="line">            return []</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        up = 0</span><br><span class="line">        down = len(matrix)-1 </span><br><span class="line">        left = 0</span><br><span class="line">        right = len(matrix[0])-1 </span><br><span class="line">        </span><br><span class="line">        while(True):</span><br><span class="line">            for col in range(left, right+1):</span><br><span class="line">                res.append(matrix[up][col])</span><br><span class="line">            up += 1</span><br><span class="line">            if up &gt; down:</span><br><span class="line">                break</span><br><span class="line">                </span><br><span class="line">            for row in range(up, down+1):</span><br><span class="line">                res.append(matrix[row][right])</span><br><span class="line">            right -= 1</span><br><span class="line">            if right &lt; left:</span><br><span class="line">                break</span><br><span class="line">                </span><br><span class="line">            for col in range(left, right+1)[::-1]:</span><br><span class="line">                res.append(matrix[down][col])</span><br><span class="line">            down -= 1</span><br><span class="line">            if up &gt; down:</span><br><span class="line">                break</span><br><span class="line">            </span><br><span class="line">            for row in range(up, down+1)[::-1]:</span><br><span class="line">                res.append(matrix[row][left])</span><br><span class="line">            left += 1</span><br><span class="line">            if left &gt; right:</span><br><span class="line">                break</span><br><span class="line">                </span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ61 扑克牌顺子</span><br><span class="line"># 现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子</span><br><span class="line"></span><br><span class="line">#解题思路：是顺子的充要条件：ma - mi &lt;= 4，除0外无重复</span><br><span class="line">class Solution:</span><br><span class="line">    def IsContinuous(self, numbers):</span><br><span class="line">        # write code here</span><br><span class="line">        num_set = set()</span><br><span class="line">        ma = 0</span><br><span class="line">        mi = 14</span><br><span class="line">        for i in numbers:</span><br><span class="line">            if i in num_set:</span><br><span class="line">                return False</span><br><span class="line">            if i == 0:</span><br><span class="line">                continue</span><br><span class="line">            ma = max(ma, i)</span><br><span class="line">            mi = min(mi, i)</span><br><span class="line">            num_set.add(i)</span><br><span class="line">        if ma - mi &lt;= 4:</span><br><span class="line">            return True</span><br><span class="line">            </span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ67 把字符串转换成整数</span><br><span class="line">#将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</span><br><span class="line"></span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def StrToInt(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        if s == None or s == &#x27;&#x27; or s == &#x27;+&#x27; or s == &#x27;-&#x27;:</span><br><span class="line">            return 0</span><br><span class="line">        nums = set()</span><br><span class="line">        for i in range(10):</span><br><span class="line">            nums.add((str)(i))</span><br><span class="line">        </span><br><span class="line">        for i in s[1:]:</span><br><span class="line">            if i not in nums:</span><br><span class="line">                return 0</span><br><span class="line">        if s[0] == &#x27;+&#x27;:</span><br><span class="line">            s = s[1:]</span><br><span class="line">            return (int)(s)</span><br><span class="line">        elif s[0] == &#x27;-&#x27;:</span><br><span class="line">            s = s[1:]</span><br><span class="line">            return -(int)(s)</span><br><span class="line">        else:</span><br><span class="line">            return (int)(s)</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ20 表示数值的字符串</span><br><span class="line"># 请实现一个函数用来判断字符串str是否表示数值（包括科学计数法的数字，小数和整数）。</span><br><span class="line"></span><br><span class="line"># 解题思路：正则表达式</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isNumeric(self , s):</span><br><span class="line">        import re</span><br><span class="line">        #patn = re.compile(&#x27;^\s*[+-]&#123;0,1&#125;((\d)+((\.)(\d)+)&#123;0,1&#125;|((\.)(\d)+)|((\d)+(\.)))([eE][+-]&#123;0,1&#125;[\d]+)&#123;0,1&#125;\s*$&#x27;)</span><br><span class="line">        p1 = &#x27;^\s*[+-]&#123;0,1&#125;&#x27;</span><br><span class="line">        p2 = &#x27;(((\d)+)|((\d)+(\.))|((\d)+(\.)(\d)+)|((\.)(\d)+))\s*&#x27;</span><br><span class="line">        p3 = &#x27;([eE][+-]&#123;0,1&#125;(\d)+)&#123;0,1&#125;\s*$&#x27;</span><br><span class="line">        match_pattern = re.compile(p1 + p2 + p3)</span><br><span class="line">        </span><br><span class="line">        return match_pattern.match(s)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ55 二叉树的深度</span><br><span class="line">#输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 递归函数功能：获取当前节点 root 的深度</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # 递归终止条件：递归到叶子节点</span><br><span class="line">        if pRoot is None:</span><br><span class="line">            return 0</span><br><span class="line">        # 得到左右子树中较大的子树深度</span><br><span class="line">        return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right)) +1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ77 按之字形顺序打印二叉树</span><br><span class="line">#给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</span><br><span class="line"></span><br><span class="line"># 解题思路：层序遍历，队列实现，输出时奇数层从左往右，偶数层从右往左</span><br><span class="line"></span><br><span class="line"># 层序遍历实现模板，背记</span><br><span class="line">class Solution:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        queue = [pRoot]</span><br><span class="line">        res = [].extend(queue)</span><br><span class="line">        while queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            for node in queue:</span><br><span class="line">                if node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">            res = res.extend(queue)</span><br><span class="line">        return res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># 层序遍历</span><br><span class="line">class Solution:</span><br><span class="line">    def Print(self, pRoot):</span><br><span class="line">        if pRoot==None:</span><br><span class="line">            return []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [pRoot]</span><br><span class="line">        index = 1</span><br><span class="line">        while queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            for i in range(len(queue)):</span><br><span class="line">                node = queue[0]</span><br><span class="line">                queue = queue[1:]</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                if node.left:  queue.append(node.left)</span><br><span class="line">                if node.right:  queue.append(node.right)</span><br><span class="line">            if index % 2 == 1:</span><br><span class="line">                res.append(tmp)</span><br><span class="line">            else:</span><br><span class="line">                res.append(tmp[::-1])</span><br><span class="line">            index += 1</span><br><span class="line">        return res</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ54 二叉搜索树的第k个结点</span><br><span class="line"># 给定一棵结点数为 n 二叉搜索树，请找出其中的第 k 小的TreeNode结点。</span><br><span class="line"></span><br><span class="line"># 解题思路：二叉搜索树的中序遍历即为从小到大的顺序</span><br><span class="line"># 中序遍历模板，背记</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回对应节点TreeNode</span><br><span class="line">    def KthNode(self, pRoot, k):</span><br><span class="line">        if pRoot == None or k &lt;= 0:</span><br><span class="line">            return None</span><br><span class="line">        res = []</span><br><span class="line">        def in_order(cur):</span><br><span class="line">            if cur == None:</span><br><span class="line">                return </span><br><span class="line">            in_order(cur.left)</span><br><span class="line">            res.append(cur)</span><br><span class="line">            in_order(cur.right)</span><br><span class="line">        in_order(pRoot)</span><br><span class="line">        if k &gt; len(res):</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            return res[k-1]</span><br><span class="line"></span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回对应节点TreeNode</span><br><span class="line">    def KthNode(self, pRoot, k):</span><br><span class="line">        # write code here</span><br><span class="line">        stack = [(pRoot, 0)]</span><br><span class="line">        while stack:</span><br><span class="line">            node, action = stack.pop()</span><br><span class="line">            if node is None:</span><br><span class="line">                continue</span><br><span class="line">            if action == 0:</span><br><span class="line">                stack.append((node.right, 0))</span><br><span class="line">                stack.append((node, 1))</span><br><span class="line">                stack.append((node.left, 0))</span><br><span class="line">            else:</span><br><span class="line">                k -= 1</span><br><span class="line">                if k == 0:</span><br><span class="line">                    return node</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ7 重建二叉树</span><br><span class="line"># 给定节点数为 n 二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</span><br><span class="line"></span><br><span class="line"># 解题思路：先序确定根，然后根据根在中序中进行二分</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pre:</span><br><span class="line">            return None</span><br><span class="line">        # 根节点</span><br><span class="line">        root = TreeNode(pre[0])</span><br><span class="line">        # 根节点在中序遍历中的位置索引</span><br><span class="line">        tmp = tin.index(pre[0])</span><br><span class="line">        # 递归 构造树的左子树</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre[1:tmp+1], tin[:tmp])</span><br><span class="line">        # 递归构造树的右子树</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre[tmp+1:], tin[tmp+1:])</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ26 树的子结构</span><br><span class="line"># 输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def HasSubtree(self, pRoot1, pRoot2):</span><br><span class="line">        # write code here</span><br><span class="line">        # 递归</span><br><span class="line">        def dfs(A, B):</span><br><span class="line">            # </span><br><span class="line">            if not B:</span><br><span class="line">                return True</span><br><span class="line">            elif not A:</span><br><span class="line">                return False</span><br><span class="line">            elif A.val != B.val:</span><br><span class="line">                return False</span><br><span class="line">            # 对比A  B的左右子树是否相同</span><br><span class="line">            return dfs(A.left, B.left) and dfs(A.right, B.right)</span><br><span class="line">        # 特殊情况</span><br><span class="line">        if not pRoot1 or not pRoot2:</span><br><span class="line">            return False</span><br><span class="line">        # 递归计算 pRoot1, pRoot2 是否相同/pRoot1的左子树、右子树是否和pRoot2相同</span><br><span class="line">        return dfs(pRoot1, pRoot2) or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.flag = False</span><br><span class="line">    </span><br><span class="line">    def dfs(self, A, B):</span><br><span class="line">            # </span><br><span class="line">            if not B:</span><br><span class="line">                return True</span><br><span class="line">            elif not A:</span><br><span class="line">                return False</span><br><span class="line">            elif A.val != B.val:</span><br><span class="line">                return False</span><br><span class="line">            # 对比A  B的左右子树是否相同</span><br><span class="line">            return self.dfs(A.left, B.left) and self.dfs(A.right, B.right)</span><br><span class="line">    </span><br><span class="line">    def HasSubtree(self, pRoot1, pRoot2):</span><br><span class="line">        # write code here</span><br><span class="line">        # 特殊情况</span><br><span class="line">        if not pRoot1 or not pRoot2:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        def in_order(cur):</span><br><span class="line">            if cur == None:</span><br><span class="line">                return </span><br><span class="line">            in_order(cur.left)</span><br><span class="line">            if self.dfs(cur, pRoot2):</span><br><span class="line">                self.flag = True</span><br><span class="line">            in_order(cur.right)</span><br><span class="line">        in_order(pRoot1)</span><br><span class="line">        return self.flag</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line">#JZ27 二叉树的镜像</span><br><span class="line"># 操作给定的二叉树，将其变换为源二叉树的镜像。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def Mirror(self , pRoot ):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot == None:</span><br><span class="line">            return None</span><br><span class="line">        pRoot.left, pRoot.right = pRoot.right, pRoot.left</span><br><span class="line">        self.Mirror(pRoot.left)</span><br><span class="line">        self.Mirror(pRoot.right)</span><br><span class="line">        return pRoot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ32 从上往下打印二叉树</span><br><span class="line"># 不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。</span><br><span class="line"></span><br><span class="line"># 层序遍历</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从上到下每个节点值列表，例：[1,2,3]</span><br><span class="line">    def PrintFromTopToBottom(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        while queue:</span><br><span class="line">            # 每层</span><br><span class="line">            for i in range(len(queue)):</span><br><span class="line">                node = queue.pop(0)</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                if node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ33 二叉搜索树的后序遍历序列</span><br><span class="line"># 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.flag = True</span><br><span class="line">    </span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(sequence) == 0:</span><br><span class="line">            return </span><br><span class="line">        root = sequence[-1]</span><br><span class="line">        tmp = 0</span><br><span class="line">        while sequence[tmp] &lt; root:</span><br><span class="line">            tmp += 1</span><br><span class="line">        for i in sequence[tmp:]:</span><br><span class="line">            if i &lt; root:</span><br><span class="line">                self.flag = False</span><br><span class="line">        self.VerifySquenceOfBST(sequence[:tmp])</span><br><span class="line">        self.VerifySquenceOfBST(sequence[tmp:-2])</span><br><span class="line">        return self.flag</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ34 二叉树中和为某一值的路径</span><br><span class="line"># 输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径。</span><br><span class="line"># 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</span><br><span class="line"></span><br><span class="line">outlist = []</span><br><span class="line">def dg(root, a, expectNumber):</span><br><span class="line">    a = a + [root.val]</span><br><span class="line">    #a.append(root.val)  这里不能用append，因为append是改变原来的a, 而+是产生新的a，改变a会使得left之后right的a被改变，+则不会</span><br><span class="line">    if not root.left and not root.right:</span><br><span class="line">        if sum(a) == expectNumber:</span><br><span class="line">            outlist.append(a)</span><br><span class="line">        return</span><br><span class="line">    if root.left: dg(root.left, a, expectNumber)</span><br><span class="line">    if root.right: dg(root.right, a, expectNumber)</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回二维列表，内部每个列表表示找到的路径</span><br><span class="line">    def FindPath(self, root, expectNumber):</span><br><span class="line">        # write code here</span><br><span class="line">        if root: dg(root, [], expectNumber)</span><br><span class="line">        return outlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ36 二叉搜索树与双向链表</span><br><span class="line"># 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</span><br><span class="line"># 解题思路：根据二叉树的中序遍历，并将遍历结果存储到数组中，再对数组进行遍历生成双向链表</span><br><span class="line"># res[i].right = res[i+1]</span><br><span class="line"># res[i+1].left = res[i]</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def Convert(self, pRootOfTree):</span><br><span class="line">        # write code here</span><br><span class="line">        # 首先进行中序排序</span><br><span class="line">        def inorder(root, res):</span><br><span class="line">            if not root:</span><br><span class="line">                return None</span><br><span class="line">            inorder(root.left, res)</span><br><span class="line">            res.append(root)</span><br><span class="line">            inorder(root.right, res)</span><br><span class="line">        res = []</span><br><span class="line">        if not pRootOfTree:</span><br><span class="line">            return None</span><br><span class="line">        inorder(pRootOfTree, res)</span><br><span class="line">        if len(res) == 1:</span><br><span class="line">            return pRootOfTree</span><br><span class="line">        # 构造双向链表</span><br><span class="line">        for i in range(len(res)-1):</span><br><span class="line">            res[i].right = res[i+1]</span><br><span class="line">            res[i+1].left = res[i]</span><br><span class="line">        return res[0]</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ79 平衡二叉树</span><br><span class="line"># 输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.flag = True</span><br><span class="line">        </span><br><span class="line">    def depth(self, root):</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        return max(self.depth(root.left), self.depth(root.right)) + 1</span><br><span class="line">    </span><br><span class="line">    def IsBalanced_Solution(self , pRoot: TreeNode) -&gt; bool:</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return True</span><br><span class="line">        depth_left = self.depth(pRoot.left)</span><br><span class="line">        depth_right = self.depth(pRoot.right)</span><br><span class="line">        if abs(depth_left-depth_right) &gt; 1:</span><br><span class="line">            self.flag =  False</span><br><span class="line">        self.IsBalanced_Solution(pRoot.left)</span><br><span class="line">        self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">        return self.flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ8 二叉树的下一个结点</span><br><span class="line"># 给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.in_order_list = []</span><br><span class="line">        </span><br><span class="line">    def in_order(self, root):</span><br><span class="line">        if not root:</span><br><span class="line">            return </span><br><span class="line">        self.in_order(root.left)</span><br><span class="line">        self.in_order_list.append(root)</span><br><span class="line">        self.in_order(root.right)</span><br><span class="line">    </span><br><span class="line">    def GetNext(self, pNode):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pNode:</span><br><span class="line">            return None</span><br><span class="line">        tmp = pNode</span><br><span class="line">        root = pNode</span><br><span class="line">        while pNode:</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">            if pNode:</span><br><span class="line">                root = pNode</span><br><span class="line">        self.in_order(root)</span><br><span class="line">        for i in range(len(self.in_order_list)):</span><br><span class="line">            if self.in_order_list[i] == tmp:</span><br><span class="line">                if i+1 &gt;= len(self.in_order_list):</span><br><span class="line">                    return None</span><br><span class="line">                else:</span><br><span class="line">                    return self.in_order_list[i+1]</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ28 对称的二叉树</span><br><span class="line"># 给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）</span><br><span class="line"></span><br><span class="line"># 解题思路：1. 层序遍历，每层分别判断是否对称</span><br><span class="line">#          2. 递归，将对称与否变成子树的判断</span><br><span class="line"># 递归</span><br><span class="line">class Solution:</span><br><span class="line">    def check(self, a,b):</span><br><span class="line">        if not a and not b:</span><br><span class="line">            return True</span><br><span class="line">        elif not a or not b:</span><br><span class="line">            return False</span><br><span class="line">        elif a.val != b.val:</span><br><span class="line">            return False</span><br><span class="line">        return self.check(a.left, b.right) and self.check(a.right, b.left)</span><br><span class="line">        </span><br><span class="line">    def isSymmetrical(self , pRoot: TreeNode) -&gt; bool:</span><br><span class="line">        return self.check(pRoot, pRoot)</span><br><span class="line"></span><br><span class="line"># 层序</span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.flag = True</span><br><span class="line">    </span><br><span class="line">    def for_layer(self, node_list):</span><br><span class="line">        n = len(node_list)</span><br><span class="line">        l,r = 0,n-1</span><br><span class="line">        while l &lt; r:</span><br><span class="line">            if node_list[l] != node_list[r]:</span><br><span class="line">                self.flag = False</span><br><span class="line">            l += 1</span><br><span class="line">            r -= 1</span><br><span class="line">    </span><br><span class="line">    def isSymmetrical(self , pRoot: TreeNode) -&gt; bool:</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return True</span><br><span class="line">        queue = [pRoot]</span><br><span class="line">        tmp = TreeNode(1001)</span><br><span class="line">        while queue:</span><br><span class="line">            layer = []</span><br><span class="line">            for i in range(len(queue)):</span><br><span class="line">                # 注意是pop(0)而非pop(), 弹出第一个而不是最后一个</span><br><span class="line">                node = queue.pop(0)</span><br><span class="line">                layer.append(node.val)</span><br><span class="line">                # 注意对空节点的处理，否则会无限循环，这也是一般判断node.left的原因</span><br><span class="line">                if node.val != 1001:</span><br><span class="line">                    if node.left:</span><br><span class="line">                        queue.append(node.left)</span><br><span class="line">                    else:</span><br><span class="line">                        queue.append(tmp)</span><br><span class="line">                    if node.right:</span><br><span class="line">                        queue.append(node.right)</span><br><span class="line">                    else:</span><br><span class="line">                        queue.append(tmp)</span><br><span class="line">            self.for_layer(layer)</span><br><span class="line">        return self.flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ78 把二叉树打印成多行</span><br><span class="line"># 给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回</span><br><span class="line"># 解题思路：层序遍历</span><br><span class="line">class Solution:</span><br><span class="line">    def Print(self , pRoot: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return </span><br><span class="line">        queue = [pRoot]</span><br><span class="line">        res = []</span><br><span class="line">        while queue:</span><br><span class="line">            layer = []</span><br><span class="line">            for i in range(len(queue)):</span><br><span class="line">                node = queue.pop(0)</span><br><span class="line">                layer.append(node.val)</span><br><span class="line">                if node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(layer)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ37 序列化二叉树</span><br><span class="line"># 请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def Serialize(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        empty_node = TreeNode(101)</span><br><span class="line">        while queue:</span><br><span class="line">            for i in range(len(queue)):</span><br><span class="line">                node = queue.pop(0)</span><br><span class="line">                if node.val != 101:</span><br><span class="line">                    res.append(node.val)</span><br><span class="line">                    if node.left:</span><br><span class="line">                        queue.append(node.left)</span><br><span class="line">                    else:</span><br><span class="line">                        queue.append(empty_node)</span><br><span class="line">                    if node.right:</span><br><span class="line">                        queue.append(node.right)</span><br><span class="line">                    else:</span><br><span class="line">                        queue.append(empty_node)</span><br><span class="line">                else:</span><br><span class="line">                    res.append(&#x27;#&#x27;)</span><br><span class="line">        return res</span><br><span class="line">        </span><br><span class="line">    def Deserialize(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        if not s:</span><br><span class="line">            return None</span><br><span class="line">        if s[0] == &#x27;#&#x27;:</span><br><span class="line">            return None</span><br><span class="line">        root = TreeNode(s.pop(0))</span><br><span class="line">        created = [root]</span><br><span class="line">        while created:</span><br><span class="line">            toBeCreated = []</span><br><span class="line">            for node in created:</span><br><span class="line">                left = s.pop(0)</span><br><span class="line">                right = s.pop(0)</span><br><span class="line">                if left != &#x27;#&#x27;:</span><br><span class="line">                    leftNode = TreeNode(left)</span><br><span class="line">                    toBeCreated.append(leftNode)</span><br><span class="line">                    node.left = leftNode</span><br><span class="line">                if right != &#x27;#&#x27;:</span><br><span class="line">                    rightNode = TreeNode(right)</span><br><span class="line">                    toBeCreated.append(rightNode)</span><br><span class="line">                    node.right = rightNode</span><br><span class="line">            created = toBeCreated</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ84 二叉树中和为某一值的路径(三)</span><br><span class="line"># 给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。</span><br><span class="line">#1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点</span><br><span class="line">#2.总节点数目为n</span><br><span class="line">#3.保证最后返回的路径个数在整形范围内(即路径个数小于2^31-1)</span><br><span class="line"></span><br><span class="line">import sys   </span><br><span class="line"># 这里是调整递归深度，python默认递归深度1000，太小了，有时候增加递归深度可以有奇效</span><br><span class="line">sys.setrecursionlimit(100000)</span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.path_num = 0</span><br><span class="line">        </span><br><span class="line">    def from_root(self, root, sum):</span><br><span class="line">        if not root:</span><br><span class="line">            return </span><br><span class="line">        # 因为不要求记录路径，只需要返回路径数，如果要记录路径则更麻烦</span><br><span class="line">        sum -= root.val</span><br><span class="line">        if sum == 0:</span><br><span class="line">            self.path_num += 1</span><br><span class="line">        self.from_root(root.left, sum)</span><br><span class="line">        self.from_root(root.right, sum)</span><br><span class="line">    </span><br><span class="line">    def FindPath(self , root: TreeNode, sum: int) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        # 先序遍历，选择出发点</span><br><span class="line">        self.from_root(root, sum)</span><br><span class="line">        self.FindPath(root.left, sum)</span><br><span class="line">        self.FindPath(root.right, sum)</span><br><span class="line">        return self.path_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ68 在二叉树中找到两个节点的最近公共祖先</span><br><span class="line"># 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.check1 = False</span><br><span class="line">        self.check2 = False</span><br><span class="line">        </span><br><span class="line">    def check_node(self, node, val1, val2):</span><br><span class="line">        if not node:</span><br><span class="line">            return False</span><br><span class="line">        if node.val == val1:</span><br><span class="line">            self.check1 = True</span><br><span class="line">        if node.val == val2:</span><br><span class="line">            self.check2 = True</span><br><span class="line">        self.check_node(node.left, val1, val2)</span><br><span class="line">        self.check_node(node.right, val1, val2)</span><br><span class="line">        return self.check1 and self.check2</span><br><span class="line">    </span><br><span class="line">    def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        if not root:</span><br><span class="line">            return None</span><br><span class="line">        queue = [root]</span><br><span class="line">        ancestor = None</span><br><span class="line">        while queue:</span><br><span class="line">            for i in range(len(queue)):</span><br><span class="line">                node = queue.pop(0)</span><br><span class="line">                self.check1, self.check2 = False, False</span><br><span class="line">                res = self.check_node(node, o1, o2)</span><br><span class="line">                if res:</span><br><span class="line">                    ancestor = node.val</span><br><span class="line">                if node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        return ancestor</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ66 构建乘积数组</span><br><span class="line"># 给定一个数组 A[0,1,...,n-1] ,请构建一个数组 B[0,1,...,n-1] ,其中 B 的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</span><br><span class="line"># （除 A[i] 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 B[0] = A[1] * A[2] * ... * A[n-1]，</span><br><span class="line"># B[n-1] = A[0] * A[1] * ... * A[n-2]）, 对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def get_B(self, A,j):</span><br><span class="line">        b = 1</span><br><span class="line">        for i in range(len(A)):</span><br><span class="line">            if i != j:</span><br><span class="line">                b *= A[i]</span><br><span class="line">        return b</span><br><span class="line">    </span><br><span class="line">    def multiply(self , A: List[int]) -&gt; List[int]:</span><br><span class="line">        # write code here</span><br><span class="line">        n = len(A)</span><br><span class="line">        if n &lt;= 1:</span><br><span class="line">            return None</span><br><span class="line">        B = [0]*n </span><br><span class="line">        for i in range(n):</span><br><span class="line">            B[i] = self.get_B(A, i)</span><br><span class="line">        return B</span><br><span class="line"></span><br><span class="line"># 优化，也可以B[i] = left[i] * right[i]</span><br><span class="line">class Solution:</span><br><span class="line">    def multiply(self, A):</span><br><span class="line">        # write code here</span><br><span class="line">        B =  [1] *len(A)</span><br><span class="line">        temp =1</span><br><span class="line">        for i in range(1,len(A)):</span><br><span class="line">            B[i] = B[i-1] *A[i-1]</span><br><span class="line">             </span><br><span class="line">        for i in range(len(A)-2,-1,-1):</span><br><span class="line">            temp *= A[i+1]</span><br><span class="line">            B[i] *=temp</span><br><span class="line">        return B</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ50 第一个只出现一次的字符</span><br><span class="line"># 在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def FirstNotRepeatingChar(self , str: str) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        repeat_char = set()</span><br><span class="line">        chars = set()</span><br><span class="line">        for i in str:</span><br><span class="line">            if i in chars:</span><br><span class="line">                repeat_char.add(i)</span><br><span class="line">            chars.add(i)</span><br><span class="line">        for i in range(len(str)):</span><br><span class="line">            if str[i] not in repeat_char:</span><br><span class="line">                return i</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ5 替换空格</span><br><span class="line"># 请实现一个函数，将一个字符串s中的每个空格替换成“%20”。</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">class Solution:</span><br><span class="line">    def replaceSpace(self , s: str) -&gt; str:</span><br><span class="line">        # write code here</span><br><span class="line">        pattern = re.compile(r&quot;(\s)&quot;)</span><br><span class="line">        s = re.sub(pattern, &#x27;%20&#x27;, s)</span><br><span class="line">        return s</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ21 调整数组顺序使奇数位于偶数前面(一)</span><br><span class="line"># 输入一个长度为 n 整数数组，数组里面不含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，</span><br><span class="line"># 所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span><br><span class="line">class Solution:</span><br><span class="line">    def reOrderArray(self , array: List[int]) -&gt; List[int]:</span><br><span class="line">        # write code here</span><br><span class="line">        res = []</span><br><span class="line">        for each in array:</span><br><span class="line">            if each % 2 != 0:</span><br><span class="line">                res.append(each)</span><br><span class="line">        for each in array:</span><br><span class="line">            if each % 2 == 0:</span><br><span class="line">                res.append(each)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ39 数组中出现次数超过一半的数字</span><br><span class="line"># 给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</span><br><span class="line"># 例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</span><br><span class="line"></span><br><span class="line"># 解题思路：</span><br><span class="line"># 1. 可以先遍历一遍数组，在map中存每个元素出现的次数，然后再遍历一次数组，找出众数</span><br><span class="line"># 2. 可以先将数组排序，然后可能的众数肯定在数组中间，然后判断一下</span><br><span class="line"># 3. 如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。</span><br><span class="line">class Solution:</span><br><span class="line">    def MoreThanHalfNum_Solution(self , numbers: List[int]) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        n = len(numbers)</span><br><span class="line">        n = n //2</span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        for i in numbers:</span><br><span class="line">            if i in dict.keys():</span><br><span class="line">                dict[i] += 1</span><br><span class="line">            else:</span><br><span class="line">                dict[i] = 1</span><br><span class="line">        for i in numbers:</span><br><span class="line">            if dict[i] &gt; n:</span><br><span class="line">                return i </span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ83 剪绳子（进阶版）</span><br><span class="line"># 给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），每段绳子的长度记为 k[1],...,k[m] 。</span><br><span class="line"># 请问 k[1]*k[2]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</span><br><span class="line"># 由于答案过大，请对 998244353 取模。</span><br><span class="line"></span><br><span class="line"># 解题思路：首先找规律，发现能凑3就凑3，实在不行就凑2，但是千万不能凑出来1(4拆成两个2)</span><br><span class="line"># 但是这就遇到第二个问题，运行超时，于是用快速幂运算，即二分递归</span><br><span class="line">import sys</span><br><span class="line">sys.setrecursionlimit(10000)</span><br><span class="line">class Solution:</span><br><span class="line">    # 快速幂运算</span><br><span class="line">    def fast_pow(self, cnt):</span><br><span class="line">        if cnt == 0: return 1</span><br><span class="line">        if cnt == 1:</span><br><span class="line">            return 3</span><br><span class="line">        part = self.fast_pow(cnt//2)</span><br><span class="line">        if cnt % 2 == 1:</span><br><span class="line">            # 不要忘了，取模后可以减少运算量</span><br><span class="line">            return 3 * part * part % 998244353</span><br><span class="line">        else:</span><br><span class="line">            return part * part % 998244353</span><br><span class="line">    </span><br><span class="line">    def cutRope(self , number: int) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        if number == 2:</span><br><span class="line">            return 1</span><br><span class="line">        if number == 3:</span><br><span class="line">            return 2</span><br><span class="line">        cnt = number // 3</span><br><span class="line">        if number % 3 == 0:</span><br><span class="line">            return self.fast_pow(cnt) % 998244353 </span><br><span class="line">        elif number % 3 == 1:</span><br><span class="line">            cnt -= 1</span><br><span class="line">            return (2 * 2 * self.fast_pow(cnt)) % 998244353 </span><br><span class="line">        else:</span><br><span class="line">            return 2 * self.fast_pow(cnt) % 998244353</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ43 整数中1出现的次数（从1到n整数中1出现的次数）</span><br><span class="line"># 输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def get_count(self, n):</span><br><span class="line">            count = 0</span><br><span class="line">            while n &gt;0:</span><br><span class="line">                if n%10 == 1:</span><br><span class="line">                    count += 1</span><br><span class="line">                n = n // 10</span><br><span class="line">            return count </span><br><span class="line">        </span><br><span class="line">    def NumberOf1Between1AndN_Solution(self , n: int) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        sum_count = 0</span><br><span class="line">        for i in range(1,n+1):</span><br><span class="line">            count = self.get_count(i)</span><br><span class="line">            sum_count += count </span><br><span class="line">        return sum_count </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ45 把数组排成最小的数</span><br><span class="line"># 输入一个正整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个</span><br><span class="line">import functools</span><br><span class="line">class Solution:</span><br><span class="line">    def PrintMinNumber(self , numbers: List[int]) -&gt; str:</span><br><span class="line">        # write code here</span><br><span class="line">        if not numbers: return &#x27;&#x27;</span><br><span class="line">        min_string = sorted(numbers, key=functools.cmp_to_key(self.cmp))</span><br><span class="line">        return &#x27;&#x27;.join(str(s) for s in min_string)</span><br><span class="line">    def cmp(self,x,y):</span><br><span class="line">        if str(x)+str(y) &gt; str(y)+str(x): return 1 #可理解为前大于后，就换（1），从小到大</span><br><span class="line">        if str(x)+str(y) == str(y)+str(x): return 0</span><br><span class="line">        if str(x)+str(y) &lt; str(y)+str(x): return -1</span><br><span class="line">#         per = itertools.permutations(numbers,len(numbers))</span><br><span class="line">#         jo = [&#x27;&#x27;.join(str(_) for _ in elem) for elem in per]</span><br><span class="line">#         return min(jo)</span><br><span class="line">#         return min([&#x27;&#x27;.join(str(_) for _ in elem) for elem in itertools.permutations(numbers,len(numbers))]) if numbers else &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ49 丑数</span><br><span class="line"># 把只包含质因子2、3和5的数称作丑数（Ugly Number）。</span><br><span class="line"># 例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def GetUglyNumber_Solution(self , index: int) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        if index &lt; 1: return 0</span><br><span class="line">        i,j,k = 0,0,0</span><br><span class="line">        res = [1]</span><br><span class="line">        for m in range(1, index):</span><br><span class="line">            tmp = min(res[i]*2, res[j]*3, res[k]*5)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            if tmp == res[i] * 2:</span><br><span class="line">                i += 1</span><br><span class="line">            if tmp == res[j] *3:</span><br><span class="line">                j += 1</span><br><span class="line">            if tmp == res[k] * 5:</span><br><span class="line">                k += 1</span><br><span class="line">        return res[index - 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ74 和为S的连续正数序列</span><br><span class="line"># 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,</span><br><span class="line"># 他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。</span><br><span class="line"># 现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? </span><br><span class="line"></span><br><span class="line"># 解题思路：1，前缀和  2，滑动窗口</span><br><span class="line">class Solution:</span><br><span class="line">    def FindContinuousSequence(self , sum: int) -&gt; List[List[int]]:</span><br><span class="line">        # write code here</span><br><span class="line">        res = []</span><br><span class="line">        for i in range(1, sum//2+1):</span><br><span class="line">            tmp_sum = 0</span><br><span class="line">            j = i</span><br><span class="line">            tmp_list = []</span><br><span class="line">            while tmp_sum &lt; sum:</span><br><span class="line">                tmp_sum += j</span><br><span class="line">                tmp_list.append(j)</span><br><span class="line">                j+=1</span><br><span class="line">            if tmp_sum == sum:</span><br><span class="line">                res.append(tmp_list)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"># 滑动窗口</span><br><span class="line">class Solution:</span><br><span class="line">    def FindContinuousSequence(self , sum: int) -&gt; List[List[int]]:</span><br><span class="line">        # write code here</span><br><span class="line">        res = []</span><br><span class="line">        l, r = 1, 1</span><br><span class="line">        tmp_sum = 0</span><br><span class="line">        while l &lt;= sum//2:</span><br><span class="line">            if tmp_sum &lt; sum:</span><br><span class="line">                tmp_sum += r</span><br><span class="line">                r += 1</span><br><span class="line">            elif tmp_sum &gt; sum:</span><br><span class="line">                tmp_sum -= l</span><br><span class="line">                l += 1</span><br><span class="line">            else:</span><br><span class="line">                res.append(range(l, r))</span><br><span class="line">                tmp_sum -= l</span><br><span class="line">                l += 1</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ57 和为S的两个数字</span><br><span class="line"># 输入一个递增排序的数组array和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，</span><br><span class="line"># 如果无法找出这样的数字，返回一个空数组即可。</span><br><span class="line"></span><br><span class="line"># 解题思路：双指针法</span><br><span class="line">class Solution:</span><br><span class="line">    def FindNumbersWithSum(self , array: List[int], sum: int) -&gt; List[int]:</span><br><span class="line">        # write code here</span><br><span class="line">        i, j = 0, len(array)-1</span><br><span class="line">        while i &lt; j:</span><br><span class="line">            if array[i] + array[j] == sum:</span><br><span class="line">                return [array[i], array[j]]</span><br><span class="line">            elif array[i] + array[j] &lt; sum:</span><br><span class="line">                i += 1</span><br><span class="line">            else:</span><br><span class="line">                j-=1</span><br><span class="line">        return []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ58 左旋转字符串</span><br><span class="line"># 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。</span><br><span class="line"># 对于一个给定的字符序列  S ，请你把其循环左移 K 位后的序列输出（保证 K 小于等于 S 的长度）</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def LeftRotateString(self , str: str, n: int) -&gt; str:</span><br><span class="line">        # write code here</span><br><span class="line">        if not str:</span><br><span class="line">            return &#x27;&#x27;</span><br><span class="line">        n = n % len(str)</span><br><span class="line">        return str[n:] + str[:n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ62 孩子们的游戏(圆圈中最后剩下的数)</span><br><span class="line"># 每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，</span><br><span class="line"># 小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，</span><br><span class="line"># 然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0... m-1报数....这样下去....直到剩下最后一个小朋友，</span><br><span class="line"># 可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？</span><br><span class="line"></span><br><span class="line"># 解题思路：约瑟夫环：删除报到k的人，直到只剩下一个人</span><br><span class="line"># f(n,m) = (f(n-1,m)+m) %n</span><br><span class="line">import sys</span><br><span class="line">sys.setrecursionlimit(10000)</span><br><span class="line">class Solution:</span><br><span class="line">    def LastRemaining_Solution(self , n: int, m: int) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;= 1:</span><br><span class="line">            return 0</span><br><span class="line">        return (self.LastRemaining_Solution(n-1, m) + m)%n</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">sys.setrecursionlimit(10000)</span><br><span class="line">class Solution:</span><br><span class="line">    def LastRemaining_Solution(self , n: int, m: int) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;= 1:</span><br><span class="line">            return 0</span><br><span class="line">        # f(n,m) = (f(n-1,m)+m)%n</span><br><span class="line">        f = 0</span><br><span class="line">        for i in range(2, n+1):</span><br><span class="line">            f = (f+m)%i </span><br><span class="line">        return f</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ75 字符流中第一个不重复的字符</span><br><span class="line"># 请实现一个函数用来找出字符流中第一个只出现一次的字符</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回对应char</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.q = []</span><br><span class="line">        self.mq = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    def FirstAppearingOnce(self):</span><br><span class="line">        # write code here</span><br><span class="line">        while self.q:</span><br><span class="line">            top = self.q[0]</span><br><span class="line">            if self.mq[top] == 1:</span><br><span class="line">                return top</span><br><span class="line">            else:</span><br><span class="line">                self.q.pop(0)</span><br><span class="line">        return &quot;#&quot;</span><br><span class="line">            </span><br><span class="line">    def Insert(self, char):</span><br><span class="line">        # write code here</span><br><span class="line">        if char not in self.mq.keys():</span><br><span class="line">            self.q.append(char)</span><br><span class="line">            self.mq[char] = 1</span><br><span class="line">        else:</span><br><span class="line">            self.mq[char] += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ14 剪绳子</span><br><span class="line"># 给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），</span><br><span class="line"># 每段绳子的长度记为 k[1],...,k[m] 。请问 k[1]*k[2]*...*k[m] 可能的最大乘积是多少？</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def cutRope(self , number: int) -&gt; int:</span><br><span class="line">        # write code here</span><br><span class="line">        res = 1</span><br><span class="line">        while number &gt; 4:</span><br><span class="line">            number -= 3</span><br><span class="line">            res *= 3</span><br><span class="line">            </span><br><span class="line">        if number == 4:</span><br><span class="line">            res *= 4</span><br><span class="line">        elif number == 3:</span><br><span class="line">            res *= 3</span><br><span class="line">        elif number == 2:</span><br><span class="line">            res *= 2</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># JZ81 调整数组顺序使奇数位于偶数前面(二)</span><br><span class="line"># 输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，</span><br><span class="line"># 使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，</span><br><span class="line"># 但是时间复杂度和空间复杂度必须如下要求。</span><br><span class="line"></span><br><span class="line"># 解题思路：双指针法</span><br><span class="line">class Solution:</span><br><span class="line">    def reOrderArrayTwo(self , array: List[int]) -&gt; List[int]:</span><br><span class="line">        # write code here</span><br><span class="line">        i, j = 0, len(array)-1</span><br><span class="line">        while i &lt; j:</span><br><span class="line">            while array[i] % 2 == 1:</span><br><span class="line">                i += 1</span><br><span class="line">            while array[j] % 2 == 0:</span><br><span class="line">                j -= 1</span><br><span class="line">            if i &lt; j:</span><br><span class="line">                array[i], array[j] = array[j], array[i]</span><br><span class="line">                i += 1</span><br><span class="line">                j -= 1</span><br><span class="line">        return array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################################################################</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line"># </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="JZ" scheme="https://zhengluoliudao.github.io/tags/JZ/"/>
    
    <category term="剑指offer" scheme="https://zhengluoliudao.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>SQL专题</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/SQL%E4%B8%93%E9%A2%98/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/SQL%E4%B8%93%E9%A2%98/</id>
    <published>2022-01-02T09:47:49.000Z</published>
    <updated>2022-01-02T09:48:33.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL专题"><a href="#SQL专题" class="headerlink" title="SQL专题"></a>SQL专题</h2><h4 id="1-SQL1-插入记录（一）"><a href="#1-SQL1-插入记录（一）" class="headerlink" title="#1 SQL1 插入记录（一）"></a>#1 <strong>SQL1</strong> <strong>插入记录（一）</strong></h4><p>牛客后台会记录每个用户的试卷作答记录到exam_record表，现在有两个用户的作答记录详情如下：</p><ul><li>用户1001在2021年9月1日晚上10点11分12秒开始作答试卷9001，并在50分钟后提交，得了90分；</li><li>用户1002在2021年9月4日上午7点1分2秒开始作答试卷9002，并在10分钟后退出了平台。</li></ul><p>试卷作答记录表exam_record中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p><p>该题最后会通过执行SELECT uid, exam_id, start_time, submit_time, score FROM exam_record;来对比结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">insert into exam_record</span><br><span class="line">VALUES (null,1001,9001,&#x27;2021-09-01 22:11:12&#x27;,&#x27;2021-09-01 22:11:12&#x27; +INTERVAL 50 minute,90),</span><br><span class="line">(null,1002,9002,&#x27;2021-09-04 07:01:02&#x27;,null,NULL);</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">insert into exam_record(uid, exam_id, start_time, submit_time, score)</span><br><span class="line">values </span><br><span class="line">(1001, 9001, &#x27;2021-09-01 22:11:12&#x27;, &#x27;2021-09-01 23:01:12&#x27;, 90),</span><br><span class="line">(1002, 9002, &#x27;2021-09-04 07:01:02&#x27;, null, null)</span><br></pre></td></tr></table></figure><h4 id="2-SQL2-插入记录（二）"><a href="#2-SQL2-插入记录（二）" class="headerlink" title="#2 SQL2 插入记录（二）"></a>#2 <strong>SQL2</strong> <strong>插入记录（二）</strong></h4><p>现有一张试卷作答记录表exam_record，结构如下表，其中包含多年来的用户作答试卷记录，由于数据越来越多，维护难度越来越大，需要对数据表内容做精简，历史数据做备份。</p><p>我们已经创建了一张新表exam_record_before_2021用来备份2021年之前的试题作答记录，结构和exam_record表一致，请将2021年之前的已完成了的试题作答纪录导入到该表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into exam_record_before_2021(uid, exam_id, start_time, submit_time, score) </span><br><span class="line">select uid, exam_id, start_time, submit_time, score from exam_record</span><br><span class="line">where year(start_time) &lt; 2021 and submit_time is not null</span><br></pre></td></tr></table></figure><h4 id="3-SQL3-插入记录（三）"><a href="#3-SQL3-插入记录（三）" class="headerlink" title="#3 SQL3 插入记录（三）"></a>#3 SQL3 插入记录（三）</h4><p>现在有一套ID为9003的高难度SQL试卷，时长为一个半小时，请你将 2021-01-01 00:00:00 作为发布时间插入到试题信息表examination_info（其表结构如下图），不管该ID试卷是否存在，都要插入成功，请尝试插入它。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用replace <span class="keyword">into</span> 而不是 <span class="keyword">insert</span> <span class="keyword">into</span>，因为无论存在与否，也可以先删除再插入</span><br><span class="line">replace <span class="keyword">into</span> examination_info(exam_id, tag, difficulty, duration, release_time)</span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">(<span class="number">9003</span>, <span class="string">&#x27;SQL&#x27;</span>, <span class="string">&#x27;hard&#x27;</span>,<span class="number">90</span> ,<span class="string">&#x27;2021-01-01 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="4-SQL4-更新记录（一）"><a href="#4-SQL4-更新记录（一）" class="headerlink" title="#4 SQL4 更新记录（一）"></a>#4 <strong>SQL4</strong> <strong>更新记录（一）</strong></h4><p>请把examination_info表中tag为PYTHON的tag字段全部修改为Python。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update examination_info</span><br><span class="line"><span class="keyword">set</span> tag <span class="operator">=</span> <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="keyword">where</span> tag <span class="operator">=</span> <span class="string">&#x27;PYTHON&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="5-SQL5-更新记录（二）"><a href="#5-SQL5-更新记录（二）" class="headerlink" title="#5 SQL5 更新记录（二）"></a>#5 <strong>SQL5</strong> <strong>更新记录（二）</strong></h4><p>请把exam_record表中2021年9月1日之前开始作答的未完成记录全部改为被动完成，即：将完成时间改为’2099-01-01 00:00:00’，分数改为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update exam_record </span><br><span class="line">set score = 0 ,</span><br><span class="line"># 条件语句里才有and，其他并列成分用，分隔</span><br><span class="line">    submit_time = &#x27;2099-01-01 00:00:00&#x27;</span><br><span class="line">where start_time &lt; &#x27;2021-09-01 00:00:00&#x27; and submit_time is null</span><br></pre></td></tr></table></figure><h4 id="6-SQL6-删除记录（一）"><a href="#6-SQL6-删除记录（一）" class="headerlink" title="#6 SQL6 删除记录（一）"></a>#6 <strong>SQL6</strong> <strong>删除记录（一）</strong></h4><p>请删除exam_record表中作答时间小于5分钟整且分数不及格（及格线为60分）的记录；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from exam_record </span><br><span class="line">where  timestampdiff(minute, start_time, submit_time) &lt; 5 and score &lt; 60</span><br></pre></td></tr></table></figure><h4 id="7-SQL7-删除记录（二）"><a href="#7-SQL7-删除记录（二）" class="headerlink" title="#7 SQL7 删除记录（二）"></a>#7 <strong>SQL7</strong> <strong>删除记录（二）</strong></h4><p>请删除exam_record表中未完成作答或作答时间小于5分钟整的记录中，开始作答时间最早的3条记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete from exam_record</span><br><span class="line">where timestampdiff(minute, start_time, submit_time) &lt; 5 or submit_time is NULL</span><br><span class="line">order by start_time</span><br><span class="line">limit 3</span><br></pre></td></tr></table></figure><h4 id="8-SQL8-删除记录（三）"><a href="#8-SQL8-删除记录（三）" class="headerlink" title="#8 SQL8 删除记录（三）"></a>#8 <strong>SQL8</strong> <strong>删除记录（三）</strong></h4><p>请删除exam_record表中所有记录，并重置自增主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#truncate table 在功能上，与不带where字句的delete语句相同；二者均删除表中的全部行，但truncate table 比delete速度更快，且#使用的系统和事务日志资源少。 truncate 删除表中的所有行，但表的结构及其列，约束，索引等保持不变。新行标识所用的计数值重置为该列</span><br><span class="line">#的种子。如果想保留标识计数值，请使用delete 。如果要删除表定义及其数据，请使用drop table 语句。</span><br><span class="line">truncate table exam_record</span><br></pre></td></tr></table></figure><h4 id="9-SQL9-创建一张新表"><a href="#9-SQL9-创建一张新表" class="headerlink" title="#9 SQL9 创建一张新表"></a>#9 <strong>SQL9</strong> <strong>创建一张新表</strong></h4><p>请<strong>创建一张优质用户信息表user_info_vip</strong>，表结构和用户信息表一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 注意default charset，default值，not null unique</span><br><span class="line">create table user_info_vip(</span><br><span class="line">    id int(11) primary key auto_increment comment &#x27;自增ID&#x27;,</span><br><span class="line">    uid int(11) not null unique comment &#x27;用户ID&#x27;,</span><br><span class="line">    nick_name varchar(64) comment &#x27;昵称&#x27;,</span><br><span class="line">    achievement int(11) default 0 comment &#x27;成就值&#x27;,</span><br><span class="line">    level int(11) comment &#x27;用户等级&#x27;,</span><br><span class="line">    job varchar(32) comment &#x27;职业方向&#x27;,</span><br><span class="line">    register_time datetime default current_timestamp comment &#x27;注册时间&#x27;</span><br><span class="line">)default charset = utf8</span><br></pre></td></tr></table></figure><h4 id="10-SQL10-修改表"><a href="#10-SQL10-修改表" class="headerlink" title="#10 SQL10 修改表"></a>#10 <strong>SQL10</strong> <strong>修改表</strong></h4><p>请在用户信息表，字段level的后面增加一列最多可保存15个汉字的字段school；并将表中job列名改为profession，achievement的默认值设置为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table user_info add school varchar(15) after level;</span><br><span class="line">alter table user_info change job profession varchar(10);</span><br><span class="line">alter table user_info modify achievement int(11) default 0;</span><br></pre></td></tr></table></figure><h4 id="11-SQL11-删除表"><a href="#11-SQL11-删除表" class="headerlink" title="#11 SQL11 删除表"></a>#11 <strong>SQL11</strong> <strong>删除表</strong></h4><p>现在随着数据越来越多，存储告急，请你把很久前的（2011到2014年）备份表都删掉（如果存在的话）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists exam_record_2011,</span><br><span class="line">                     exam_record_2012,</span><br><span class="line">                     exam_record_2013,</span><br><span class="line">                     exam_record_2014</span><br></pre></td></tr></table></figure><h4 id="12-SQL12-创建索引"><a href="#12-SQL12-创建索引" class="headerlink" title="#12 SQL12 创建索引"></a>#12 <strong>SQL12</strong> <strong>创建索引</strong></h4><p>现有一张试卷信息表examination_info，其中包含各种类型试卷的信息。为了对表更方便快捷地查询，需要在examination_info表创建以下索引，规则如下：</p><p>在duration列创建普通索引idx_duration、在exam_id列创建唯一性索引uniq_idx_exam_id、在tag列创建全文索引full_idx_tag。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create index idx_duration </span><br><span class="line">    on examination_info (duration);</span><br><span class="line">create unique index uniq_idx_exam_id </span><br><span class="line">    on examination_info (exam_id);</span><br><span class="line">create fulltext index full_idx_tag </span><br><span class="line">    on examination_info (tag);</span><br><span class="line">    </span><br><span class="line"># 也可以用alter修改表格</span><br><span class="line">alter table examination_info add index idx_duration(duration);</span><br><span class="line">alter table examination_info add unique index uniq_idx_exam_id(exam_id); </span><br><span class="line">alter table examination_info add fulltext index full_idx_tag(tag);</span><br></pre></td></tr></table></figure><h4 id="13-SQL13-删除索引"><a href="#13-SQL13-删除索引" class="headerlink" title="#13 SQL13 删除索引"></a>#13 <strong>SQL13</strong> <strong>删除索引</strong></h4><p>请删除examination_info表上的唯一索引uniq_idx_exam_id和全文索引full_idx_tag。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drop index uniq_idx_exam_id on examination_info;</span><br><span class="line">drop index full_idx_tag on examination_info;</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">alter table examination_info  drop  index uniq_idx_exam_id;</span><br><span class="line">alter table examination_info drop  index full_idx_tag;</span><br></pre></td></tr></table></figure><h4 id="14-SQL14-SQL类别高难度试卷得分的截断平均值"><a href="#14-SQL14-SQL类别高难度试卷得分的截断平均值" class="headerlink" title="#14 SQL14 SQL类别高难度试卷得分的截断平均值"></a>#14 <strong>SQL14</strong> <strong>SQL类别高难度试卷得分的截断平均值</strong></h4><p>牛客的运营同学想要查看大家在SQL类别中高难度试卷的得分情况。</p><p>请你帮她从exam_record数据表中计算所有用户完成SQL类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。保留一位小数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select ei.tag, ei.difficulty, round((sum(er.score) - max(er.score) - min(er.score))/(count(er.score)-2), 1)</span><br><span class="line">from </span><br><span class="line">examination_info ei join exam_record er</span><br><span class="line">on ei.exam_id = er.exam_id</span><br><span class="line">where </span><br><span class="line">ei.tag = &#x27;SQL&#x27; and ei.difficulty = &#x27;hard&#x27; and er.score is not null</span><br></pre></td></tr></table></figure><h4 id="15-SQL15-统计作答次数"><a href="#15-SQL15-统计作答次数" class="headerlink" title="#15 SQL15 统计作答次数"></a>#15 <strong>SQL15</strong> <strong>统计作答次数</strong></h4><p>有一个试卷作答记录表exam_record，请从中统计出总作答次数total_pv、试卷已完成作答数complete_pv、已完成的试卷数complete_exam_cnt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">count(id) total_pv, </span><br><span class="line">count(score) complete_pv, </span><br><span class="line"># 可以添加条件语句，用and连接</span><br><span class="line">count(distinct exam_id and score is not null) complete_exam_cnt</span><br><span class="line">from exam_record</span><br></pre></td></tr></table></figure><h4 id="16-SQL16-得分不小于平均分的最低分"><a href="#16-SQL16-得分不小于平均分的最低分" class="headerlink" title="#16 SQL16 得分不小于平均分的最低分"></a>#16 <strong>SQL16</strong> <strong>得分不小于平均分的最低分</strong></h4><p>请从试卷作答记录表中找到SQL试卷得分不小于该类试卷平均得分的用户最低得分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select min(er.score) min_score_over_avg</span><br><span class="line">from </span><br><span class="line">exam_record er join examination_info ei on er.exam_id = ei.exam_id</span><br><span class="line">where ei.tag = &#x27;SQL&#x27; and er.score &gt;= </span><br><span class="line">(</span><br><span class="line">select avg(score) from </span><br><span class="line">exam_record a join examination_info b on a.exam_id = b.exam_id</span><br><span class="line">where b.tag = &#x27;SQL&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="17-SQL17-平均活跃天数和月活人数"><a href="#17-SQL17-平均活跃天数和月活人数" class="headerlink" title="#17 SQL17 平均活跃天数和月活人数"></a>#17 <strong>SQL17</strong> <strong>平均活跃天数和月活人数</strong></h4><p>请计算2021年每个月里试卷作答区用户平均月活跃天数avg_active_days和月度活跃人数mau</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 注意，%Y是2021，%y是21， %M是July, %m是07, date_format可以按需求提取时间</span><br><span class="line">select  date_format(start_time, &#x27;%Y%m&#x27;) month,</span><br><span class="line"># count(a,b)按照两个参数都不同的进行统计数量，不要忘了distinct</span><br><span class="line">round(count(distinct uid, date_format(start_time, &#x27;%Y%m%d&#x27;))/count(distinct uid), 2) avg_active_days, </span><br><span class="line">count(distinct uid) mau</span><br><span class="line">from exam_record</span><br><span class="line">where </span><br><span class="line">submit_time is not null</span><br><span class="line">and year(submit_time) = 2021 </span><br><span class="line"># group by不要和order by弄混了</span><br><span class="line">group by date_format(start_time, &#x27;%Y%m&#x27;)</span><br></pre></td></tr></table></figure><h4 id="18-SQL18-月总刷题数和日均刷题数"><a href="#18-SQL18-月总刷题数和日均刷题数" class="headerlink" title="#18 SQL18 月总刷题数和日均刷题数"></a>#18 <strong>SQL18</strong> <strong>月总刷题数和日均刷题数</strong></h4><p>请从中统计出2021年每个月里用户的月总刷题数month_q_cnt 和日均刷题数avg_day_q_cnt，以及该年的总体情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select  coalesce(DATE_FORMAT(submit_time, &#x27;%Y%m&#x27;), &quot;2021汇总&quot;)  submit_month,</span><br><span class="line">count(score) month_q_cnt, </span><br><span class="line">round(count(score)/max(day(last_day(submit_time))), 3)  avg_day_q_cnt</span><br><span class="line">from practice_record </span><br><span class="line">where year(submit_time) = 2021</span><br><span class="line">group by DATE_FORMAT(submit_time, &#x27;%Y%m&#x27;)</span><br><span class="line">with rollup</span><br></pre></td></tr></table></figure><h4 id="19-SQL19-未完成试卷数大于1的有效用户"><a href="#19-SQL19-未完成试卷数大于1的有效用户" class="headerlink" title="#19 SQL19 未完成试卷数大于1的有效用户"></a>#19 <strong>SQL19</strong> <strong>未完成试卷数大于1的有效用户</strong></h4><p>请统计2021年每个未完成试卷作答数大于1的有效用户的数据（有效用户指完成试卷作答数至少为1且未完成数小于5），输出用户ID、未完成试卷作答数、完成试卷作答数、作答过的试卷tag集合，按未完成试卷数量由多到少排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select uid,</span><br><span class="line">       count(if(submit_time is null,1,null)) as incomplete_cnt,</span><br><span class="line">       count(if(submit_time is not null,1,null)) as complete_cnt,</span><br><span class="line">       group_concat(distinct concat_ws(&#x27;:&#x27;,date(start_time),tag) separator &#x27;;&#x27;) as detail</span><br><span class="line">from exam_record a</span><br><span class="line">left join examination_info b</span><br><span class="line">on a.exam_id=b.exam_id</span><br><span class="line">where year(start_time)=2021</span><br><span class="line">group by uid</span><br><span class="line">having  (count(if(submit_time is null,1,null)) between 2 and 4)</span><br><span class="line">and (count(if(submit_time is not null,1,null)) &gt;= 1)</span><br><span class="line">order by incomplete_cnt desc;</span><br></pre></td></tr></table></figure><h4 id="20-SQL20-月均完成试卷数不小于3的用户爱作答的类别"><a href="#20-SQL20-月均完成试卷数不小于3的用户爱作答的类别" class="headerlink" title="#20 SQL20 月均完成试卷数不小于3的用户爱作答的类别"></a>#20 <strong>SQL20</strong> <strong>月均完成试卷数不小于3的用户爱作答的类别</strong></h4><p>请从表中统计出 月均完成试卷数不小于3的用户爱作答的类别及作答次数，按次数降序输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">tag, </span><br><span class="line">count(tag) tag_cnt</span><br><span class="line">from </span><br><span class="line">exam_record er join examination_info ei</span><br><span class="line">on er.exam_id = ei.exam_id</span><br><span class="line">where uid in </span><br><span class="line">(</span><br><span class="line">select uid from exam_record </span><br><span class="line">    where submit_time is not null</span><br><span class="line">    group by uid</span><br><span class="line">    having count(*)/count(distinct date_format(start_time, &#x27;%Y%m&#x27;)) &gt;= 3</span><br><span class="line">)</span><br><span class="line">group by tag </span><br><span class="line">order by tag_cnt desc </span><br></pre></td></tr></table></figure><h4 id="21-SQL21-试卷发布当天作答人数和平均分"><a href="#21-SQL21-试卷发布当天作答人数和平均分" class="headerlink" title="#21 SQL21 试卷发布当天作答人数和平均分"></a>#21 <strong>SQL21</strong> <strong>试卷发布当天作答人数和平均分</strong></h4><p>请计算每张SQL类别试卷发布后，当天5级以上的用户作答的人数uv和平均分avg_score，按人数降序，相同人数的按平均分升序，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select er.exam_id, </span><br><span class="line">count(distinct er.uid) uv, </span><br><span class="line">round(avg(er.score), 1) avg_score</span><br><span class="line">from examination_info ei join exam_record er </span><br><span class="line">on ei.exam_id = er.exam_id</span><br><span class="line">where er.uid in </span><br><span class="line">(</span><br><span class="line">select uid from user_info </span><br><span class="line">    where level &gt; 5</span><br><span class="line">) and ei.tag = &#x27;SQL&#x27;</span><br><span class="line">and DATE_FORMAT(ei.release_time, &#x27;%Y%m%d&#x27;) = DATE_FORMAT(er.submit_time, &#x27;%Y%m%d&#x27;)</span><br><span class="line"># group by即分组，之后的count等聚集操作在每组内进行，即每个</span><br><span class="line">group by er.exam_id</span><br><span class="line">order by uv desc, avg_score</span><br></pre></td></tr></table></figure><h4 id="22-SQL22-作答试卷得分大于过80的人的用户等级分布"><a href="#22-SQL22-作答试卷得分大于过80的人的用户等级分布" class="headerlink" title="#22 SQL22 作答试卷得分大于过80的人的用户等级分布"></a>#22 <strong>SQL22</strong> <strong>作答试卷得分大于过80的人的用户等级分布</strong></h4><p>统计作答SQL类别的试卷得分大于过80的人的用户等级分布，按数量降序排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select u_i.level, </span><br><span class="line">count(distinct u_i.uid )  level_cnt  </span><br><span class="line">from exam_record e_r join examination_info e_i </span><br><span class="line">on e_r.exam_id = e_i.exam_id </span><br><span class="line">join user_info u_i </span><br><span class="line">on e_r.uid = u_i.uid </span><br><span class="line">where e_i.tag = &#x27;SQL&#x27; </span><br><span class="line">and score &gt; 80 </span><br><span class="line">group by level </span><br><span class="line">order by level_cnt desc, level desc</span><br></pre></td></tr></table></figure><h4 id="23-SQL23-每个题目和每份试卷被作答的人数和次数"><a href="#23-SQL23-每个题目和每份试卷被作答的人数和次数" class="headerlink" title="#23 SQL23 每个题目和每份试卷被作答的人数和次数"></a>#23 SQL23 每个题目和每份试卷被作答的人数和次数</h4><p>请统计每个题目和每份试卷被作答的人数和次数，分别在试卷区和题目区按uv &amp; pv降序显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select * from</span><br><span class="line">(select exam_id as tid,</span><br><span class="line">       count(distinct uid) as uv,</span><br><span class="line">       count(*) as pv</span><br><span class="line">from exam_record</span><br><span class="line">group by exam_id</span><br><span class="line">order by uv desc, pv desc) exam</span><br><span class="line">union</span><br><span class="line">select * from</span><br><span class="line">(select question_id as tid,</span><br><span class="line">       count(distinct uid) as uv,</span><br><span class="line">       count(*) as pv</span><br><span class="line">from practice_record</span><br><span class="line">group by question_id</span><br><span class="line">order by uv desc, pv desc) practice</span><br></pre></td></tr></table></figure><h4 id="24-SQL24-分别满足两个活动的人"><a href="#24-SQL24-分别满足两个活动的人" class="headerlink" title="#24 SQL24 分别满足两个活动的人"></a>#24 <strong>SQL24</strong> <strong>分别满足两个活动的人</strong></h4><p>为了促进更多用户在牛客平台学习和刷题进步，我们会经常给一些既活跃又表现不错的用户发放福利。假使以前我们有两拨运营活动，分别给每次试卷得分都能到85分的人（activity1）、至少有一次用了一半时间就完成高难度试卷且分数大于80的人（activity2）发了福利券。</p><p>现在，需要你一次性将这两个活动满足的人筛选出来，交给运营同学。请写出一个SQL实现：输出2021年里，所有每次试卷得分都能到85分的人以及至少有一次用了一半时间就完成高难度试卷且分数大于80的人的id和活动号，按用户ID排序输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL专题&quot;&gt;&lt;a href=&quot;#SQL专题&quot; class=&quot;headerlink&quot; title=&quot;SQL专题&quot;&gt;&lt;/a&gt;SQL专题&lt;/h2&gt;&lt;h4 id=&quot;1-SQL1-插入记录（一）&quot;&gt;&lt;a href=&quot;#1-SQL1-插入记录（一）&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="DataBase" scheme="https://zhengluoliudao.github.io/tags/DataBase/"/>
    
    <category term="SQL" scheme="https://zhengluoliudao.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>linux命令</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/linux%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/linux%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-02T09:46:55.000Z</published>
    <updated>2022-01-02T09:47:52.011Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>全称list，默认列出当前目录，所以可以列出其他目录或者路径下的文件信息或者目录信息。</p><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>Print Working Directory, 打印当前工作目录的完整路径名</p><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>change file timestamps，将每个文件的访问和修改时间更新为当前时间。除非提供-c或-h，否则将不存在的FILE参数创建为空。</p><h4 id="cat-amp-tac"><a href="#cat-amp-tac" class="headerlink" title="cat&amp;tac"></a>cat&amp;tac</h4><p>将FILE或标准输入连接到标准输出。</p><p>tac命令与cat命令展示内容相反（tac从最后一行输出到第一行），不能带行号输出</p><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>如果目录不存在，则创建目录</p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>Change Directory，切换当前目录至指定目录</p><h4 id="rm-amp-rmdir"><a href="#rm-amp-rmdir" class="headerlink" title="rm&amp;rmdir"></a>rm&amp;rmdir</h4><p>Remove Directory，rm -rf /</p><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>移动目录或者文件到指定目录下，同时具有重命名的功能。</p><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>copy，将source_file的内容复制到target_file</p><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>将任何指定的操作数打印到标准输出（就是print）</p><h4 id="head-amp-tail"><a href="#head-amp-tail" class="headerlink" title="head&amp;tail"></a>head&amp;tail</h4><p>显示每个指定文件或标准输入（如果未指定文件）的前几行或字节</p><h4 id="more-amp-less"><a href="#more-amp-less" class="headerlink" title="more&amp;less"></a>more&amp;less</h4><p>more流式读取文件内容</p><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看日志常用more/less，也常用head/tail</span><br></pre></td></tr></table></figure><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>统计文件中包含的行数，字数和字节数</p><h4 id="date-amp-cal"><a href="#date-amp-cal" class="headerlink" title="date &amp; cal"></a>date &amp; cal</h4><p>date根据指定的选项，打印日期和时间。</p><p>cal命令可以用来显示公历（阳历）日历</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>搜索某个系统命令的位置，查看该命令所在的文件位置</p><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>只能用于程序名的搜索，搜索文件名中包含该字符串的文件</p><h4 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h4><p>将输出的文件内容自动的加上行号（对行号的显示设计比 cat -n丰富）</p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>查看进程有关信息，ps -ef | grep</p><h4 id="kill-amp-killall"><a href="#kill-amp-killall" class="headerlink" title="kill&amp;killall"></a>kill&amp;killall</h4><p> kill -9 pid 表示强制杀死该进程，kill -15更优雅，给了进程善后的机会</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find  /Users  -name  “*.log”  -print       查找/user目录下所有以.log结尾的文件</p><p>find /home/midou/logs// -mtime +30 -name “*.log.gz” -exec rm -rf {} ;         删除一个月之前的日志</p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>搜索任何给定的输入文件，选择一个或多个与模式匹配的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$grep &#x27;20:[1-5][0-9]:&#x27; *.log  #匹配当前目录下搜索log日志中，20点的日志</span><br><span class="line">$grep &#x27;20:[1-5][0-9]&#x27; 1.log 2.log 3.log  #指定在这三个文件中查找</span><br><span class="line">#grep规则是支持正则表达式的</span><br><span class="line">$ps -ef|grep java    #查找所有java进程</span><br><span class="line">$grep &#x27;20:[1-5][0-9]:&#x27; *.log | grep -v &#x27;20:[3-4][0-9]:&#x27;   # -v反向选择，相当于过滤</span><br><span class="line">$grep &#x27;ab|bc&#x27; *.log  #支持|语法，匹配含有ab或者bc的文本行</span><br></pre></td></tr></table></figure><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>序从每个文件中剪切出每行的选定部分打印输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$cut -c-10 tmp.txt  #cut tmp.txt文件的前10列</span><br><span class="line">$cut -c3-5 tmp.txt  #cut tmp.txt文件的第3到5列</span><br><span class="line">$cut -c3- tmp.txt  #cut tmp.txt文件的第3到结尾列</span><br></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>比较两个文件的不同</p><p>diff testA.txt testB.txt</p><h4 id="tar-amp-gzip"><a href="#tar-amp-gzip" class="headerlink" title="tar&amp;gzip"></a>tar&amp;gzip</h4><p>用来压缩和解压文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#打包  tar -cvf 包名  文件名</span><br><span class="line">$tar -cvf test.tar test.txt </span><br><span class="line">#解包  tar -xvf 包名 </span><br><span class="line">$tar -xvf test.tar</span><br><span class="line">#压缩  tar -czvf 包名 文件名</span><br><span class="line">$tar -czvf test.tgz test.txt</span><br><span class="line">#解压  tar -xzvf 包名</span><br><span class="line">$tar -xzvf test.tgz</span><br></pre></td></tr></table></figure><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>显示指定文件使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#查看指定文件大小</span><br><span class="line">$du -h filename</span><br><span class="line">#展示该目录下所有文件大小，大小以可读方式展示</span><br><span class="line">$du  -h /</span><br><span class="line">#展示当前目录大小</span><br><span class="line">$du -sh</span><br><span class="line">#展示当前目录下每个目录大小</span><br><span class="line">$du -sh ./</span><br><span class="line">#显示所有文件的大小，以可读方式展示</span><br><span class="line">$du -ah /</span><br></pre></td></tr></table></figure><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>展示磁盘使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#展示当前系统磁盘使用情况，以可读的方式展示</span><br><span class="line">$ df -h</span><br><span class="line">Filesystem      Size   Used  Avail Capacity iused               ifree %iused  Mounted on</span><br><span class="line">/dev/disk1s1   234Gi   78Gi  151Gi    35% 1376436 9223372036853399371    0%   /</span><br><span class="line">devfs          208Ki  208Ki    0Bi   100%     720                   0  100%   /dev</span><br><span class="line">/dev/disk1s4   234Gi  4.0Gi  151Gi     3%       4 9223372036854775803    0%   /private/var/vm</span><br><span class="line">map -hosts       0Bi    0Bi    0Bi   100%       0                   0  100%   /net</span><br><span class="line">map auto_home    0Bi    0Bi    0Bi   100%       0                   0  100%   /home</span><br><span class="line">/dev/disk3s1   290Mi  271Mi   17Mi    94%    2156 9223372036854773651    0%   /Volumes/Sourcetrail_2019_4_102</span><br></pre></td></tr></table></figure><h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><p>列出当前系统打开文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#显示当前系统打开的文件</span><br><span class="line">$lsof  </span><br><span class="line">#查看某个文件的相关进程  lsof 文件名</span><br><span class="line">$ lsof /bin/bash</span><br><span class="line">COMMAND  PID  USER  FD   TYPE DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">bash    9430 midou txt    REG  253,1   960392 140072 /usr/bin/bash</span><br><span class="line">#查看某个用户打开的文件信息</span><br><span class="line">$lsof -u username</span><br><span class="line">#列出某个程序进程所打开的文件信息</span><br></pre></td></tr></table></figure><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>向主机发送报文，常用于测试本机与其他机器之间的网络通信</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#显示当前系统打开的文件</span><br><span class="line">$lsof  </span><br><span class="line">#查看某个文件的相关进程  lsof 文件名</span><br><span class="line">$ lsof /bin/bash</span><br><span class="line">COMMAND  PID  USER  FD   TYPE DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">bash    9430 midou txt    REG  253,1   960392 140072 /usr/bin/bash</span><br><span class="line">#查看某个用户打开的文件信息</span><br><span class="line">$lsof -u username</span><br><span class="line">#列出某个程序进程所打开的文件信息</span><br></pre></td></tr></table></figure><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>显示与端口连接相关的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#列出所有端口使用情况</span><br><span class="line">$netstat -a</span><br><span class="line">#显示当前UDP连接状况</span><br><span class="line">$netstat -nu</span><br><span class="line">#显示UDP端口号的使用情况</span><br><span class="line">$netstat -apu</span><br><span class="line">#显示网卡列表</span><br><span class="line">$netstat -i</span><br><span class="line">#显示网络统计信息</span><br><span class="line">$netstat -s</span><br><span class="line">#显示监听的套接口</span><br><span class="line">$netstat -l</span><br><span class="line">#显示所有已建立的有效连接</span><br><span class="line">$netstat -n</span><br><span class="line">#显示关于路由表的信息</span><br><span class="line">$netstat -r</span><br><span class="line">#列出所有 tcp 端口</span><br><span class="line">$netstat -at</span><br><span class="line">#找出程序运行的端口</span><br><span class="line">$netstat -ap | grep ssh</span><br><span class="line">#在 netstat 输出中显示 PID 和进程名称</span><br><span class="line">$netstat -pt</span><br></pre></td></tr></table></figure><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>展示或配置网络设备信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#显示网络设备信息</span><br><span class="line">$ifconfig</span><br><span class="line">#启动关闭指定网卡</span><br><span class="line">$ifconfig eth0 up</span><br><span class="line">$ifconfig eth0 down</span><br><span class="line">#配置IP地址</span><br><span class="line">$ifconfig eth0 ip</span><br><span class="line">#启用和关闭ARP协议</span><br><span class="line">$ifconfig eth0 arp</span><br><span class="line">$ifconfig eth0 -arp</span><br><span class="line">#设置最大传输单元</span><br><span class="line">$ifconfig eth0 mtu 1500</span><br></pre></td></tr></table></figure><h4 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h4><p>查看主机ip，DNS等信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看主机ip,这个命令我最推荐的一个用法就是查看主机ip，之前我一直用ifconfig</span><br><span class="line">$hostname -i </span><br></pre></td></tr></table></figure><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><p>跟踪获取从IP网络到给定主机的路由信息包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#traceroute 一下百度，看下数据包的路由途径</span><br><span class="line">$ traceroute www.baidu.com</span><br><span class="line">traceroute: Warning: www.baidu.com has multiple addresses; using 183.232.231.172</span><br><span class="line">traceroute to www.baidu.com (183.232.231.172), 64 hops max, 52 byte packets</span><br><span class="line"> 1  192.168.0.1 (192.168.0.1)  6.059 ms  0.879 ms  0.843 ms</span><br><span class="line"> 2  192.168.1.1 (192.168.1.1)  1.305 ms  2.232 ms  2.167 ms</span><br><span class="line"> 3  10.104.0.1 (10.104.0.1)  5.085 ms  5.534 ms  4.466 ms</span><br><span class="line"> 4  221.131.253.13 (221.131.253.13)  4.633 ms  11.736 ms  4.199 ms</span><br><span class="line"> 5  117.148.181.1 (117.148.181.1)  4.544 ms *</span><br><span class="line">    112.11.233.49 (112.11.233.49)  13.384 ms</span><br><span class="line"> 6  221.183.47.165 (221.183.47.165)  6.591 ms  6.643 ms</span><br><span class="line">    221.183.47.161 (221.183.47.161)  5.591 ms</span><br></pre></td></tr></table></figure><h4 id="route"><a href="#route" class="headerlink" title="route"></a>route</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#显示当前路由</span><br><span class="line">$route</span><br><span class="line">#屏蔽一条路由</span><br><span class="line">$route add -net 224.0.0.0 netmask 240.0.0.0 reject</span><br><span class="line">#删除路由记录</span><br><span class="line">$route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">#删除和添加设置默认网关</span><br><span class="line">$route del default gw 192.168.0.100</span><br><span class="line">$route add default gw 192.168.0.100</span><br></pre></td></tr></table></figure><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>用于从Web非交互式下载文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#下载某个文件，wget 文件的地址</span><br><span class="line">$wget https://blog.csdn.net/qq_38646470</span><br></pre></td></tr></table></figure><h4 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h4><p>查看虚拟内存使用情况</p><p>报告有关进程，内存，页面调度，块IO，陷阱，磁盘和cpu活动的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#显示虚拟内存情况</span><br><span class="line">$ vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 23764228 507816 36953948    0    0     3     5    0    0  1  0 98  0  0</span><br></pre></td></tr></table></figure><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>查看内存使用情况</p><p>显示系统中可用和可用的物理内存和交换内存的总量，以及内核使用的缓冲区和高速缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#显示内存使用情况</span><br><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       65808884     4582700    23754736         684    37471448    60913052</span><br><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            62G        4.4G         22G        684K         35G         58G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">#周期性的查询内存使用信息，5s执行一次</span><br><span class="line">$ free -s 5</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>查看正在运行的系统的动态实时视图。</p><p>第一行，任务队列信息；第二行，Tasks — 任务（进程）；第三行，cpu状态信息；第四行,内存状态；第五行，swap交换分区信息；第七行以下：各进程（任务）的状态监控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#top</span><br><span class="line">$ top</span><br><span class="line">top - 00:56:07 up 149 days, 14:40,  1 user,  load average: 0.00, 0.02, 0.05</span><br><span class="line">Tasks: 254 total,   1 running, 253 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.4 us,  0.3 sy,  0.0 ni, 98.3 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : 65808884 total, 23749772 free,  4586160 used, 37472952 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 60909608 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">24397 dongshan  20   0 17.972g 688312  13728 S   6.2  1.0   7:09.11 java</span><br><span class="line">    1 root      20   0   42140   3684   1476 S   0.0  0.0  23:58.88 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:05.47 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 S   0.0  0.0   0:16.06 ksoftirqd/0</span><br><span class="line">    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">    7 root      rt   0       0      0      0 S   0.0  0.0   1:27.00 migration/0</span><br><span class="line">    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh</span><br><span class="line">    9 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/0</span><br></pre></td></tr></table></figure><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p>sar（System Activity Reporter系统活动情况报告）是目前 Linux 上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、 系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ls&quot;&gt;&lt;a href=&quot;#ls&quot; class=&quot;headerlink&quot; title=&quot;ls&quot;&gt;&lt;/a&gt;ls&lt;/h4&gt;&lt;p&gt;全称list，默认列出当前目录，所以可以列出其他目录或者路径下的文件信息或者目录信息。&lt;/p&gt;
&lt;h4 id=&quot;pwd&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="linux" scheme="https://zhengluoliudao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>秒杀项目</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-01-02T09:44:48.000Z</published>
    <updated>2022-01-02T09:46:28.257Z</updated>
    
    <content type="html"><![CDATA[<h4 id="秒杀项目"><a href="#秒杀项目" class="headerlink" title="秒杀项目"></a>秒杀项目</h4><p>问题：高并发，超卖，恶意请求，链接暴露，数据库</p><p>解决方案：服务单一职责（微服务+分布式+单独数据库），秒杀链接加盐(url动态化)，Redis集群（主从同步、读写分离），Nginx（多个Tomcat负载均衡），资源静态化，按钮控制（点击前后置灰），限流，库存预热（提前将库存加载到redis，lua脚本），限流&amp;降级&amp;熔断&amp;隔离，削峰填谷（消息队列）</p><p>隔壁数仓组打算搞flink的实时数仓，美团用的OLAP引擎是doris，可以投其所好学一学，语法跟MySQL一毛一样，原理不同罢了</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>基本数据类型：String、Hash、List、Set、SortedSet，HyperLogLog、Geo、Pub/Sub，BloomFilter，RedisSearch，Redis-ML</p><p>redis为什么快：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</span><br><span class="line">数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</span><br><span class="line">采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</span><br><span class="line">使用多路I/O复用模型，非阻塞IO；</span><br><span class="line">使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</span><br></pre></td></tr></table></figure><p>持久化：</p><pre><code>RDB：RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog。对比：RDB适合冷备，AOF适合热备，RDB对性能影响比AOF小，恢复快，但是数据完整性不如AOF</code></pre><p>高可用性：哨兵集群，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</span><br><span class="line">消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</span><br><span class="line">故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</span><br><span class="line">配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址</span><br></pre></td></tr></table></figure><p>主从同步：master生成RDB快照，发送给slave</p><p>过期策略：定期删除+惰性删除</p><p>内存淘汰机制： FIFO 淘汰最早数据、LRU 剔除最近最少使用、和 LFU 剔除最近使用频率最低的数据</p><p>对比MemCache和Redis：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redis 采用单线程模式处理请求，避免线程上下文切换产生的代价</span><br><span class="line">Redis 支持持久化</span><br><span class="line">除了 K-V 之外，还支持多种数据格式</span><br><span class="line">Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务</span><br></pre></td></tr></table></figure><p>缓存更新：失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。</p><p>缓存穿透：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对不存在的用户，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。</span><br><span class="line">使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。</span><br></pre></td></tr></table></figure><p>缓存击穿：缓存击穿，就是某个热点数据失效时，大量针对这个数据的请求会穿透到数据源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。</span><br><span class="line">使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。</span><br><span class="line">针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效</span><br></pre></td></tr></table></figure><p>缓存雪崩：产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用快速失败的熔断策略，减少 DB 瞬间压力；</span><br><span class="line">使用主从模式和集群模式来尽量保证缓存服务的高可用。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;秒杀项目&quot;&gt;&lt;a href=&quot;#秒杀项目&quot; class=&quot;headerlink&quot; title=&quot;秒杀项目&quot;&gt;&lt;/a&gt;秒杀项目&lt;/h4&gt;&lt;p&gt;问题：高并发，超卖，恶意请求，链接暴露，数据库&lt;/p&gt;
&lt;p&gt;解决方案：服务单一职责（微服务+分布式+单独数据库），秒杀链接</summary>
      
    
    
    
    
    <category term="项目" scheme="https://zhengluoliudao.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="秒杀" scheme="https://zhengluoliudao.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>腾讯面试</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2022-01-02T09:42:18.000Z</published>
    <updated>2022-01-02T09:44:05.224Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h4><ol><li><p>acid, 原子性 不可分割，一致性 前后一致，隔离性  不可见，持久性  一旦提交持久保存</p></li><li><p>tcp三次握手和四次挥手，为什么要四次挥手。   </p><p>三次握手：syn, syn+ack, ack        四次挥手：fin, ack, fin, ack</p><ol><li><p>三次握手才可以阻止历史重复连接的初始化（主要原因）。客户端需要根据syn+ack判断和服务器建立的是不是历史连接</p></li><li><p>三次握手才可以同步双方的初始序列号。同步序列号，客户端才知道下一次应该用哪个序列号</p></li><li><p>三次握手才可以避免资源浪费。服务器不知道客户端是否收到了ack，那么如果客户端发了多个syn，服务器就要建立多个连接，浪费资源</p><p>服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p></li></ol></li><li><p>进程与线程。进程就是一次把数据加载到内存，时间片切分导致多进程，即并发。</p><ol><li>并发是多个任务在一个处理器核上进行时间片分片；并行是多个处理器核同时运行多个任务</li><li>线程是进程当中的一条执行流程。线程之间可以并发运行且共享相同的地址空间</li><li>线程比进程不管是时间效率，还是空间效率都要高。线程创建快，终止快，切换快，数据传递快。线程是调度的基本单位，而进程则是资源拥有的基本单位。</li></ol></li><li><p>MySQL所有的锁</p><ol><li>s锁（共享锁）能读  x锁（互斥锁）能写  2PL  IS IX SIX 多粒度锁协议</li></ol></li><li><p>范式</p><ol><li>第一范式  属性不可分<br>第二范式    每个非主属性完全函数依赖于候选键<br>第三范式    每个非主属性不传递函数依赖于候选键<br>BCNF       任意主属性都完全函数依赖于候选键</li></ol></li><li><p>事务隔离级别。</p><ol><li><p>read uncommitted。可以看到未提交事务</p></li><li><p>read committed。只能看到已提交事务的改变，面对不可重复读的问题</p></li><li><p>可重复读。事务执行过程中会看到相同的行，mysql的默认隔离级别。面对幻读的问题，即新插入行仍能看到，MVCC解决</p><p>这个问题</p></li><li><p>可串行化。强制事务排序，使之不可能相互冲突，但是效率低</p></li></ol><p> 脏读，不可重复读，幻读</p></li><li><p>排序算法</p></li><li><p>http1.0和http1.1(https)和2.0的区别；</p></li><li><p>tcp和udp的区别；</p></li><li><p>HashMap怎样避免减少冲突</p></li><li><p>进程间通信：</p><p>消息传递：消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行通信；消息传递分为发送方和接收方</p><p>先进先出队列：先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式</p><p>管道：管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工，需要另外一个管道。</p><p>直接通信：在这种进程通信的方式中，进程与进程之间只存在一条链接，进程间要明确通信双方的命名。</p><p>间接通信：间接通信是通信双方不会直接建立连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中放置消息，并且可以从中删除消息，以此达到进程间通信的目的。</p><p>消息队列：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程之间提供全双工的通信连接。</p><p>共享内存：共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。</p></li><li><p>协程：协程运行在线程之上，在线程的基础之上通过分时复用的方式运行多个协程；协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。协程只有和异步IO结合起来才能发挥出最大的威力。</p></li><li><p>Redis：</p></li><li><p>MySQL引擎：innodb和myisam的区别：</p><ol><li><p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </p></li><li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </p></li><li><p>InnoDB是聚簇索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p><pre><code>MyISAM是非聚簇索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</code></pre><p> 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p></li><li><p>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</p></li></ol></li><li><p>linux定时执行脚本，crontab命令</p></li><li><p>消息队列：异步，削峰，解耦</p></li></ol><p>实战：</p><p>一面面试问到的：共享内存，B+树，平衡二叉树和二叉查找树，进程间通信，操作系统，互斥锁没拿到cpu是等着还是休眠，</p><p>把字符串倒过来，时间空间要求极低</p><p>总结：腾讯面试在把问题问细，深挖一个简单的问题，算法上要求简单问题时间空间复杂度降到最低，重视知识的应用场景，</p><p>二面面试问到的：</p><p>linux命令，定时执行，git指令fetch和pull的区别，协程，docker，go语言，前端JS，输入重定向，管道</p><p>三面问到的：</p><p>python装饰器，linux  free/vmstat top，异步IO，kafka，redis的内存回收机制，mysql一万条数据怎么查询，索引什么情况失效，case when</p><p>字节面试：</p><p>一面：共享内存，http遇到大量超时，智能指针</p><p>###########################################################################################</p><h4 id="三面面经收集"><a href="#三面面经收集" class="headerlink" title="三面面经收集"></a>三面面经收集</h4><h3 id="3-技术三面-9-26-30min"><a href="#3-技术三面-9-26-30min" class="headerlink" title="3.技术三面 9.26 30min"></a>3.技术三面 9.26 30min</h3><p> <a href="">腾讯</a>三面一般都是部门总监，问的问题一般都是项目、架构、设计之类的。 </p><p>  1.自我介绍 </p><p>  2.之前实习为什么没留用？ </p><p>  3.你怎么看待之前leader对你的评价呢？ </p><p>  4.你认为你在PCG实习的这个项目中，有哪些亮点和挑战？ </p><p>  5.你项目中的ES是直接拿来用的吗？（回答：不是）那你介绍下你做了哪些优化和配置的工作？ </p><p>  6.用什么语言？（答：golang）golang的协程介绍下？ </p><p>  7.介绍下PCG内部的那个…(我怕泄露机密，就不写出来了） </p><p>  8.反问 </p><p>二面：只面了30分钟，感觉面试官挺忙的</p><p> http1.0和2.0的区别；</p><p> tcp和udp的区别；</p><p> go中make和new的区别；</p><p> 进程、线程、协程</p><p> go的接口机制？</p><p> go通道是如何实现的；</p><p> 三面：三面印象中是最难的，上来就问我简历中提到了<a href="">区块链</a>，问我<a href="">区块链</a>是什么，然后抓住我做的一个项目问，问得比较细；</p><p> go协程是如何实现的。</p><p> 如何控制协程创建的数量？</p><p> 协程之间通信机制？</p><p> 项目中用到了几个通道，具体是如何使用的？</p><p> 你做的项目，并发量有多大。</p><p> 考虑你的项目出现了问题怎么办。</p><p> mysql的数据引擎？innodb和myisam的区别？</p><p> 如何保证mysql数据并发安全？</p><p> 项目部署在哪里？有没有上线？</p><p> linux熟悉吗？都熟悉哪些操作？如何查找一个指定名称的进程？</p><p> linux如何修改配置信息？</p><p> go 的垃圾回收机制？</p><p> 了解过哪些新出的云产品服务？答了个k8s</p><p> 用go还做过哪些其他项目？</p><p> go web开发的框架有哪些？</p><p> docker了解过吗？</p><p> 最近看的书？</p><p>二面 30 min:<br>全程聊项目，所以问题只记得几个</p><ol><li>项目中遇到过什么困难呢？是怎么解决的呢？</li><li>你是怎么去做算法调研的？你了解实际应用中用了哪些算法吗？</li><li>为什么要用python？用了哪些包呢？</li><li>讲一个项目里数据处理的流程吧。</li><li>为什么用clickhouse？你了解其他数据库吗？</li><li>用了解不了解分布式的一些东西，我就直接说了自己不了解也没有继续往下问</li></ol><p>2021.4.2 腾讯TEG一面</p><p>岗位被TEG-基础架构部捞成运营开发了</p><p>消息队列怎么保证消息不被重复消费，怎么保证顺序性</p><p>redis有哪些持久化的方式<br>redis在项目中起到哪些作用<br>介绍一下Redis分布式锁</p><p>了解过协程吗<br>什么是用户态，什么是内核态？为什么要这么设计？</p><p>说一下常用的http方法<br>那么有什么场景下，在尽量遵循RFC规范下，不得不用post去代替get？</p><p>手撕代码，ide屏幕共享：<br>有一个会议室，0-1000是一个固定的时间段，然后给出在这个时间段内的一些会议时间，表示这个时间段占用了这个会议室（那么显然给出的占用时间之间不会发生冲突）。现在给你一个会议开始时间，和会议时长。<br>如果这个时间段能开会，那么直接返回这个是开始时间；<br>如果这个时间段不能开会，那么不得不调整开始时间，返回需要付出最小调整代价的开始时间（也就是左边和右边最近的时间）；如果怎么调整也无法开会，返回-1</p><p>2021.4.9 腾讯TEG二面</p><p>介绍下项目，介绍下自己的技术栈</p><p>平常怎么学习的</p><p>redis过期key的删除策略<br>redis淘汰机制（或者操作系统中有哪些内存淘汰机制）<br>LRU是怎么实现的<br>redis中的k-v结构是怎么存的</p><p>消息队列怎么保证有序性和持久性</p><p>64位机器int类型是多少位？<br>Malloc函数会分配物理内存吗？那在什么时候才会分配？<br>了解内存泄露吗</p><p>什么时候会发生StackOverFlow</p><p>HashMap讲一下</p><p>手撕：字符串转整数，尽可能考虑边界条件</p><p>怎么自己生成Integer.MAX_VALUE</p><p>###########################################################################################</p><h4 id="二面面经收集"><a href="#二面面经收集" class="headerlink" title="二面面经收集"></a>二面面经收集</h4><p>1.自我介绍<br> 2.<a href="">算法题</a>：LIS的序列值求解<br>  没做出来，换了一题，lc209 长度最小的子数组<br> (以上就占了快四十分钟了，剩下就问了二十分钟不到，心里已经凉凉)<br> 3.Java线程池参数以及实现与缺陷<br> 4.HashMap怎样避免减少冲突<br> 5.整数作为Key要怎样设计最好<br> 6.如果单个桶的元素数量很大，Map要怎么设计来解决<br> 7.Hash桶很多但元素少，如何快速遍历<br> 8.原子操作的实现<br> 9.SpringBoot和Spring的区别<br> 10.了解go吗<br> 11.协程<br> 12.跳表<br> 13.数据库的分库分表方案<br> 14.联合索引与多个单列索引的区别<br> 15.Java RPC<br> 16.Linux Socket<br> 17.职业规划</p><p>简述项目 </p><p>  1、无锁队列，CAS </p><p>  2、http状态码？ </p><p>  3、断点续传用到什么状态码？ </p><p>  4、https原理？ </p><p>  5、为什么用epoll？ </p><p>  6、ET、LT模式区别？ </p><p>  7、多进程、多线程、多协程区别以及应用场景？ </p><p>  8、Nginx并发模型？ </p><p>  9、Redis并发模型？ </p><p>  10、Linux下查看一个进程有什么命令？ </p><p>  11、10亿qq号怎么做去重最高效？</p><p>和游戏有关的问题：</p><p>1、Steam里有多少款游戏？</p><p>2、问我觉得主机三大平台和Steam，以后哪个发展前景更好。</p><p>3、问我WeGame和Steam商店首页功能的区别，以及我觉得为什么会有这些区别。</p><p>4、Steam有什么可以改进的地方？</p><p>5、性格怎么样？</p><p>6、为什么想要做产品这个岗位？</p><p>7、除了产品之外还有什么想投的岗位。</p><p>8、城市接受调剂吗？</p><p>9、有什么兴趣爱好。</p><p>10、有什么问题要问他（他的预期似乎是问一些和求职有关的问题，但我问的是他觉得五年内有什么新的技术会改变互联网和互联网产品）</p><p>对原神的感受，谈对原神的了解，对比腾讯王者荣耀</p><ol><li>腾讯的游戏缺少很多细节，一些精彩的文案。比如说原神中有很多书籍，可以丰富世界观，每种材料都会有相应的描述，甚至故事，彼此串联，而例如王者里面，人物和皮肤都缺少文案以丰富内容。</li><li>用户反馈，基本上每个礼拜都会收到调查反馈，而且确实会根据玩家声音比较大的点进行改进</li><li>简单的界面，简单的操作。相比腾讯网易的游戏，游戏界面确实干净很多，非功能性的界面都不在主界面显示</li><li>游戏的自由度。最开始吸引我去玩的就是自由度，几乎可以做想做的一切，而这和王者峡谷那种低自由度的环境产生了鲜明对比；后期驱动我玩下去的是二创，尤其是B战丰富的二创确实是越来越精良，这形成了一种氛围</li><li>挖掘用户群体，宅男宅女。这些人的特质是，闷骚，不热衷社交，有点小H，愿意为喜欢的游戏氪金。可以说，原神正是为这个群体打造的，高自由度满足了小H的愿望，弱社交性弱联机性迎合了略带社恐的人，精良的画面和美术抓住眼球</li><li>音乐和美术。优秀的音乐团队，恰到好处的bgm确实有调动人心的能力；美丽的风景，社畜的心灵安慰</li><li></li></ol><p>大话：原神目前对腾讯的游戏构成了巨大威胁</p><p>新手引导：<br>简单点说，就是它不是通过大量文字引导你</p><p>而是通过巧妙设置地图，让你觉得应该怎么操作人物，然后记住这一模式</p><p>还有一个就是，不会一股脑把你需要掌握的灌输给你<br>而是先让你学会一个方法，然后给你几个怪物或者场景，去实践一下，来掌握这项方法<br>细节方面，可以说，玩家和怪物的交互做的很好<br>怪物的攻击对玩家有反馈，同时玩家的攻击也会让怪物的动作有反馈，不会出现双方各打各的，只是血条变化这种之类的</p><p>二面 30 min:<br> 全程聊项目，所以问题只记得几个<br> \1. 项目中遇到过什么困难呢？是怎么解决的呢？<br> \2. 你是怎么去做<a href="">算法</a>调研的？你了解实际应用中用了哪些<a href="">算法</a>吗？<br> \3. 为什么要用python？用了哪些包呢？<br> \4. 讲一个项目里数据处理的流程吧。<br> \5. 为什么用clickhouse？你了解其他数据库吗？<br> \6. 用了解不了解分布式的一些东西，我就直接说了自己不了解也没有继续往下问 </p><p> 一面（30min）<br> \1. 面试官先进行了自我介绍，主要工作介绍。然后讲了一下为什么捞我。问我对这个岗位的意见。<br> \2. Tcp和udp的区别；使用场景<br> \3. http和https，讲一下https是怎么连接的，知道对称加密和非对称加密吗？<br> \4. http是怎么保证可靠性的？讲一下滑动窗口。<br> \5. 三次握手过程，为什么握手三次而挥手要四次。<br> \6. 数据库了解吗？讲一下事务。<br> \7. 索引的底层实现，为什么用B+树。<br> \8. 了解<a href="">redis</a>吗？<br> \9. 进程和线程的区别<br> \10. 知道哪些锁？如何避免死锁？<br> 11.了解epoll吗<br> \12. 问了几个项目问题，大概是介绍自己的项目那些之类的，我记不清了。问一个项目的并发量是多少？<br> 13.场景题: 如何设计一个秒杀系统？<br> \14. 你觉得mysql可以支持百万级数据吗？如果可以的话要怎么做？<br> 大概是这些，如果我想起来其他的回来补充。 </p><p>HR面:<br>\1. 讲项目的详细流程，遇到了什么困难，怎么解决的<br>\2. 项目分工，如何进行沟通？有什么收获或者进行总结过吗？<br>\3. 如果工作中需要同事配合，但是这不是他的kpi怎么办<br>\4. 你是如何学习新技术的？<br>其他的我想起来再来补充……</p><p>一面：记不大清楚了</p><p> 先让自我介绍，然后问了我简历上的项目</p><p> 问了beego框架的一些特性</p><p> 项目中用到了hash函数，为什么用256而不是md5？</p><p> 写代码：括号匹配</p><p> 二面：只面了30分钟，感觉面试官挺忙的</p><p> http1.0和2.0的区别；</p><p> tcp和udp的区别；</p><p> go中make和new的区别；</p><p> 进程、线程、协程</p><p> go的接口机制？</p><p> go通道是如何实现的；</p><p> 三面：三面印象中是最难的，上来就问我简历中提到了<a href="">区块链</a>，问我<a href="">区块链</a>是什么，然后抓住我做的一个项目问，问得比较细；</p><p> go协程是如何实现的。</p><p> 如何控制协程创建的数量？</p><p> 协程之间通信机制？</p><p> 项目中用到了几个通道，具体是如何使用的？</p><p> 你做的项目，并发量有多大。</p><p> 考虑你的项目出现了问题怎么办。</p><p> mysql的数据引擎？innodb和myisam的区别？</p><p> 如何保证mysql数据并发安全？</p><p> 项目部署在哪里？有没有上线？</p><p> linux熟悉吗？都熟悉哪些操作？如何查找一个指定名称的进程？</p><p> linux如何修改配置信息？</p><p> go 的垃圾回收机制？</p><p> 了解过哪些新出的云产品服务？答了个k8s</p><p> 用go还做过哪些其他项目？</p><p> go web开发的框架有哪些？</p><p> docker了解过吗？</p><p> 最近看的书？</p><p>###########################################################################################</p><h4 id="一面面经收集"><a href="#一面面经收集" class="headerlink" title="一面面经收集"></a>一面面经收集</h4><p>一上来就写题，问了一个第一个<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95%E9%A2%98">算法题</a>：<br>1.给一个长度为偶数n的序列中，前n/2个元素里面的最大值小于等于后n/2个元素里的最小值，称为“几乎有序”，可以对序列交换任意多次，两个不同的需要i,j交换每次的代价是i-j的绝对值。求将给定序列，转化为几乎有序序列的最小代价。<br>嗯不太会。面试官提醒了一下，说求中位数然后比较。类似快排<br>嗯写了10分钟没写出来。面试官说换一个吧那<br>2。<br>Ri：代表第i行的和<br>Ci：代表第i列的和<br>Zi：代表主对角线的和<br>Fi：代表副对角线的和<br>给一个n*n的矩阵，允许交换两个数的位置，返回上述4个参数和的最大值。<br>嗯，还是不太会。面试官：你本科软件工程的这么基础的题都不会？</p><p>我：嗯这题比我想象中的基础多了。</p><p>面试官：你有什么要问我的么？</p><p>然后。。。没有然后了</p><p>1.自我介绍 </p><p>  2.问项目 </p><p>  3.为什么使用<a href="">redis</a> </p><p>  4.nacos的作用 </p><p>  5.cap理论 </p><p>  6.tcp三次握手和四次挥手 </p><p>  7.为什么要四次挥手 </p><p>  8.有大量的time-wait怎么办 </p><p>  9.java的hashmap所用数据结构 </p><p>  10.MySQL事务隔离级别 </p><p>  11.MySQL所有的锁 </p><p>  12.MySQL下的MVCC </p><p>  13.反问</p><p>1、TCP三次握手流程？为什么需要第三次？去掉第三次会怎么样？ </p><p>  2、TCP如何处理丢包？TCP如何处理重传？拥塞控制？ </p><p>  3、用过哪些加密<a href="">算法</a>？介绍加密<a href="">算法</a>及其区别？ </p><p>  4、如果客户端反馈了一个错误如何排查服务器代码？如果没有任何输出、但就是有问题，如何排查？ </p><p>  5、你常用的linux命令是什么？怎么在linux里找到你在运行的tomcat？ </p><p>  6、mysql索引原理？悲观锁乐观锁？如果查询慢怎么解决？ </p><p>  7、用过缓存吗？知道哪些缓存？ </p><p>  8、堆和栈的区别？java函数调用的具体过程，在堆栈中的过程？ </p><p>  9、<a href="">区块链</a>底层原理？（项目相关） </p><p>  10、手撕代码…… </p><p>  输入一个n，为结点总数；输入一个二维数组，表示结点的连接关系。可以以任意一个为根节点，请输出使得树深度最小的根节点。 </p><p>  先问了有哪些思路，提了两个，错了一个，讨论了一下为什么错，然后让按照第一个思路写……没撕出来……………… </p><p>  11、反问（想着八成凉了，反手质问面试官，为啥问这么多跟java不太相关的（自杀式行为.jpg）他说因为平常要用）</p><p>8.进程线程区别，以及多进程多线程的使用场景  </p><p>   9.mysql主从复制以及好处、工作原理和机制  </p><p>   10.mysql引擎，索引数据结构，为什么用b+树不用别的  </p><p>   11.最近在看哪方面的书，你给我讲讲  </p><p>   12.写2道<a href="">算法题</a>  </p><p>   第一道：  </p><p>   汉明距离  </p><p>   第二道：  </p><p>   单词倒序并且大小写互反：例如：”heLlo WolRd” 转化为 “HElLO wOLrD”  </p><p>   13.反问</p><p>\1. 自我介绍 </p><p>  \2. 6道<a href="">算法题</a>，要求半小时完成 </p><p>  1）26 进制题<br>  2）<a href="">二叉树</a>的第三大<br>  3）有序<a href="">链表</a>公共结点<br>  4）青蛙<a href="">跳台阶</a><br> 5）最长递增序列<br> \6. 进程线程区别<br> \7. 线程锁有哪些<br> \8. 线程锁的优缺点<br> \9. 如何改进线程锁的缺点<br> \10. 问项目</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;问题汇总&quot;&gt;&lt;a href=&quot;#问题汇总&quot; class=&quot;headerlink&quot; title=&quot;问题汇总&quot;&gt;&lt;/a&gt;问题汇总&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;acid, 原子性 不可分割，一致性 前后一致，隔离性  不可见，持久性  一旦提交持久保存&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="腾讯面试" scheme="https://zhengluoliudao.github.io/tags/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>wyh面试圣经</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/wyh%E9%9D%A2%E8%AF%95%E5%9C%A3%E7%BB%8F/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/wyh%E9%9D%A2%E8%AF%95%E5%9C%A3%E7%BB%8F/</id>
    <published>2022-01-02T09:39:33.000Z</published>
    <updated>2022-01-02T09:40:45.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复习纲要"><a href="#复习纲要" class="headerlink" title="复习纲要"></a>复习纲要</h1><h2 id="计算机基础篇"><a href="#计算机基础篇" class="headerlink" title="计算机基础篇"></a>计算机基础篇</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul><li>链表和数组</li><li>栈和队列</li></ul><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><ul><li>二叉树</li><li>AVL树、红黑树</li><li>B/B+树</li><li>堆（感觉不严格属于树）</li></ul><p>（都不要求能够实现，甚至不需要知道左右旋之类的，知道区别，适用场景即可）</p><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><ul><li>遍历图的算法（DFS/BFS）</li><li>迪杰斯特拉等算法（考得很少）</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>快排</li><li>堆排序</li><li>归并排序</li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>这个只能练习几道题来掌握，感觉很灵活</p><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>感觉也是面试考题时毕竟容易遇到的，相对好掌握一点，也需要练练题</p><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>没咋遇到过考贪心的</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>CPU的轮转调度</li><li>进程和线程</li><li>Linux相关操作（查端口占用，查性能占用之类的）</li><li>Linux对锁的实现等等</li><li>还有些杂七杂八的</li></ul><h3 id="网络（这个是重点）"><a href="#网络（这个是重点）" class="headerlink" title="网络（这个是重点）"></a>网络（这个是重点）</h3><h4 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h4><ul><li>特点（无状态，应用层协议之类的）</li><li>一次GET请求的过程（这个真的会考）</li><li>cookie和session（这个也考过，我还没答上来）</li><li>二者的区别，以及HTTPS如何保证安全</li><li>其它一堆东西（我现在一下子记不起来了</li></ul><h4 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h4><ul><li>二者区别和特点</li><li>TCP的拥塞控制和流量控制（常考题）</li><li>TCP的三次握手四次挥手（你一定会遇到的题，建议深入了解）</li><li>TCP的原理</li></ul><h4 id="web框架"><a href="#web框架" class="headerlink" title="web框架"></a>web框架</h4><p>这个不会就说不会（我也不太会</p><h2 id="JAVA篇"><a href="#JAVA篇" class="headerlink" title="JAVA篇"></a>JAVA篇</h2><h3 id="Java特性"><a href="#Java特性" class="headerlink" title="Java特性"></a>Java特性</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li>类、接口</li><li>继承、多态、抽象等等</li></ul><h4 id="Java容器（或者数据结构）"><a href="#Java容器（或者数据结构）" class="headerlink" title="Java容器（或者数据结构）"></a>Java容器（或者数据结构）</h4><ul><li><p>List和Array</p></li><li><p>HashMap、HashTable、TreeMap、ConcurrentHashMap</p><ul><li>Collection集合接口和Map接口有什么关系（所以Map不太算容器，它继承自Set</li><li>HashMap是线程安全的吗？线程安全的Map都有哪些？性能最好的是哪个？（大概看看各种Map的区别，复习到这里的时候可以先问问我，可以先大致给你讲讲）</li><li>HashMap的一系列问题（扩容啊，实现啊，插入啊，查询啊balabala的）</li></ul></li></ul><h4 id="Java的锁（这块儿咱们学得比较少）"><a href="#Java的锁（这块儿咱们学得比较少）" class="headerlink" title="Java的锁（这块儿咱们学得比较少）"></a>Java的锁（这块儿咱们学得比较少）</h4><ul><li>什么是线程安全，如何保证</li><li>什么是死锁，产生死锁的四个条件（这个也是常考题）</li><li>synchronized关键字</li><li>volatile关键字</li><li>锁实现的一般原理和synchronized 实现原理</li><li>synchronized 与 Lock 的区别（也考过几次）</li><li>CAS无锁的概念、乐观锁和悲观锁</li><li>偏向锁、轻量级锁、重量级锁、自旋锁的概念（这两个比较难，不一定非要理解）</li></ul><h4 id="Java的多线程"><a href="#Java的多线程" class="headerlink" title="Java的多线程"></a>Java的多线程</h4><ul><li>什么是线程</li><li>线程和进程的区别</li><li>如何在Java中实现线程（三种方法：继承Thread类、完成Runnable接口，实现Callable&lt;&gt;接口并重写call方法）</li><li>Thread 类中的start() 和 run() 方法有什么区别</li><li>Vector是一个线程安全类吗？（同理，他有可能问你每一个常见容器是否安全）</li><li>java线程间通讯的方法</li><li>进程间通信的方法</li><li>线程池（一个重要考点）<ul><li>线程池的作用，为什么要使用线程池</li><li>如何创建一个线程池，有哪些参数（比较重要）</li><li>按线程池内部机制，当提交新任务时，有哪些异常要考虑。</li><li>线程池的拒绝策略</li><li>其它（我这块儿一直掌握不佳）</li></ul></li><li>线程如何启动</li></ul><h4 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h4><ul><li>JVM内存模型</li><li>GC（上面两个都是软件构造讲过的）</li><li>类加载机制（背下来就差不多了）</li></ul><h4 id="JavaSpring（学有余力可以学）"><a href="#JavaSpring（学有余力可以学）" class="headerlink" title="JavaSpring（学有余力可以学）"></a>JavaSpring（学有余力可以学）</h4><h2 id="数据库（也是重点）"><a href="#数据库（也是重点）" class="headerlink" title="数据库（也是重点）"></a>数据库（也是重点）</h2><ul><li>sql语句书写（找个在线sql练习网站练一练就好）</li><li>MySql的哪几种引擎（主要了解InnoDB和MyIASM）</li><li>MySql的索引，什么时候用Hash索引什么时候使用B+树索引</li><li>为什么数据库采用B+树来实现</li><li>事务的性质（ACID四大性质）</li><li>事务的隔离级别（以上都是重点）</li><li>MySql的锁（不需要像Java了解那么深，知道不同引擎有不同锁，效率上的区别和适用场景即可）</li><li>视图</li><li>非关系型数据库（可做了解）</li></ul><h2 id="设计模式（也经常考一两题）"><a href="#设计模式（也经常考一两题）" class="headerlink" title="设计模式（也经常考一两题）"></a>设计模式（也经常考一两题）</h2><ul><li>知道哪些设计模式啊？</li><li>单例模式的懒汉模式和饿汉模式（这个面试官蜜汁爱问）</li><li>反正23种设计模式都看看吧，没啥坏处（软件构造的助教小姐姐还在群里发了基本资料，有空可以瞅瞅）</li></ul><h2 id="分布式系统（一般不会就不问）"><a href="#分布式系统（一般不会就不问）" class="headerlink" title="分布式系统（一般不会就不问）"></a>分布式系统（一般不会就不问）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复习纲要&quot;&gt;&lt;a href=&quot;#复习纲要&quot; class=&quot;headerlink&quot; title=&quot;复习纲要&quot;&gt;&lt;/a&gt;复习纲要&lt;/h1&gt;&lt;h2 id=&quot;计算机基础篇&quot;&gt;&lt;a href=&quot;#计算机基础篇&quot; class=&quot;headerlink&quot; title=&quot;计算机基础</summary>
      
    
    
    
    
    <category term="WYH" scheme="https://zhengluoliudao.github.io/tags/WYH/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘知识点汇总</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</id>
    <published>2022-01-02T09:18:36.000Z</published>
    <updated>2022-01-02T13:25:22.522Z</updated>
    
    <content type="html"><![CDATA[<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>数据质量的度量：准确性，完整性，一致性，及时性，可信度，可解释性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">数据预处理的主要任务：</span><br><span class="line">数据清理：</span><br><span class="line">对丢失数据，忽略元组或手工/自动填写</span><br><span class="line">对噪声数据，binning（分类再进行数据平滑）, 回归拟合，检测噪声并去除，计算机人工联合检测</span><br><span class="line">对不一致数据，函数依赖项，人工规则</span><br><span class="line">数据简化：</span><br><span class="line">降维：PCA，奇异值分解</span><br><span class="line">数字缩减：回归和对数线性模型，直方图/聚类/采样，数据立方体聚合</span><br><span class="line">数据压缩：</span><br><span class="line">数据转换和数据离散化</span><br><span class="line"></span><br><span class="line">归一化：</span><br><span class="line">min-max归一化：(x-min)/(max-min)</span><br><span class="line">z-score归一化：x-均值/方差</span><br><span class="line"></span><br><span class="line">预处理的作用：缩减数据规模，整理数据形式；有效清理数据，增加数据分析都有效性和准确性</span><br><span class="line">预处理的步骤有哪些：数据抽样和过滤，数据标准化和归一化，数据清洗</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211130144505039.png" alt="image-20211130144505039"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PCA：捕捉有最大变化量的投影。找协方差矩阵的特征向量</span><br><span class="line">步骤：1，归一化S（减去均值）    </span><br><span class="line"> 2，计算C=S^TS   </span><br><span class="line"> 3，计算特征值和特征向量，特征向量即是主成分       |A-λE|=0，</span><br><span class="line">     4，P=SU，U为特征向量的拼接</span><br><span class="line">     </span><br><span class="line">行列式计算：主对角线元素积与副对角线元素积的差</span><br><span class="line">计算特征值和特征向量：解|A-λE|=0得特征向量，再代入|A-λE|，求得基础解系，归一化即得到特征向量，拼接特征向量得到U投影矩阵</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211130181727628.png" alt="image-20211130181727628"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SVD：A=UsigmaV</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">皮尔逊相关系数：x和y的协方差除以x和y的标准差（注意都是除以n-1）</span><br><span class="line">Jaccard相似度：同为1/不同为0</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211130214856248.png" alt="image-20211130214856248"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211202105030022.png" alt="image-20211202105030022"></p><h4 id="序列数据挖掘"><a href="#序列数据挖掘" class="headerlink" title="序列数据挖掘"></a>序列数据挖掘</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GSP：</span><br><span class="line">先得到频繁一项集，再反复进行：生成候选，剪枝，计数，淘汰</span><br><span class="line"></span><br><span class="line">1）连接阶段：如果去掉序列模式S1的第一个项目与去掉序列模式S2的最后一个项目所得到的序列相同，则可以将S1与S2进行连接，即将S2的最后一个项目添加到S1中。</span><br><span class="line">2）剪切阶段：若某候选序列模式的某个子序列不是序列模式，则此候选序列不可能是序列模式，将它从候选序列模式中删除。</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211203012723757.png" alt="image-20211203012723757"></p><h4 id="图挖掘"><a href="#图挖掘" class="headerlink" title="图挖掘"></a>图挖掘</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gspan:</span><br><span class="line">1、遍历所有的图，计算出所有的边和点的频度。</span><br><span class="line">2、将频度与最小支持度数做比较，移除不频繁的边和点。</span><br><span class="line">3、重新将剩下的点和边按照频度进行排序，将他们的排名号给边和点进行重新标号。</span><br><span class="line">4、再次计算每条边的频度，计算完后，然后初始化每条边，并且进行此边的subMining()挖掘过程。</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211203105021034.png" alt="image-20211203105021034"></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">决策树：</span><br><span class="line">如何确定分类属性：基尼指数，熵（最大化增益）（增益比），分类误差</span><br><span class="line">如何确定停止分类：所有记录属于同一类，所有记录属性值相同，没有剩余属性</span><br><span class="line">避免过拟合：预修剪pre-pruning（提前停止），post-pruning（可以用MDL）</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201162105742.png" alt="image-20211201162105742"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201162354111.png" alt="image-20211201162354111"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201170412634.png" alt="image-20211201170412634"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201170819820.png" alt="image-20211201170819820"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201173617851.png" alt="image-20211201173617851"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROC：横坐标FPR，纵坐标TPR，随阈值变化</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201201247406.png" alt="image-20211201201247406"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201201828986.png" alt="image-20211201201828986"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201201855128.png" alt="image-20211201201855128"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">K近邻：k个最近的里投票</span><br><span class="line">问题：距离公式，K的选择，属性值缩放归一化，维度</span><br><span class="line">贝叶斯分类器：最大化后验概率</span><br><span class="line">贝叶斯网络：</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201212957593.png" alt="image-20211201212957593"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20211201221646775.png" alt="image-20211201221646775"></p><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分区聚类和层次聚类</span><br><span class="line">聚类的类型：分离良好的，基于中心的，基于邻近的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基于密度的聚类：</span><br><span class="line">DBSCAN算法：核心点，边界点，噪声点</span><br><span class="line">在彼此Eps内的任何两个核心点都在同一个聚类中，核心点Eps内的点都在同一个聚类</span><br><span class="line">部分聚类方法，时间复杂度O(n^2)，允许不准确则可以到O(n)</span><br><span class="line">确定Eps和MinPts</span><br><span class="line"></span><br><span class="line">基于网格的聚类：划分网格，计算网格密度，消除密度低于阈值的网格，连续网格形成簇</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">层次聚类：嵌套聚类</span><br><span class="line">凝聚：合并最接近的聚类，更新邻近矩阵，循环</span><br><span class="line">聚类间距离：最小，最大，平均，质心，沃德法（平方差SSE变化量，每个值减去合并后的均值，平方再求和）</span><br><span class="line">分裂：</span><br><span class="line">cure算法（使用代表点）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K-means：循环：选中心，根据距离分类</span><br></pre></td></tr></table></figure><h4 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">频繁项集：</span><br><span class="line">Apriori算法：</span><br><span class="line">剪枝：任意频繁项集的非空子集也是频繁的</span><br><span class="line"></span><br><span class="line">FP-growth:</span><br><span class="line">建立频繁一项集，剪枝删除没达到支持度的节点，按照支持度排序重排原集合（不要忘了这个）</span><br><span class="line">建立FP-树</span><br><span class="line">从树底E出发，建立条件模式基，祖先节点计数置为叶子节点的计数，从而挖掘出含E的频繁项集</span><br><span class="line">递归挖掘频繁项集</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;预处理&quot;&gt;&lt;a href=&quot;#预处理&quot; class=&quot;headerlink&quot; title=&quot;预处理&quot;&gt;&lt;/a&gt;预处理&lt;/h4&gt;&lt;p&gt;数据质量的度量：准确性，完整性，一致性，及时性，可信度，可解释性&lt;/p&gt;
&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    
    <category term="数据挖掘" scheme="https://zhengluoliudao.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>2020年高级数据库试题</title>
    <link href="https://zhengluoliudao.github.io/2022/01/02/hello/"/>
    <id>https://zhengluoliudao.github.io/2022/01/02/hello/</id>
    <published>2022-01-02T08:08:02.000Z</published>
    <updated>2022-01-02T08:18:08.393Z</updated>
    
    <content type="html"><![CDATA[<hr><h5 id="⼀、简答题（数据库语⾔，共20分）"><a href="#⼀、简答题（数据库语⾔，共20分）" class="headerlink" title="⼀、简答题（数据库语⾔，共20分）"></a>⼀、简答题（数据库语⾔，共20分）</h5><ol><li>（8分）在图书管理数据库中，有如下三个关系：<br>图书信息关系：B(B#, BNAME, AUTHOR, TYPE)，其中B#为图书编号，BNAME为书名，<br>AUTHOR为作者，TYPE为图书类别；<br>学⽣信息关系：S(S#, SNAME, CLASS)，其中S#为学号，SNAME为学⽣姓名，CLASS为班级<br>号；<br>借阅信息关系：L(S#, B#, DATE)，其中S#为借阅⼈学号，B#为被借阅图书编号，DATE为借<br>阅⽇期。<br>使⽤关系代数回答下列问题：<br>a) （2分）查询借了《红楼梦》这本书的学⽣的姓名。<br>b) （2分）查询105班的所有学⽣全都借过的图书的编号。<br>c) （2分）查询“张三”同学借过，但是“李四“同学没有借过的书的编号。<br>d) （2分）编写⼀个查询，说明如何根据该查询的结果验证B的关系实例是否满⾜函数依赖<br>BNAME → B#。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">a)</span><br><span class="line">select SNAME </span><br><span class="line">from </span><br><span class="line">((B join L using B#) join S using S#)</span><br><span class="line">where BNAME = &quot;红楼梦&quot;  </span><br><span class="line"></span><br><span class="line">b)  #这里有一个关键词，全都，即借阅人数等于总人数，或者不存在人没选</span><br><span class="line">select B# </span><br><span class="line">from </span><br><span class="line">((B join L using B#) join S using S#) X</span><br><span class="line">where CLASS = 105 </span><br><span class="line">group by B#</span><br><span class="line">having count(*) = </span><br><span class="line">(select count(*) from </span><br><span class="line">((B join L using B#) join S using S#) Y</span><br><span class="line">where Y.CLASS = 105) </span><br><span class="line"></span><br><span class="line">select B# from</span><br><span class="line">((B join L using B#) join S using S#) X</span><br><span class="line">where CLASS = 105 and not exists</span><br><span class="line">(</span><br><span class="line">select * from </span><br><span class="line">((B join L using B#) join S using S#) Y</span><br><span class="line">where Y.CLASS = 105 and  X.B# != Y.B#</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">c) #这里有一个关键词，借过/学过，没借过/没学过</span><br><span class="line">select B# from </span><br><span class="line">((B join L using B#) join S using S#) X</span><br><span class="line">where </span><br><span class="line">&quot;张三&quot; in </span><br><span class="line">(select SNAME from </span><br><span class="line">((B join L using B#) join S using S#) Y</span><br><span class="line">where X.B# = Y.B#</span><br><span class="line">) Z</span><br><span class="line">and &quot;李四&quot; not in Z</span><br><span class="line"></span><br><span class="line">d) #验证函数依赖，即确定如果两本书书名相同，书号必相同，即根据书名找书号找不到两个</span><br><span class="line">select count(B#) from B</span><br><span class="line">group by BNAME</span><br><span class="line">如果不是全为1，则函数依赖不成立，反之成立</span><br></pre></td></tr></table></figure><ol><li><h5 id="（12分）在博客管理数据库中，有如下三个关系："><a href="#（12分）在博客管理数据库中，有如下三个关系：" class="headerlink" title="（12分）在博客管理数据库中，有如下三个关系："></a>（12分）在博客管理数据库中，有如下三个关系：</h5><p>⽤户信息关系：U(UID#，UNAME, UAGE, USEX)，该表包含属性UID#（⽤户ID）、<br>UNAME（⽤户姓名）、UAGE（⽤户年龄）、USEX（⽤户性别）。<br>博客信息关系：B(BID#，UID#，BTITLE，BCONTENT，BTIME)，该表包含属性BID#（博客<br>编号）、UID#（作者ID），BTITLE（博客标题），BCONTENT（博客内容），BTIME（博客<br>发布时间）。<br>评论信息关系：C(CID#, BID#, UID#, CCONTENT，CTIME)，该表包含属性CID#（评论编<br>号），BID#（被评论博客编号），UID#（评论者ID），CCONTENT（评论内容），<br>CTIME（评论时间）。<br>UID #、BID #、CID#分别为关系U、B、C的主键。使⽤SQL语⾔回答下列问题：<br>a) （3分）删除名为“张三”的⽤户发表的所有博客。<br>b) （3分）查询“张三”对“李四”发表的博客的评论总数。<br>c) （3分）定义⼀个视图SumU(UID#, UNAME, Year, Count#)，其中UID#为⽤户id，UNAME<br>为⽤户姓<br>名，Year为年份，Count#为该⽤户该年度发表博客的总数。<br>d)（3分）基于视图SumU，查询2019年发表博客数最多的⽤户的ID和姓名。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">a)</span><br><span class="line">delete from B</span><br><span class="line">where UID in </span><br><span class="line">(</span><br><span class="line">select UID from U where U.UID = B.UID and UNAME = &quot;张三&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">b)</span><br><span class="line">select count(*) from C</span><br><span class="line">where BID in </span><br><span class="line">(</span><br><span class="line">select BID from B join U where UNAME = &quot;李四&quot;</span><br><span class="line">)</span><br><span class="line">and UID in </span><br><span class="line">(</span><br><span class="line">select BID from B join U where UNAME = &quot;张三&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">c)</span><br><span class="line">create view SumU as</span><br><span class="line">select X.UID# UID#, X.UNAME UNAME, </span><br><span class="line">Date_FORMAT(X.BTIME, &quot;%Y&quot;) Year, </span><br><span class="line">count(BID#) Count# </span><br><span class="line">from U join B using UID# X</span><br><span class="line">group by UID#, year</span><br><span class="line"></span><br><span class="line">d)  #关键词，最大, &gt;ALL , = MAX</span><br><span class="line">select UID#, BNAME</span><br><span class="line">from SumU X</span><br><span class="line">where Year = 2019 and </span><br><span class="line">count# &gt;= all</span><br><span class="line">(</span><br><span class="line">select count# from SumU where Year = 2019</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="⼆、计算与简答题（关系数据库理论，共18分）"><a href="#⼆、计算与简答题（关系数据库理论，共18分）" class="headerlink" title="⼆、计算与简答题（关系数据库理论，共18分）"></a>⼆、计算与简答题（关系数据库理论，共18分）</h5><p>已知关系模式R(A, B, C, D, E)上的函数依赖集F为{ AC → E; B → CE; C → B; AB → CD; AE → D }，回答下<br>列问题：</p><ol start="2"><li>（3分）求AC关于F的属性集闭包。</li><li>（3分）求R的候选键。</li><li>（4分）求F的最⼩覆盖。</li><li>（4分）将R分解为2个关系模式S(A, B, C)和T(A, B, D, E)，该分解是否是⽆损连接分解？说明理由。</li><li>（4分）将R进⾏分解⼀组3NF关系模式，使得该分解既是⽆损连接分解，⼜保持函数依赖。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)</span><br><span class="line">闭包</span><br></pre></td></tr></table></figure><h5 id="三、论述题（共12分）"><a href="#三、论述题（共12分）" class="headerlink" title="三、论述题（共12分）"></a>三、论述题（共12分）</h5><p>结合你的数据库系统实践经历，回答下列问题：</p><ol><li>（4分）数据库的三级模式和两级映像架构对数据库系统有何重要意义？</li><li>（4分）在设计⼤型关系数据库时，遵照“概念设计→逻辑设计→物理设计”的设计过程有何好处？</li><li>（4分）数据库管理系统的缓冲区管理与操作系统的虚拟内存管理有何不同之处？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="四、分析与简答题（数据库管理系统实现，共34分）"><a href="#四、分析与简答题（数据库管理系统实现，共34分）" class="headerlink" title="四、分析与简答题（数据库管理系统实现，共34分）"></a>四、分析与简答题（数据库管理系统实现，共34分）</h5><ol><li>（6分）使⽤可扩展hash表存储整型元素。设hash函数为h(x) = x mod 16，h(x)的结果是⼀个4位<br>⼆进制序列，其前d位⽤于确定元素x属于哪个桶。设每个桶中⾄多包含2个元素。现将下列元素依<br>次添加到hash表中：5, 19, 24, 26, 35, 48, 53, 61。初始时，hash表为空，且d = 1。请画出添加完<br>上述所有元素后，最终得到的hash表。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ol><li>（6分）关系R(a, b)和S(b, c)存储在磁盘上，分别占500和1000个磁盘块。R和S上既⽆索引，也未<br>按属性b排序。设可⽤内存缓冲区块数为M，回答下列问题：<br>a)（3分）如果M = 50，那么使⽤哪种连接算法执⾏R ⨝ S效率最⾼？I/O代价是多少？<br>b)（3分）如果M = 126，那么使⽤哪种连接算法执⾏R ⨝ S效率最⾼？I/O代价是多少？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a)哈希，4500</span><br><span class="line">b)哈希</span><br></pre></td></tr></table></figure><ol><li>（6分）设教学管理数据库有如下3个关系模式：<br>EMPLOYEE(ESSN#, ENAME, SALARY, DNO#)<br>PROJECT(PNO#, PNAME)<br>WORKS_ON(ESSN#, PNO#)<br>DEPARTMENT(DNO#, DNAME)<br>⽤户给出以下SQL语句：<br>SELECT ENAME<br>FROM EMPLOYEE, WORKS_ON, PROJECT<br>WHERE SALARY &lt; 3000 AND PROJECT.PNO = ‘P1’<br>AND EMPLOYEE.ESSN# = WORKS_ON.ESSN# AND WORKS_ON.PNO# = PROJECT.PNO#;<br>回答下列问题：<br>a) （3分）写出该SQL语句对应的关系代数表达式，并画出该表达式对应的逻辑查询计划树。<br>b) （3分）使⽤启发式查询优化⽅法对以上查询计划进⾏优化，并画出优化后的逻辑查询计划<br>树。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h5 id=&quot;⼀、简答题（数据库语⾔，共20分）&quot;&gt;&lt;a href=&quot;#⼀、简答题（数据库语⾔，共20分）&quot; class=&quot;headerlink&quot; title=&quot;⼀、简答题（数据库语⾔，共20分）&quot;&gt;&lt;/a&gt;⼀、简答题（数据库语⾔，共20分）&lt;/h5&gt;&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="DataBase" scheme="https://zhengluoliudao.github.io/tags/DataBase/"/>
    
  </entry>
  
</feed>
