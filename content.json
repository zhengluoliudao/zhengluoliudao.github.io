{"meta":{"title":"风连广宇的萌萌哒小博客","subtitle":"","description":"","author":"momentum","url":"https://zhengluoliudao.github.io","root":"/"},"pages":[],"posts":[{"title":"高级数据库知识点汇总","slug":"高级数据库知识点汇总","date":"2022-01-02T13:32:53.000Z","updated":"2022-01-02T13:47:18.388Z","comments":true,"path":"2022/01/02/高级数据库知识点汇总/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"","text":"数据模型和概念模型12数据模型：表达数据/计算机世界的模型概念模型：表达观念/信息世界的模型 ER图1ER图基本概念：实体，属性，联系，关键字 1234567IDEF1X图：独立实体用直角方形框，从属实体用圆角方形框表示独立实体的主关键字没有外键，从属实体的主关键字含有外键标定联系：子实体的实例都是由它与父实体的联系而确定。父实体的主关键字是子实体主关键字的一部分非标定联系：子实体的实例能够被唯一标识而无需依赖与其实体的联系。父实体的主关键字不是子实体的主关键字。非确定联系：即实体之间的多对多的联系，必须分解为若干个一对多的联系来表达，通过引入相交实体来分解分类联系：一个实体实例是由一个一般实体实例及多个分类实体实例构成的 函数依赖123非平凡函数依赖：X-&gt;Y, Y不属于X完全/部分函数依赖： X-&gt;Y, X的部分能/不能-&gt;Y传递函数依赖：若X-&gt;Y, Y-&gt;Z, 且Y不属于X, Y不能-&gt;X, 则x-&gt;Z Armstrong公理 属性集闭包1X在R(U,F)上的闭包：X能决定的集合 最小覆盖 关系模式的范式1234第一范式 属性不可分第二范式 每个非主属性完全函数依赖于候选键第三范式 每个非主属性不传递函数依赖于候选键BCNF 任意主属性都完全函数依赖于候选键 关系模式分解无损连接性，函数依赖保持性 存储体系回顾12345678操作系统对磁盘管理：FAT(文件分配表)+目录+磁盘块 操作系统将文件保存在多个不连续磁盘块，目录/文件夹保存第一个磁盘块编号，FAT表格保存每个磁盘块的下一个磁盘块编号操作系统对内存管理：内存页对应磁盘块，记录地址=页面+页内偏移量，页面的分配与替换磁盘：盘面--磁道--扇区--磁盘块磁盘读取时间=寻道时间+旋转时间+传输时间RAID(独立磁盘冗余阵列)技术： 并行处理：并行读取多个磁盘 可靠性：奇偶检验与纠错 1表所占磁盘块的分配方法：连续分配，链接分配，按簇分配，索引分配 1234567四种文件组织方法： 无序记录文件（堆文件）：需要数据库重组 有序记录文件：对排序字段检索效率高，更新效率低（可以用溢出文件） 散列文件：查找和更新效率都高 聚簇文件：将具有相同或相似属性值的记录存放于连续的磁盘簇块中；多表聚簇 性能降低：数据库重组 索引 123稠密索引：索引中包含了主文件对应字段的所有不同值 候选键的稠密索引 非候选键的稠密索引稀疏索引：主文件中只有部分记录有索引项对应 ----要求主文件按照索引值顺序存储 12主索引辅助索引 连接算法 I/O代价 可用内存页数要求 适用条件 一趟连接算法 B(R) + B(S) B(S) &lt; M − 1 基于元组的嵌套循环连接算法 T(S)(T(R) + 1) M &gt;= 2 基于块的嵌套循环连接算法 B(S) + B(R)B(S)/(M-1) M &gt;= 2 排序归并连接算法 3B(R) + 3B(S) B(R) + B(S) &lt;= M^2 有序 基于哈希的连接算法 3B(R) + 3B(S) B(S) &lt;= (M-1)^2 基于索引的连接算法 B(R) + T(R)T(S)/V(S,Y) 非聚簇索引 B(R) + T(R)B(S)/V(S,Y) 聚簇索引 M &gt;= 2 有索引 12如何判断使用哪种算法以及代价：先看R和S的大小是否超过M，超过则一趟连接算法不可用；无索引，则索引连接不可用；无序，则排序归并不可用。优先哈希 查询优化12逻辑查询优化：改写成关系代数表达式（投影操作（选择操作（连接操作）））---尽可能早做选择投影操作物理查询优化：对不同操作选取不同算法 12345678910关系代数操作次序交换的等价性： 连接，笛卡尔积满足交换律 连接和笛卡儿积满足结合律 投影合并律 选择串接律 选择和投影交换律：若选择操作只涉及投影属性，则可交换顺序 选择和积的交换律：若选择操作只涉及E1中的属性，则 选择(E1*E2) = 选择(E1)*E2 若F1和F2分别只涉及E1和E2，则 选择F1^F2(E1*E2) = 选择F1(E1)*选择F2(E2) 优化语法树步骤： 1. 选择条件拆分 2. 对每个选择尽可能移动到下方(看条件的属性涉及到几张表，基本可以直接移动到涉及的表上方) 3. 对每个投影尽可能移动到下方(基本是拆分每个表的投影属性，然后下移) 1物理查询代价估计 并发控制12冲突条件：两个操作属于不同事务；两个操作涉及相同对象，且至少一个是写优先图：操作Oi和Oj冲突（Oi在Oj前），则有一条Oi指向Oj的边；优先图无环等价于冲突可串行化调度。 2PL(两阶段锁) 123456789101112131415161718增长阶段：事务申请锁萎缩阶段：事务只能释放锁，不能申请优点：冲突可串行化缺点：面临级联中止和死锁 SS2PL（强两阶段锁）增长阶段：同2PL萎缩阶段：事务结束释放所有锁优点：避免级联中止死锁死锁的形成条件： 1、互斥条件：一个资源每次只能被一个进程使用； 2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 3、不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺； 4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系；死锁检测：超时检测，等待图检测死锁预防：设置优先级 故障恢复123456undo：撤销未完成事务对数据库的修改redo：重做已提交事务对数据库的修改steal：允许未提交事务所做修改提交到磁盘froce：事务提交前必须将所做修改提交到磁盘NO-Steal+Force 无需undo,redo 12345WAL（预写式日志）：&lt;tid 事务id, O_id 修改对象id, before 修改前值, after 修改后值&gt;基于WAL的故障恢复检查点：&lt;BEGIN CHECKPOINT (T1,T2, . . . ,Tn)&gt; T1到Tn是检查点开始时的未提交未中止事务故障恢复：redo找提交的，从检查点开始向下找；undo从后往前找未提交的，直到检查点（只需要从检查点后开始redo） 各数据库模型对比 描述 网状/层次模型 以图/树为操控手段，以记录型和系型为基本数据结构，维护困难 关系模型 以表为操作手段，通过5种基本运算对表操作，使用SQL语句查询，结构简单但是数据表达能力差 面向对象模型 以对象为操作手段，使用对象封装技术将复合属性及聚集类型属性封装为对象，使用OQL语句进行查询，可读性强，易于扩展，但是执行速度慢 XML模型 多用于描述半结构化数据，将数据的语义格式和数据通过标记和可分词字符串组合成一个元素放在XML文档中，通过Xpath/Xquery语言检索，可以嵌套描述，XML的数据结构是一棵树 NoSQL模型 泛指非关系型数据库，有多种存储方式，高性能易扩展","categories":[],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"https://zhengluoliudao.github.io/tags/DataBase/"}]},{"title":"2020年组合数学考试题","slug":"2020年组合数学考试题","date":"2022-01-02T13:30:51.000Z","updated":"2022-01-02T13:51:00.318Z","comments":true,"path":"2022/01/02/2020年组合数学考试题/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/2020%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95%E9%A2%98/","excerpt":"","text":"14男4女围圆桌交替就座，请向有多少种就座方式? (10分) 1某车站有1到6个人口，每个人口每次只能进入一个人，一个小组共有9人组成，请问这个小组有多少种不同的进站方案? 1用鸽笼原理证明Fermat小定理:设p是-个素数,a是一个整数,并且(a,p)=1。证明: a^(P-1)=== 1(mod p)。(10分)","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://zhengluoliudao.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"组合数学知识点汇总","slug":"组合数学知识点汇总","date":"2022-01-02T13:29:43.000Z","updated":"2022-01-02T13:42:08.914Z","comments":true,"path":"2022/01/02/组合数学知识点汇总/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"","text":"组合数学 第一章 排列与组合排列1234从n 个不同的元素中不重复的选取r(1 &lt;= r &lt;= n) 个元素并将其排成一排称为n个元素的r排列, 其方法数记为P(n, r) 或Prn.重点：有序，不同元素，n!/(n-m)!题目：这部分题目都比较简单，可以用排除取补，分割问题等办法 12如n，r包含于N 且n &gt;= r &gt;= 2，则P(n, r) = n * P(n - 1, r - 1)如n，r包含于N 且n &gt;= r &gt;= 2，则P(n, r) = r * P(n - 1, r - 1) + P(n - 1, r) 1圆排列：从n 个不同的元素中选取r(1 &lt;= r &lt;= n) 个元素的园排列数为 p(n, r)/r 多重集的排列1a1-an互不相同，无限多重集选取r个元素的排列方式有n^r种 1有限多重集全排总数为 (K1+K2+...+Kn)!/K1!K2!...Kn! 组合12组合：只选不排，C(n,r)=n!/(n-r)!r!C(n, r) = C(n, n-r) 1杨辉三角 多重组合12多重组合：对无限多重集，r-组合数有 F(n, r) = C(n+r-1, r) 1不相邻组合：从集合A = &#123;1，2，3，，，n&#125; 中选取r个元素做组合，其中不存在i, i + 1 两个相邻的数同时出现于一个组合的组合，被称为不相邻组合。，其组合数为 C(n - r + 1, r) 二项式定理 组合恒等式第二章 鸽巢原理与Ramsey 理论鸽笼原理基本形式1 鸽笼原理加强形式 Ramsey理论 第三章 容斥原理容斥原理 错排问题 限位排列 广义容斥原理 第四章 母函数普通母函数 指数母函数 母函数的基本运算 母函数的应用 正确答案是 3328 在组合恒等式中的应用 第五章 递推关系递推关系常系数线性齐次递推关系 非齐次常系数线性递推关系迭代法与归纳法母函数在递推关系中的应用第六章 特殊计数Fibonacci数Catalan 数 Stirling 数 Bell 数差分序列分拆数","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://zhengluoliudao.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"JZ_Offer","slug":"JZ-Offer","date":"2022-01-02T09:49:40.000Z","updated":"2022-01-02T09:51:12.579Z","comments":true,"path":"2022/01/02/JZ-Offer/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/JZ-Offer/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833283428352836283728382839284028412842284328442845284628472848284928502851285228532854285528562857285828592860286128622863286428652866286728682869287028712872287328742875287628772878287928802881288228832884288528862887288828892890289128922893289428952896289728982899290029012902290329042905290629072908290929102911291229132914291529162917291829192920292129222923292429252926292729282929293029312932293329342935293629372938293929402941294229432944294529462947294829492950295129522953295429552956295729582959296029612962296329642965296629672968296929702971297229732974297529762977297829792980298129822983298429852986298729882989299029912992299329942995#给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？#输出需要删除的字符个数#解题思路：回文串的特点，想到将源字符串逆转后，“回文串”（不一定连续）相当于顺序没变#求原字符串和其反串的最大公共子序列（不是子串，因为可以不连续）的长度，然后用原字符串的长度减去这个最大公共子串的长度就得到了最小编辑长度。#用dp解决lcs: 相等 dp[i][j] = dp[i-1][j-1] + 1# 不相等 dp[i][j] = max&#123;dp[i-1][j], dp[i][j-1]&#125;import sysdef lcs(line): if line==None or len(line) == 0: return 0 line_reverse = line[::-1] line_len = len(line) #注意，这样申请二维数组是错误的，因为[0] * 5是一个一维数组的对象，* 3的话只是把对象的引用复制了3次，还是同一个地址，修改会一起被修改 #错误！！！ dp = [[0] * (line_len+1)] * (line_len + 1) dp =[[0] *(line_len+1) for _ in range(line_len+1)] for i in range(1, line_len+1): for j in range(1, line_len+1): if line[i-1] == line_reverse[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) lcs_len = dp[-1][-1] return lcs_lenif __name__ == &#x27;__main__&#x27;: try: for line in sys.stdin: line = line.strip() line_len = len(line) if line_len == 0: break else: lcs_len = lcs(line) drop_len = line_len - lcs_len print(drop_len) except: pass#注意：碰到了楼上Python解法同样的问题，没把循环过程放到name中，一直说是过90% #然后超时，放进去就好了。猜一下：是不是给了程序入口能加快解析 # -*- coding:utf-8 -*-import sysdef maxlcp(s): if s==None or len(s)==0: return 0 leng = len(s) dp =[] dp =[[0] *(leng+1) for _ in range(leng+1)] for i in range(1,lens+1): for j in range(1,lens+1): if s[i-1] == s[leng-j]: #not include i,j dp[i][j] = dp[i-1][j-1] +1 else: dp[i][j] = max(dp[i-1][j],dp[i][j-1]) return dp[-1][-1]if __name__ == &#x27;__main__&#x27;: while True: line = sys.stdin.readline().strip() lens = len(line) if not line: break maxLcp = maxlcp(line) print(lens - maxLcp)###############################################################################################################################小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。#你能帮帮小Q吗？#解题思想：冒泡try: while True: s = input().strip() if s == &#x27;&#x27;: break for i in s: if i.isupper(): s = s+i s = s[0:s.index(i)] + s[s.index(i)+1 : ] print(s)except: pass###############################################################################################################################小Q今天在上厕所时想到了这个问题：有n个数，两两组成二元组，相差最小的有多少对呢？相差最大呢？#解题思路：先排序， 1.差值最大的好求，看有序数组有几个最小值和几个最大值，相乘即可# 2. 差值最小的，由有序数组生成差值数组import systry: #for line in sys.stdin: while True: N = input().strip() nums = input().strip().split(&quot; &quot;) nums = [(int)(i) for i in nums] nums.sort() Dict = &#123;&#125; for i in nums: if i in Dict.keys(): Dict[i] += 1 else: Dict[i] = 1 num_max = Dict[nums[0]] * Dict[nums[-1]] num_min = 0 for i in Dict.values(): if i &gt;= 2: tmp = i*(i-1)/2 num_min += tmp if num_min == 0: #说明没有相同的数字，即不存在差值为0 nums_2 = [] for i in range(len(nums)-1): nums_2.append(nums[i+1]-nums[i]) nums_2.sort() num_min = nums_2.count(nums_2[0]) num_min = (int)(num_min) print((str)(num_min) + &quot; &quot; + (str)(num_max))except: passimport sysfor line in sys.stdin: temp = [int(i) for i in line.split()] if len(temp) == 1: # 把N跳过 continue temp.sort() Dict = &#123;&#125; for i in temp: if i in Dict: Dict[i] += 1 else: Dict[i] = 1 res = 0 for k in Dict.keys(): if Dict[k] &gt;= 2: temp2 = [i for i in range(Dict[k])] res += sum(temp2) if res == 0: # 没重复的情况，比如[1,2,3,9]这种 temp3 = [] for j in range(len(temp)-1): temp3.append(temp[j+1] - temp[j]) temp3.sort() # print()会换行，算例通不过，加了end就不会换行 print(temp3.count(temp3[0]), end=&quot; &quot;) else: print(res, end=&quot; &quot;) num_max, num_min = Dict[temp[-1]], Dict[temp[0]] print(num_max*num_min)###############################################################################################################################链接：https://www.nowcoder.com/questionTerminal/11ee0516a988421abf40b315a2b28d08?answerType=1&amp;f=discussion#现在有107个用户，编号为1- 107，现在已知有m对关系，每一对关系给你两个数x和y，代表编号为x的用户和编号为y的用户是在一个圈子中，# 例如：A和B在一个圈子中，B和C在一个圈子中，那么A,B,C就在一个圈子中。现在想知道最多的一个圈子内有多少个用户。 #解题思路：并查集# 并查集：要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可import sysclass unionfind(): def __init__(self, n): self.father = list(range(n+1)) self.size = [1] * (n+1) def find(self, x): if self.father[x] == x: return x self.father[x] = self.find(self.father[x]) return self.father[x] def merge(self,x,y): fx = self.find(x) fy = self.find(y) if fx != fy: self.father[fy] = fx self.size[fx] += self.size[fy] returnif __name__ == &#x27;__main__&#x27;: try: T = (int)(input().strip()) for i in range(T): n = (int)(input().strip()) un = unionfind(1000000) max_size = 1 for j in range(n): x,y = [(int)(a) for a in input().strip().split()] un.merge(x,y) max_size = max(max_size, un.size[un.find(x)]) print(max_size) except: pass#别人的题解import sysclass unionfind(): def __init__(self, n): self.father = list(range(n+1)) self.size = [1] * (n+1) def find(self, x): if self.father[x] == x: return x self.father[x] = self.find(self.father[x]) return self.father[x] def merge(self,x,y): fx = self.find(x) fy = self.find(y) if fx != fy: self.father[fy] = fx self.size[fx] += self.size[fy] returnn1 = int(input())for i in range(n1): n2 = int(input()) un = unionfind(1000000) res = 1 for j in range(n2): line = sys.stdin.readline().strip() a,b = list(map(int, line.split())) un.merge(a,b) res = max(res,un.size[un.find(a)]) print(res)###############################################################################################################################输入一个字符串 s，s 由小写英文字母组成，保证 s 长度小于等于 5000 并且大于等于 1。在 s 的所有不同的子串中，输出字典序第 k 小的字符串。#字符串中任意个连续的字符组成的子序列称为该字符串的子串。字母序表示英文单词在字典中的先后顺序，#即先比较第一个字母，若第一个字母相同，则比较第二个字母的字典序，依次类推，则可比较出该字符串的字典序大小#解题思路：字典序第k小, 投机取巧真的爽，首先肯定长度为k（不然减少或到不了第k个），那么可以把所有连续的长度为k的子串都截取出来，# 然后根据前k个字符串排序if __name__ == &#x27;__main__&#x27;: try: s = input().strip() k = (int)(input()) str_set = [] for i in range(len(s)-k): str_set.append(s[i:i+k]) res = sorted(str_set) print(res[0]) except: passif __name__ == &#x27;__main__&#x27;: try: s = input().strip() k = (int)(input()) str_set = [] for i in range(len(s)-k): str_set.append(s[i:i+k]) if k == 1: #sort和sorted不同，前者会改变原字符串 res = sorted(str_set, key = lambda x:(x[0])) elif k == 2: res = sorted(str_set, key = lambda x:(x[0], x[1])) elif k == 3: res = sorted(str_set, key = lambda x:(x[0], x[1], x[2])) elif k == 4: res = sorted(str_set, key = lambda x:(x[0], x[1], x[2], x[3])) else: res = sorted(str_set, key = lambda x:(x[0], x[1], x[2], x[3], x[4])) print(res[0]) except: pass#投机取巧，nbs=input().strip()k=int(input())A=[]for i in range(len(s)-k): A.append(s[i:i+k])if k==1: A=sorted(A,key=lambda x:(x[0]))elif k==2: A=sorted(A,key=lambda x:(x[0],x[1]))elif k==3: A=sorted(A,key=lambda x:(x[0],x[1],x[2]))elif k==4: A=sorted(A,key=lambda x:(x[0],x[1],x[2],x[3]))else: A=sorted(A,key=lambda x:(x[0],x[1],x[2],x[3],x[4]))print(A[0])#暴力枚举s = input()k = int(input())k_str = [0 for i in range(k)]for i in range(len(s)): for j in range(i,min(i+k,len(s))): for kk in range(k): if k_str[kk]==s[i:j+1]: break if k_str[kk]==0: k_str[kk]=s[i:j+1] break elif k_str[kk]&gt;s[i:j+1]: k_str[kk+1:]=k_str[kk:-1] k_str[kk]=s[i:j+1] breakprint(k_str[-1])###############################################################################################################################求抛物线y^2 = 2Ax 与直线y = Bx+ C 所围成的封闭图形面积.若图形不存在,则输出0#解题思路：数学题，对(f1(x) - f2(x))dy积分，积分上下限为交点y坐标import mathdef get_area(A,B,C,y): res = (-1/(6*A)) * y*y*y + (1/(2*B))*y*y - (C/B)*y return resif __name__ == &quot;__main__&quot;: T = (int)(input().strip()) for i in range(T): A,B,C = [(int)(i) for i in input().strip().split()] #巨坑，python里的平方不是^2而是**2 if (A*A - 2*A*B*C)&lt;0: print(0) else: y_up = (1/B)*(A + math.sqrt(A*A-2*A*B*C)) y_down = (1/B)*(A - math.sqrt(A*A-2*A*B*C)) res = get_area(A,B,C,y_up) - get_area(A,B,C,y_down) print(res)#别人的题解import mathsamples_num = int(input()) # 测试的样例数list_A_B_C = []for i in range(samples_num): list_A_B_C.append(input().split(&quot; &quot;))def f(y): return -y * y * y / (6 * A) + y * y / (2 * B) - C * y / Bfor A_B_C in list_A_B_C: A = int(A_B_C[0]) B = int(A_B_C[1]) C = int(A_B_C[-1]) if A * A - 2 * A * B * C &lt; 0: print(0) else: lb = (A - math.sqrt(A * A - 2 * A * B * C)) / B ub = (A + math.sqrt(A * A - 2 * A * B * C)) / B print(f(ub)- f(lb))#定积分，我靠from scipy.integrate import quadfrom sympy import *from sympy.core.add import adddef area_compute(): t = int(input(&#x27;输入次数t:&#x27;)) while t: t -= 1 A,B,C = map(float,(input(&#x27;输入三个数:&#x27;).split())) def func(x): y1 = x ** 2 / 2 / A y2 = (x - C) / B return y2 - y1 x = symbols(&#x27;x&#x27;) expre = x ** 2 / 2 / A - (x - C) / B res = solve(expre, x) # 计算两线交点 if isinstance(res[0], Add): # 解为复数 print(0) continue elif len(res)==1: # 只有一个解 print(0) continue else: fA,err = quad(func,res[0],res[1]) # 用定积分求包含部分的面积 print(fA)area_compute()###############################################################################################################################数据结构基础之一——队列。队列有五种基本操作，插入队尾、取出队首、删除队首、队列大小、清空队列。#现在让你模拟一个队列的操作，具体格式参考输入。#解题思路: 构建队列class my_queue(): #其实隐式继承了object，不然是class my_queue: def __init__(self): super().__init__() self.A = [] def my_push(self, i): self.A.append(i) def my_top(self): if len(self.A) == 0: print(-1) else: print(self.A[0]) def my_pop(self): if len(self.A) == 0: print(-1) else: self.A = self.A[1:] def my_size(self): print(len(self.A)) def my_clear(self): self.A = []if __name__ == &#x27;__main__&#x27;: T = (int)(input().strip()) for i in range(T): Q = (int)(input().strip()) A = my_queue() for j in range(Q): line = input().strip().split() if line[0] == &#x27;PUSH&#x27;: A.my_push((int)(line[1])) elif line[0] == &#x27;TOP&#x27;: A.my_top() elif line[0] == &#x27;POP&#x27;: A.my_pop() elif line[0] == &#x27;SIZE&#x27;: A.my_size() elif line[0] == &#x27;CLEAR&#x27;: A.my_clear() #别人的题解T=int(input())for i in range(T): #有T组测试数据 Q=int(input()) #改组测试数据有Q次操作 q=[] for j in range(Q): s = input().strip().split() if len(s)==2: #入队操作 q.append(s[1]) else: #其他操作 if s[0]==&#x27;TOP&#x27;: #查看队首 if len(q)==0:print(-1) else:print(q[0]) elif s[0]==&#x27;SIZE&#x27;: print(len(q)) elif s[0]==&#x27;POP&#x27;: #出队 if len(q)==0:print(-1) else:del q[0] else: #clear清空操作 while len(q)!=0:q.pop()###############################################################################################################################界面中存在id=jsContainer的节点A，系统会随机生成id为jsLayout的 m行 x n列 表格(m &gt;= 3, n &gt;= 3)，并随机选中一个td节点，请按照如下需求实现bind函数#1、bind 函数为每个td节点绑定click事件，当某个td节点被点击时class变为current，同时以该td为中心的同一行和同一列td节点class变为wrap，具体效果参考以下图片#2、每次click后，请清空所有不需要变动的td节点的class#3、请不要手动调用bind函数#4、当前界面为系统生成 9 * 9 表格，执行 bind 函数，并点击其中td后的效果#5、请不要手动修改html和css#6、不要使用第三方插件#解题思路：JS的题目，不懂#别人的题解&quot;&quot;&quot;function bind() &#123; var tr = document.querySelectorAll(&#x27;tr&#x27;) var td =document.querySelectorAll(&#x27;td&#x27;) for(var i=0;i&lt;td.length;i++)&#123; td[i].addEventListener(&#x27;click&#x27;,function()&#123; for(var i =0;i&lt;td.length;i++)&#123; td[i].className =&quot;&quot; &#125; var trC = this.parentNode.children for(var i =0;i&lt;trC.length;i++)&#123; trC[i].className=&quot;wrap&quot; &#125; for(var i = 0;i&lt;tr.length;i++)&#123; tr[i].children[this.cellIndex].className=&quot;wrap&quot; &#125; this.className=&quot;current&quot; &#125;) &#125;&#125;&quot;&quot;&quot;###############################################################################################################################小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，# 对于字符串中连续的m个相同字符串S将会压缩为[m|S](m为一个整数且1&lt;=m&lt;=100)，# 例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？ #解题思路：正则表达式,永远的神import reclass Solution: def compress(self, s): #r 表示原生字符串, 不加的话/前面还要加/，麻烦，建议加上r match_pattern = re.compile(r&#x27;\\[(\\d+)\\|([a-zA-Z]+)\\]&#x27;) while re.findall(match_pattern, s): s = re.sub(match_pattern, lambda match : match.group(2)*(int)(match.group(1)), s) return s#别人的题解import reclass Solution: def compress(self , s): # write code here while re.findall(r&#x27;\\[(\\d+)\\|([a-zA-Z]+)\\]&#x27;,s): s = re.sub(r&#x27;\\[(\\d+)\\|([a-zA-Z]+)\\]&#x27;,lambda match:match.group(2)*int(match.group(1)),s) return s###############################################################################################################################小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。#小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？#（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） #解题思路：#看到的唯一条件，没有被挡到，即前面没有更大的。# 对时间复杂度要求高，时间换空间, 对最近的更高的建立表格可以加速搜索，把O(n)变成O(1)class Solution: def findBuilding(self , heights ): n = len(heights) #表示每个元素前面的，最近的更高的位置 forward_i = [-1]*n #表示每个元素后面的，最近的更高的位置 backward_i = [-1]*n # 第 k 个表示在 k 前能看到的 res_forward = [0]*n # 第 k 个表示在 k 后能看到的 res_backward = [0]*n # 初始化，给backward和forward数组初始化 if heights[-2] &lt; heights[-1]: #初始化forward[-1]和[-2] forward_i[-2] = n - 1 if heights[1] &lt; heights[0]: #初始化backward[0]和[1] backward_i[1] = 0 res_forward[-2] = res_backward[1] = 1 #初始化res_forward和res_backward for k in range(3, n+1): i = n-k #更新forward表 j = i + 1 while 0 &lt;= j &lt; len(heights) and heights[i] &gt;= heights[j]: #从j开始一直先前找最近的更高的，直到比i高，即找到i最近的更高的 j = forward_i[j] forward_i[i] = j #找到最近的比i+1高的 j = forward_i[i+1] while 0 &lt;= j &lt; n and heights[i+1] &gt;= heights[j]: j = forward_i[j] res_forward[i] = 1 if j&lt;0 else res_forward[j-1]+1 for i in range(2, len(heights)): # 更新backward列表,指向最近的更高的位置 # 根据其指向最快找到比自己高的 j = i - 1 while 0 &lt;= j &lt; n and heights[i] &gt;= heights[j]: j = backward_i[j] backward_i[i] = j #找到最近的比i-1高的 j = backward_i[i-1] while 0 &lt;= j &lt; n and heights[i-1] &gt;= heights[j]: j = backward_i[j] # 从邻居前面看,等价于 从比邻居高的最近的位置之后看 # 多看了一个邻居 res_backward[i] = 1 if j &lt; 0 else res_backward[j+1] + 1 return [i+j+1 for i, j in zip(res_forward, res_backward)]#这样会超时，时间复杂度为n^2，需要利用前后邻居的信息，用空间换时间降低时间复杂度class Solution: def findBuilding(self,heights): left=[] right=[] result=[] for i in range(0,len(heights)): count=1 right=heights[i+1:] left=heights[0:i] if right: count=count+1 max = right[0] for j in range(1,len(right)): if right[j]&gt;max: count=count+1 max = right[j] if left: count = count + 1 left.reverse() max = left[0] for j in range(1,len(left)): if left[j]&gt;max: count=count+1 max = left[j] result.append(count) return result#别人的题解class Solution: def findBuilding(self , heights ): forward_i = [-1 for _ in heights] backward_i = [-1 for _ in heights] # 第 k 个表示在 k 后能看到的 res_forward = [0 for _ in heights] # 第 k 个表示在 k 前能看到的 res_backward = [0 for _ in heights] # 头尾处理 if heights[-2] &lt; heights[-1]: forward_i[-2] = len(heights) - 1 if heights[1] &lt; heights[0]: backward_i[1] = 0 res_forward[-2] = res_backward[1] = 1 for k in range(3, len(heights)+1): i = len(heights) - k #从最后面开始更新，n-1和n-2初始化了。从n-3开始更新 # 更新指向列表,指向最近的更高的位置 # 根据其指向最快找到比自己高的 j = i + 1 while 0 &lt;= j &lt; len(heights) and heights[i] &gt;= heights[j]: #从j开始一直先前找最近的更高的，直到比i高，即找到i最近的更高的 j = forward_i[j] forward_i[i] = j # 更新计数列表，优化子结构，开始迭代 if heights[i+1] &lt; heights[i+2]: # 如果邻居的邻居比邻居高,则能比邻居多看1（因为i+2之后的更高的i和i+1都能看到，低于i+2的都看不到，i只比i+1多看到一个） res_forward[i] = res_forward[i+1] + 1 continue # 根据其指向最快找到比邻居高的 j = forward_i[i+2] #最近的更高的，这个数据结构加速了查找，降低了时间复杂度 while 0 &lt;= j &lt; len(heights) and heights[i+1] &gt;= heights[j]: #本质都是找到最近的比邻居更高的，因为之后的看到与否都一样了 j = forward_i[j] # 从邻居后面看,等价于 从比邻居高的最近的位置之前看 # 多看了一个邻居 res_forward[i] = 1 if j &lt; 0 else res_forward[j-1] + 1 for i in range(2, len(heights)): # 更新指向列表,指向最近的更高的位置 # 根据其指向最快找到比自己高的 j = i - 1 while 0 &lt;= j &lt; len(heights) and heights[i] &gt;= heights[j]: j = backward_i[j] backward_i[i] = j # 更新计数列表 if heights[i-1] &lt; heights[i-2]: # 如果邻居的邻居比邻居高,则能比邻居多看1 res_backward[i] = res_backward[i-1] + 1 continue # 根据其指向最快找到比邻居高的 j = backward_i[i-2] while 0 &lt;= j &lt; len(heights) and heights[i-1] &gt;= heights[j]: j = backward_i[j] # 从邻居前面看,等价于 从比邻居高的最近的位置之后看 # 多看了一个邻居 res_backward[i] = 1 if j &lt; 0 else res_backward[j+1] + 1 return [i+j+1 for i, j in zip(res_forward, res_backward)]###############################################################################################################################在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P 。# 并将P对1000000007取模的结果输出。#解题思路：归并排序求逆序对，本质是分治思想，每部分分别统计逆序对，部分内部排序后不影响部分间逆序对的求解，其实这个过程就是归并排序count =0class Solution: global count def InversePairs(self, data): self.MergeSort(data) return count % 1000000007 def MergeSort(self, list): global count len_list = len(list) if len_list &lt;= 1: return list middle = (int)(len_list/2) left = self.MergeSort(list[ : middle]) right = self.MergeSort(list[middle : ]) #[middle : len_list]也行，[middle : (len_list-1)]是错的，sb l_num = r_num = 0 res = [] while l_num &lt; len(left) and r_num &lt; len(right): if left[l_num] &gt; right[r_num]: #说明出现逆序对 count += len(left) - l_num res.append(right[r_num]) r_num += 1 else: res.append(left[l_num]) l_num += 1 res += left[l_num:] res += right[r_num:] return res#别人的题解count = 0class Solution: def InversePairs(self, data): global count def MergeSort(lists): global count if len(lists) &lt;= 1: return lists num = int( len(lists)/2 ) left = MergeSort(lists[:num]) right = MergeSort(lists[num:]) r, l=0, 0 result=[] while l&lt;len(left) and r&lt;len(right): if left[l] &lt; right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 count += len(left)-l result += right[r:] result += left[l:] return result MergeSort(data) return count%1000000007class Solution: def InversePairs(self, data): #发现可以用归并排序，归并拼接后用计算排序时元素的index变动了多少 #两个有序序列，每个元素移动index数（严格来说不是移动，这里不知怎么表达）之和好像刚好等于逆序对的个数 #我也不知为什么，找了半天发现了这个规律 _,s=self.MergeSort(data) return s%1000000007 def MergeSort(self,data): n=len(data) #递归基 if n==1:return data, 0 #分两半来排序 part1,part2=data[:n//2],data[n//2:] sorted_part1,s1=self.MergeSort(part1) sorted_part2,s2=self.MergeSort(part2) #排序后拼接这两半，拼接后先计数，然后将两个有序序列合并 s,sorted_temp=0,sorted_part1+sorted_part2 #用p、q两个指针指向两段，计算q中每个元素离插入点的index差 p,q,len1,len_all=0,sorted_temp.index(sorted_part2[0]),len(sorted_part1),len(sorted_temp) while p&lt;len1 and q&lt;len_all: #移动p使p成为插入排序的插入点，计算要移动多少个位置 while p&lt;len1: if sorted_temp[q]&lt;sorted_temp[p]: s+=len1-p break p+=1 q+=1 #完成排序，并把排序后的内容回溯给上一级做准备 l=[] p,q=0,sorted_temp.index(sorted_part2[0]) while p&lt;len1 and q&lt;len_all: if sorted_temp[p]&lt;sorted_temp[q]: l.append(sorted_temp[p]) p+=1 else: l.append(sorted_temp[q]) q+=1 if p==len1:l+=sorted_temp[q:] if q==len_all:l+=sorted_part1[p:] return l,s+s1+s2###############################################################################################################################链接：https://www.nowcoder.com/questionTerminal/8fe007e54fc04b5e82089aaa71ba3553?f=discussion#作为程序员的小Q，他的数列和其他人的不太一样，他有2^n个数。#老板问了小Q一共 m次，每次给出一个整数qi(1 &lt;= i &lt;= m), 要求小Q把这些数每2^&#123;qi&#125;分为一组，然后把每组进行翻转，#小Q想知道每次操作后整个序列中的逆序对个数是多少呢？#例如:#对于序列1 3 4 2，逆序对有(4, 2),(3, 2),总数量为2。#翻转之后为2 4 3 1，逆序对有(2, 1),(4, 3), (4, 1), (3, 1),总数量为4。#解题思路: 归并排序求逆序对if __name__ == &#x27;__main__&#x27;: n = (int)(input().strip()) nums_init = [(int)(i) for i in input().strip().split()] if len(nums_init) != (2**n): print(-1) exit() m = (int)(input().strip()) nums_q = [(int)(i) for i in input().strip().split()] if len(nums_q) != m: print(-1) exit() for i in range(m): pass###############################################################################################################################链接：https://www.nowcoder.com/questionTerminal/7cd9a140387e455a972e8fea0e74be2c?f=discussion#由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：#不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。#给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。#解题思路：三个状态：工作锻炼休息，状态转移，联想到动态规划中的状态转移方程,#可以用dp[i][0]、dp[i][1]、dp[i][2]分别表示第i天小Q处于休息、工作、锻炼时最少的休息天数#//1. 选择休息，故天数多1#dp[i][0] = min(dp[i-1][0], min(dp[i-1][1], dp[i-1][2])) + 1; #//2. 不休息，选择工作#dp[i][1] = min(dp[i-1][0], dp[i-1][2]); #//3. 不休息，选择锻炼#dp[i][2] = min(dp[i-1][0], dp[i-1][1]); #//边界：第0天休息天数为0#dp[0][i] = 0 (i = 1, 2, 3) if __name__ == &#x27;__main__&#x27;: n = (int)(input().strip()) company = [(int)(i) for i in input().strip().split()] exercise = [(int)(i) for i in input().strip().split()] #dp[i][0/1/2]为第i天休息/工作/锻炼对应的最少休息天数 dp = [[100000]*3 for i in range(n+1)] dp[0][0] = dp[0][1] = dp[0][2] = 0 for i in range(1, n+1): if company[i-1] == 1: dp[i][1] = min(dp[i-1][0], dp[i-1][2]) if exercise[i-1] == 1: dp[i][2] = min(dp[i-1][0], dp[i-1][1]) dp[i][0] = min(dp[i-1][0], dp[i-1][1], dp[i-1][2]) + 1 res = min(dp[n][0], dp[n][1], dp[n][2]) print(res)#别人的题解n = int(input())a = [int(value) for value in input().split()]b = [int(value) for value in input().split()]result = 0previous_a = 0previous_b = 0 for i in range(n): if a[i] == 0 and b[i] == 0: result += 1 previous_a = previous_b = 0 continue if a[i] == 1 and b[i] == 0: if previous_a == 1: result += 1 previous_a = previous_b = 0 continue else: previous_a = 1 previous_b = 0 continue if a[i] == 0 and b[i] == 1: if previous_b == 1: result += 1 previous_a = previous_b = 0 continue else: previous_a = 0 previous_b = 1 continue if a[i] == 1 and b[i] == 1: if previous_a == 1: previous_a = 0 previous_b = 1 continue if previous_b == 1: previous_b = 0 previous_a = 1 continue if previous_b == 0 and previous_a == 0: continueprint(result)day=int(input())_C=input()c=[int(i) for i in _C.split()]_G=input()g=[int(i) for i in _G.split()] a=[c.copy(),g.copy()] for i in range(day-1): if c[i]==0: a[0][i+1]+=a[0][i] if a[0][i] &gt; a[1][i] else a[1][i] else: a[0][i+1]+=a[1][i] if g[i]==0: a[1][i+1]+=a[0][i] if a[0][i] &gt; a[1][i] else a[1][i] else: a[1][i+1]+=a[0][i] print(day-(a[0][day-1] if a[0][day-1]&gt;a[1][day-1] else a[1][day-1]))############################################################################################################################### https://www.nowcoder.com/questionTerminal/61e1e66e39f348cdb6495de91ac36a41?f=discussion# 小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。#这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。#现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。#解题思路：贪心, 每次都选择可以覆盖到最远距离的地方if __name__ == &#x27;__main__&#x27;: n,L = [(int)(i) for i in input().strip().split()] x_y = [] for i in range(n): x_y.append([(int)(i) for i in input().strip().split()]) x_y.sort(key = lambda x:x[0]) if x_y[0][0] &lt; 0: print(-1) exit() last_reach = 0 #上一次抵达的 max_reach = 0 #可能抵达的 cnt = 1 #一定要记得加上第一个，因为开始计数时已经到了第二个 for i in range(n): if max_reach &gt;= L: break if x_y[i][0] &gt; max_reach: print(-1) exit() if x_y[i][0] &lt;= last_reach and x_y[i][1] &gt; max_reach: max_reach = x_y[i][1] if x_y[i][0] &gt; last_reach: last_reach = max_reach max_reach = max(x_y[i][1], max_reach) cnt += 1 if max_reach &gt;= L: print(cnt) else: print(-1)#别人的题解#贪心选择n,L = map(int,input().split())xy = []for _ in range(n): xy.append(list(map(int,input().split())))xy.sort(key = lambda x : x[0])last = 0#当前已选尾部位置max_reach = 0#当前可选最大到达位置cnt = 1#ans 先加最后一个for i in range(n): if max_reach &gt;= L: break#一定要加，不然初始化1可能会重复 if xy[i][0] &gt; max_reach: print(-1) exit() if xy[i][0]&gt;last:#此时需要更新last last = max_reach#确定选择max_reach cnt+=1 #max_reach = max(xy[i][1],max_reach)#勿忘更新max #continue max_reach = max(xy[i][1],max_reach)#日常更新maxif max_reach &gt;= L: print(cnt)else: print(-1)###############################################################################################################################JZ1#在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。# 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。# 时间复杂度O(m+n)class Solution: def Find(self, target, array): if array == None or array[0] == None: return False row = len(array) col = len(array[0]) i = 0 j = col-1 #这里很精妙，从右上角出发，对于每一步，如果目标更大只有向下走，如果目标更小只有向左走 #因为没有回退，路线最大长度为row+col，复杂度为O(m+n) while(i&gt;=0 and i&lt;row and j&gt;=0 and j&lt;col): if array[i][j] == target: return True elif target &gt; array[i][j]: i+=1 elif target &lt; array[i][j]: j-=1 return False###############################################################################################################################JZ2#请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。import reclass Solution: def replaceSpace(self , s ): pattern = re.compile(r&quot; &quot;) while(re.findall(pattern, s)): s = re.sub(pattern, &quot;%20&quot;, s) return s ###############################################################################################################################JZ3#输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。class Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): res = [] if listNode == None: return [] while listNode: res.append(listNode.val) listNode = listNode.next return res[::-1]###############################################################################################################################JZ14#输入一个长度为的链表，设链表中的元素的值为a_i，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。#如果该链表长度小于k，请返回一个长度为 0 的链表。#解题思路：1. 一般链表题，我们都可以考虑双指针的解题思路# 2. 变成数组，直接切分class Solution: def FindKthToTail(self , pHead , k ): if pHead == None: return None res = [] while pHead: #注意是要返回链表，即头指针，因此数组存储头指针 res.append(pHead) pHead = pHead.next if len(res) &lt; k or k == 0: return None else: return res[-k]class Solution: def FindKthToTail(self , pHead , k ): # write code here #首先初始化两个指针，都指向头节点 first, second = pHead, pHead #当first不存在的时候，直接返回None for i in range(k): if first == None: return None #否则节点存在，开始移动first指针走动k步 first = first.next #当first走完k步后，此时first、second指针开始同步移动，当first移出链表到null的位置，second指针停止移动;此时返回second指针所在位置就是我们要找的倒数最后K个节点值 while first: first = first.next second = second.next return second###############################################################################################################################JZ15#输入一个长度为n链表，反转链表后，输出新链表的表头。#解题思路：双指针法：一般链表题，我们都可以考虑双指针的解题思路class Solution: # 返回ListNode def ReverseList(self, pHead): if pHead == None: return None if pHead.next == None: return pHead cur_node = pHead pre_node = None while cur_node: temp = cur_node.next cur_node.next = pre_node pre_node = cur_node cur_node = temp return pre_node ###############################################################################################################################JZ16#输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。# 解题思路：排序想到归并排序，链表想到双指针class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): if pHead1 == None: return pHead2 elif pHead2 == None: return pHead1 ListSorted = ListNode(0) res = ListSorted while pHead1 and pHead2: if pHead1.val &gt; pHead2.val: ListSorted.next = pHead2 pHead2 = pHead2.next ListSorted = ListSorted.next else: ListSorted.next = pHead1 pHead1 = pHead1.next ListSorted = ListSorted.next if pHead1 == None: ListSorted.next = pHead2 else: ListSorted.next = pHead1 return res.next###############################################################################################################################JZ16#输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），# 请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 # 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出#解题思路：class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): if pHead==None: return None cur = pHead node_map = &#123;&#125; while cur: new_node = RandomListNode(cur.label) node_map[cur] = new_node cur = cur.next cur = pHead while cur: node = node_map[cur] if cur.next: node.next = node_map[cur.next] else: node.next = None if cur.random: node.random = node_map[cur.random] else: node.random = None cur = cur.next return node_map[pHead]###############################################################################################################################JZ36 两个链表的第一个公共结点#输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。# （注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）#解题思路：1. 对于链表，想到双指针（这里注意，画图应该是丫形，因为公共结点后都应该相同）# p1遍历完后跳到p2，这样如果没有公共结点，M+N后都为None结束循环，如果有公共结点那么在M+N-L处有公共结点# 2. 对于寻找公共结点，想到哈希，常规思路就是用一个哈希集合来存储第一个链表遍历后的所有节点；# 接着遍历第二个链表，与哈希集合中的节点进行比较：class Solution: def FindFirstCommonNode(self , pHead1 , pHead2 ): if pHead1 == None or pHead2 == None: return None p1 = pHead1 p2 = pHead2 while p1 != p2: if p1: p1 = p1.next else: p1 = pHead2 if p2: p2 = p2.next else: p2 = pHead1 return p1class Solution: def FindFirstCommonNode(self , pHead1 , pHead2 ): # write code here #首先判断两个链表是否为空 if pHead1 is None or pHead2 is None: return None #定义链表1 的集合 set_A = set() node1, node2 = pHead1, pHead2 #定义两个节点 #遍历链表 1 ，把每个节点加入集合中 while node1: set_A.add(node1) node1 = node1.next #遍历链表2 看当前节点是否在 集合中；如果存在，当前节点就是要找的第一个公共节点；否则继续比较下一个节点。 #这里还要注意，如果遍历完链表 B，发现所有节点都不在集合中，则说明两个链表不相交，返回None。 while node2: if node2 in set_A: return node2 node2 = node2.next return None###############################################################################################################################JZ55 链表中环的入口结点#给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。#解题思路：用哈希setclass Solution: def EntryNodeOfLoop(self, pHead): # write code here if pHead == None: return None set_A = set() while pHead: if pHead in set_A: return pHead else: set_A.add(pHead) pHead = pHead.next return pHead###############################################################################################################################JZ56 删除链表中重复的结点#在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 # 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5#解题思路：删除重复节点，注意这里的重复指的是val一样, 链表想到双指针class Solution: def deleteDuplication(self, pHead): # write code here preHead = ListNode(-1) preHead.next = pHead cur = pHead pre = preHead while cur: if cur.next and cur.val == cur.next.val: cur = cur.next while cur.next and cur.val == cur.next.val: cur = cur.next cur = cur.next pre.next = cur else: pre = cur cur = cur.next return preHead.next###############################################################################################################################JZ5 用两个栈实现队列#用两个栈来实现一个队列，完成 n 次在队列尾部插入整数(push)和在队列头部删除整数(pop)的功能。 # 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。#解题思路：模拟push和pop函数的实现过程，push只需将节点送入stack1，pop如果stack2有元素则只需弹出stack2栈顶的，# stack2没有则将stack1中元素逐一pop进stack2,再弹出stack2栈顶元素class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here return self.stack1.append(node) def pop(self): # return xx if self.stack2: return self.stack2.pop() else: for i in range(len(self.stack1)): temp = self.stack1.pop() self.stack2.append(temp) return self.stack2.pop()###############################################################################################################################JZ20 包含min函数的栈#定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数，并且调用 min函数、push函数 及 pop函数 的时间复杂度都是 O(1)#解题思路： 双栈法：在返回栈中的min值时，如果仅仅使用一个辅助变量min，则其值可能因为min元素被出栈而失效，# 常规的做法是额外添加一个同步栈（min栈），以保存记录之前所有的min值# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack = [] #注意不要随意命名，一些关键字可能会导致意想不到的问题 self.stack_min = [] def push(self, node): # write code here self.stack.append(node) #特殊情况处理，初始值处理 if not self.stack_min: self.stack_min.append(node) elif node &lt; self.stack_min[-1]: self.stack_min.append(node) else: self.stack_min.append(self.stack_min[-1]) def pop(self): # write code here self.stack.pop() self.stack_min.pop() def top(self): # write code here if self.stack: return self.stack[-1] def min(self): # write code here return self.stack_min[-1]###############################################################################################################################JZ21 栈的压入、弹出序列#输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。# 例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。# （注意：这两个序列的长度是相等的）class Solution: def IsPopOrder(self, pushV, popV): j=0 temp = [] for i in range(len(pushV)): temp.append(pushV[i]) while len(temp) &gt; 0 and temp[-1] == popV[j]: j+=1 temp.pop() if len(temp) == 0: return True else: return False###############################################################################################################################JZ44 翻转单词序列#牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，# 有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，# 正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？class Solution: def ReverseSentence(self, s): return &#x27; &#x27;.join(s.split(&quot; &quot;)[::-1])class Solution: def ReverseSentence(self, s): # write code here s_word = s.strip().split() s_word = s_word[::-1] res = &#x27;&#x27; for i in range(len(s_word)): res += s_word[i] if i != (len(s_word)-1): res += &#x27; &#x27; return res###############################################################################################################################JZ64 滑动窗口的最大值#给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。class Solution: def get_max(self, num): size = len(num) max_num = num[0] for i in range(size): max_num = max(num[i], max_num) return max_num def maxInWindows(self, num, size): # write code here if size == 0: return [] n = len(num) res = [] for i in range(n-size+1): slide_window = num[i:i+size] res.append(self.get_max(slide_window)) return res###############################################################################################################################JZ30 连续子数组的最大和#输入一个长度为n的整型数组a，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).#解题思路：典型的动态规划。# dp[n]代表以当前元素为截止点的连续子序列的最大和，如果dp[n-1]&gt;0，dp[n]=A[n]+dp[n-1]，因为当前数字加上一个正数一定会变大；# 如果dp[n-1]&lt;0，dp[n]=A[n]，因为当前数字加上一个负数一定会变小。# 使用一个变量max记录最大的dp值返回即可。class Solution: def FindGreatestSumOfSubArray(self, array): # write code here l=len(array) dp=[array[0]] for i in range(1,l): dp.append(max(dp[-1]+array[i],array[i])) return max(dp)###############################################################################################################################JZ8 跳台阶#一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。#解题思路：动态规划 #由于它可以跳1级台阶或者2级台阶，所以它上一步必定在第n-1,或者第n-2级台阶，也就是说它跳上n级台阶的跳法数是跳上n-1和跳上n-2级台阶的跳法数之和。# dp[n] = dp[n-1]+dp[n-2]class Solution: def jumpFloor(self, number): # write code here if number == 1: return 1 if number == 2: return 2 a = 1 b = 2 c = 0 for i in range(number-2): c = a + b a = b b = c return c###############################################################################################################################JZ7 斐波那契数列################################################################################################################################JZ52 正则表达式匹配#请实现一个函数用来匹配包括&#x27;.&#x27;和&#x27;*&#x27;的正则表达式。模式中的字符&#x27;.&#x27;表示任意一个字符，而&#x27;*&#x27;表示它前面的字符可以出现任意次（包含0次）。 # 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配#解题思路：首先想到双指针，可以用动态规划（因为存在优化子结构），class Solution: def match(self , str , pattern ): m = len(str)+1 n = len(pattern)+1 dp = [[False] * n for _ in range(m)] dp[0][0] = True #*代表0次时 for j in range(1, n): if pattern[j-1] == &#x27;*&#x27;: dp[0][j] = dp[0][j-2] # for i in range(1, m): for j in range(1, n): if pattern[j-1] != &#x27;*&#x27;: dp[i][j] = dp[i-1][j-1] and pattern[j-1] in (str[i-1], &#x27;.&#x27;) else: dp[i][j] = dp[i][j-2] or dp[i-1][j] and pattern[j-2] in (str[i-1], &#x27;.&#x27;) return dp[-1][-1]###############################################################################################################################JZ9 跳台阶扩展问题#一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。#解题思路：跳台阶问题：可以根据最后一次跳的台阶数分解# 设n级台阶有f(n) 种跳法，根据最后一次跳台阶的数目可以分解为最后一次一级，则前面需要跳n−1 级，# 有f(n-1)种跳法；最后一次跳两级，则前面需要跳n- 2级，有f(n-2)种跳法。以此类推 易知，f(n) = 2f(n−1)class Solution: def jumpFloorII(self, number): # write code here ans = 2 ** (number-1) return ans###############################################################################################################################JZ10 矩形覆盖#我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，# 从同一个方向看总共有多少种不同的方法？#解题思路：同样考虑最后一步，因为是2*1，最后一步只有长度为1和长度为2两种，因此f(n) = f(n−1) +f(n−2)class Solution: def rectCover(self, number): # write code here a = 0 b = 1 c = 0 for i in range(number): c = a+b a = b b = c return c ###############################################################################################################################JZ11 旋转数组的最小数字#有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，# 比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。#解题思路：二分#递归；非递归则应该有low、mid、high三个指针class Solution: def minNumberInRotateArray(self, A): if len(A) &lt;= 0: return 0 low = 0 high = len(A)-1 mid = low + (high-low)//2 while low &lt; high: if A[low]&lt;A[high]: return A[low] mid = low + (high-low)//2 if A[low] &lt; A[mid]: low = mid+1 elif A[mid] &lt; A[high]: high = mid else: low+=1 return A[low]###############################################################################################################################JZ38 字符串的排列#输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。#解题思路：递归，就要写出递归方程# ss的排列组合，等价于ss中不重复的字母拼接除去该字母的子集的排列组合#例如对&quot;aab&quot;做递归: func(&quot;aab&quot;) = [&#x27;a&#x27;+func(&quot;ab&quot;), &#x27;b&#x27;+func(&quot;aa&quot;)] # -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): # write code here if len(ss) &lt;= 1: return [ss] results = [] unique_ss = list(set([c for c in ss])) unique_ss.sort() for c in unique_ss: children_results = self.Permutation(ss.replace(c, &quot;&quot;, 1)) results.extend([c+r for r in children_results]) return results###############################################################################################################################JZ72 数字在升序数组中出现的次数#给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数#解题思路：func[12345] = func[123] + func[45]#递归写法，简单，但是递归深度太长会爆内存class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 1: if data[0]==k: return 1 else: return 0 low = 0 high = len(data) mid = low + (high-low)//2 #直接翻译递归方程 count = self.GetNumberOfK(data[low:mid], k) + self.GetNumberOfK(data[mid:high], k) return count#一种非递归写法，但是对于k出现很多次的情况收敛太慢（时间复杂度On）class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 1: if data[0]==k: return 1 else: return 0 count = 0 low = 0 high = len(data) mid = low + (high-low)//2 while low &lt; high: mid = low + (high-low)//2 if k &lt; data[mid]: high = mid elif k &gt; data[mid]: low = mid else: count += 1 del data[mid] high -= 1 return count#但是实际上，解法异常简单，吐class Solution: def GetNumberOfK(self, data, k): num = 0 for i in range (0,len(data)): if data[i] &gt; k : break if data[i] == k: num = num + 1 return num # write code here###############################################################################################################################JZ40 最小的K个数#给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。# 例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here tinput.sort() return tinput[0:k]###############################################################################################################################JZ51 数组中的逆序对#在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。# 输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007count = 0class Solution: def InversePairs(self, data): # write code here global count def MergeSort(data_list): if len(data_list) &lt;= 1: return data_list global count low = 0 high = len(data_list) mid = low + (high-low)//2 left = MergeSort(data_list[low:mid]) right = MergeSort(data_list[mid: high]) l_point = 0 r_point = 0 list_sorted = [] while l_point &lt; len(left) and r_point &lt; len(right): if left[l_point] &gt; right[r_point]: list_sorted.append(right[r_point]) count += len(left)- l_point r_point += 1 else: list_sorted.append(left[l_point]) l_point += 1 list_sorted.extend(left[l_point:]) list_sorted.extend(right[r_point:]) return list_sorted MergeSort(data) return count % 1000000007###############################################################################################################################JZ3 数组中重复的数字#在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。# 也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，# 那么对应的输出是2或者3。存在不合法的输入的话输出-1class Solution: def duplicate(self , numbers ): # write code here numbers = sorted(numbers) n = len(numbers) if n == 0: return -1 for i in range(1,n): if numbers[i-1] == numbers[i]: return numbers[i]###############################################################################################################################JZ41 数据流中的中位数#如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。# 如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，# 使用GetMedian()方法获取当前读取数据的中位数。class Solution: def __init__(self): self.s = [] def Insert(self, num): # write code here self.s.append(num) def GetMedian(self): # write code here self.s.sort() n = len(self.s) if n % 2 == 0: return (self.s[n//2] + self.s[n//2-1]) / 2 else: return self.s[n//2]###############################################################################################################################JZ15 二进制中1的个数#输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。#解题思路：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，# 原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。# xx100 &amp; xx011 = xx000 对负数，n&amp;0xffffffff 可以获得和负数补码相同的的位形式（直接的话无法获得相应位形式）class Solution: def NumberOf1(self, n): # write code here if n == 0: return 0 count = 0 if n &lt; 0: n = n&amp;0xffffffff while n: count += 1 n = n &amp; (n-1) return count#直接获得位形式class Solution: def NumberOf1(self, n): # write code here if n&lt;0: n=n&amp;0xffffffff return bin(n).count(&#x27;1&#x27;) #bin转化为str数组，如‘0b10101’#移位操作class Solution: def NumberOf1(self, n): # write code here if n&lt;0: n=n&amp;0xffffffff count = 0 flag = 1 for i in range(32): if (n &amp; flag): count += 1 flag = flag &lt;&lt; 1 return countclass Solution: def NumberOf1(self, n): # write code here count = 0 if n&lt;0: n=n&amp;0xffffffff count += 1 flag = 1 while flag != 0x80000000: if (n &amp; flag): count += 1 flag = flag &lt;&lt; 1 return count###############################################################################################################################JZ65 不用加减乘除做加法#写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。#解题思路：第一步：相加各位的值，不算进位，二进制每位相加就相当于各位做异或操作；# 第二步：计算进位值，相当于各位做与操作，再向左移一位。# 第三步重复上述两步， 各位相加 ，计算进位值。进位值为0，跳出循环。class Solution: def Add(self, num1, num2): while num2 != 0: sum = num1 ^ num2 num2 = (num1 &amp; num2)&lt;&lt;1 num1 = sum &amp;(0xffffffff) return num1 if num1 &gt;&gt;31 == 0 else num1-2**32 #python负数表示的问题，0b8fffffff第一位为1不认为是负数，有-0b1，因此-2^32###############################################################################################################################JZ16 数值的整数次方#给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。class Solution: def Power(self, base, exponent): # write code here return base**exponent###############################################################################################################################JZ56 数组中只出现一次的两个数字#一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。class Solution: def FindNumsAppearOnce(self , array ): # write code here nums = set() twice_nums = set() for i in array: if i in nums: twice_nums.add(i) else: nums.add(i) res = list(nums - twice_nums) res.sort() return resclass Solution: def FindNumsAppearOnce(self , array ): # write code here res = [] for n in array: if n not in res: res.append(n) else: res.remove(n) res.sort() return res###############################################################################################################################JZ64 求1+2+3+...+n#求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）class Solution: def Sum_Solution(self, n): # write code here #(n+1)n/2 = (n**2+n)/2 res = n**2 + n return res&gt;&gt;1###############################################################################################################################JZ29 顺时针打印矩阵# 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字#解题思路： 简单来说，就是不断地收缩矩阵的边界 定义四个变量代表范围，up、down、left、right#向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错#向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错#向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错#向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here if matrix == None or len(matrix)==0 or len(matrix[0])==0: return [] res = [] up = 0 down = len(matrix)-1 left = 0 right = len(matrix[0])-1 while(True): for col in range(left, right+1): res.append(matrix[up][col]) up += 1 if up &gt; down: break for row in range(up, down+1): res.append(matrix[row][right]) right -= 1 if right &lt; left: break for col in range(left, right+1)[::-1]: res.append(matrix[down][col]) down -= 1 if up &gt; down: break for row in range(up, down+1)[::-1]: res.append(matrix[row][left]) left += 1 if left &gt; right: break return res###############################################################################################################################JZ61 扑克牌顺子# 现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子#解题思路：是顺子的充要条件：ma - mi &lt;= 4，除0外无重复class Solution: def IsContinuous(self, numbers): # write code here num_set = set() ma = 0 mi = 14 for i in numbers: if i in num_set: return False if i == 0: continue ma = max(ma, i) mi = min(mi, i) num_set.add(i) if ma - mi &lt;= 4: return True ###############################################################################################################################JZ67 把字符串转换成整数#将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0# -*- coding:utf-8 -*-class Solution: def StrToInt(self, s): # write code here if s == None or s == &#x27;&#x27; or s == &#x27;+&#x27; or s == &#x27;-&#x27;: return 0 nums = set() for i in range(10): nums.add((str)(i)) for i in s[1:]: if i not in nums: return 0 if s[0] == &#x27;+&#x27;: s = s[1:] return (int)(s) elif s[0] == &#x27;-&#x27;: s = s[1:] return -(int)(s) else: return (int)(s)###############################################################################################################################JZ20 表示数值的字符串# 请实现一个函数用来判断字符串str是否表示数值（包括科学计数法的数字，小数和整数）。# 解题思路：正则表达式class Solution: def isNumeric(self , s): import re #patn = re.compile(&#x27;^\\s*[+-]&#123;0,1&#125;((\\d)+((\\.)(\\d)+)&#123;0,1&#125;|((\\.)(\\d)+)|((\\d)+(\\.)))([eE][+-]&#123;0,1&#125;[\\d]+)&#123;0,1&#125;\\s*$&#x27;) p1 = &#x27;^\\s*[+-]&#123;0,1&#125;&#x27; p2 = &#x27;(((\\d)+)|((\\d)+(\\.))|((\\d)+(\\.)(\\d)+)|((\\.)(\\d)+))\\s*&#x27; p3 = &#x27;([eE][+-]&#123;0,1&#125;(\\d)+)&#123;0,1&#125;\\s*$&#x27; match_pattern = re.compile(p1 + p2 + p3) return match_pattern.match(s) ###############################################################################################################################JZ55 二叉树的深度#输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。class Solution: # 递归函数功能：获取当前节点 root 的深度 def TreeDepth(self, pRoot): # 递归终止条件：递归到叶子节点 if pRoot is None: return 0 # 得到左右子树中较大的子树深度 return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right)) +1###############################################################################################################################JZ77 按之字形顺序打印二叉树#给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）# 解题思路：层序遍历，队列实现，输出时奇数层从左往右，偶数层从右往左# 层序遍历实现模板，背记class Solution: def TreeDepth(self, pRoot): queue = [pRoot] res = [].extend(queue) while queue: tmp = [] for node in queue: if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) queue = tmp res = res.extend(queue) return res # 层序遍历class Solution: def Print(self, pRoot): if pRoot==None: return [] res = [] queue = [pRoot] index = 1 while queue: tmp = [] for i in range(len(queue)): node = queue[0] queue = queue[1:] tmp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if index % 2 == 1: res.append(tmp) else: res.append(tmp[::-1]) index += 1 return res ############################################################################################################################### JZ54 二叉搜索树的第k个结点# 给定一棵结点数为 n 二叉搜索树，请找出其中的第 k 小的TreeNode结点。# 解题思路：二叉搜索树的中序遍历即为从小到大的顺序# 中序遍历模板，背记class Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): if pRoot == None or k &lt;= 0: return None res = [] def in_order(cur): if cur == None: return in_order(cur.left) res.append(cur) in_order(cur.right) in_order(pRoot) if k &gt; len(res): return None else: return res[k-1]# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here stack = [(pRoot, 0)] while stack: node, action = stack.pop() if node is None: continue if action == 0: stack.append((node.right, 0)) stack.append((node, 1)) stack.append((node.left, 0)) else: k -= 1 if k == 0: return node###############################################################################################################################JZ7 重建二叉树# 给定节点数为 n 二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。# 解题思路：先序确定根，然后根据根在中序中进行二分class Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if not pre: return None # 根节点 root = TreeNode(pre[0]) # 根节点在中序遍历中的位置索引 tmp = tin.index(pre[0]) # 递归 构造树的左子树 root.left = self.reConstructBinaryTree(pre[1:tmp+1], tin[:tmp]) # 递归构造树的右子树 root.right = self.reConstructBinaryTree(pre[tmp+1:], tin[tmp+1:]) return root############################################################################################################################### JZ26 树的子结构# 输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here # 递归 def dfs(A, B): # if not B: return True elif not A: return False elif A.val != B.val: return False # 对比A B的左右子树是否相同 return dfs(A.left, B.left) and dfs(A.right, B.right) # 特殊情况 if not pRoot1 or not pRoot2: return False # 递归计算 pRoot1, pRoot2 是否相同/pRoot1的左子树、右子树是否和pRoot2相同 return dfs(pRoot1, pRoot2) or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) class Solution: def __init__(self): self.flag = False def dfs(self, A, B): # if not B: return True elif not A: return False elif A.val != B.val: return False # 对比A B的左右子树是否相同 return self.dfs(A.left, B.left) and self.dfs(A.right, B.right) def HasSubtree(self, pRoot1, pRoot2): # write code here # 特殊情况 if not pRoot1 or not pRoot2: return False def in_order(cur): if cur == None: return in_order(cur.left) if self.dfs(cur, pRoot2): self.flag = True in_order(cur.right) in_order(pRoot1) return self.flag###############################################################################################################################JZ27 二叉树的镜像# 操作给定的二叉树，将其变换为源二叉树的镜像。class Solution: def Mirror(self , pRoot ): # write code here if pRoot == None: return None pRoot.left, pRoot.right = pRoot.right, pRoot.left self.Mirror(pRoot.left) self.Mirror(pRoot.right) return pRoot############################################################################################################################### JZ32 从上往下打印二叉树# 不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。# 层序遍历class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root: return [] res = [] queue = [root] while queue: # 每层 for i in range(len(queue)): node = queue.pop(0) res.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res############################################################################################################################### JZ33 二叉搜索树的后序遍历序列# 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。class Solution: def __init__(self): self.flag = True def VerifySquenceOfBST(self, sequence): # write code here if len(sequence) == 0: return root = sequence[-1] tmp = 0 while sequence[tmp] &lt; root: tmp += 1 for i in sequence[tmp:]: if i &lt; root: self.flag = False self.VerifySquenceOfBST(sequence[:tmp]) self.VerifySquenceOfBST(sequence[tmp:-2]) return self.flag############################################################################################################################### JZ34 二叉树中和为某一值的路径# 输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径。# 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。outlist = []def dg(root, a, expectNumber): a = a + [root.val] #a.append(root.val) 这里不能用append，因为append是改变原来的a, 而+是产生新的a，改变a会使得left之后right的a被改变，+则不会 if not root.left and not root.right: if sum(a) == expectNumber: outlist.append(a) return if root.left: dg(root.left, a, expectNumber) if root.right: dg(root.right, a, expectNumber)class Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if root: dg(root, [], expectNumber) return outlist############################################################################################################################### JZ36 二叉搜索树与双向链表# 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示# 解题思路：根据二叉树的中序遍历，并将遍历结果存储到数组中，再对数组进行遍历生成双向链表# res[i].right = res[i+1]# res[i+1].left = res[i]class Solution: def Convert(self, pRootOfTree): # write code here # 首先进行中序排序 def inorder(root, res): if not root: return None inorder(root.left, res) res.append(root) inorder(root.right, res) res = [] if not pRootOfTree: return None inorder(pRootOfTree, res) if len(res) == 1: return pRootOfTree # 构造双向链表 for i in range(len(res)-1): res[i].right = res[i+1] res[i+1].left = res[i] return res[0]############################################################################################################################### JZ79 平衡二叉树# 输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树class Solution: def __init__(self): self.flag = True def depth(self, root): if not root: return 0 return max(self.depth(root.left), self.depth(root.right)) + 1 def IsBalanced_Solution(self , pRoot: TreeNode) -&gt; bool: # write code here if not pRoot: return True depth_left = self.depth(pRoot.left) depth_right = self.depth(pRoot.right) if abs(depth_left-depth_right) &gt; 1: self.flag = False self.IsBalanced_Solution(pRoot.left) self.IsBalanced_Solution(pRoot.right) return self.flag############################################################################################################################### JZ8 二叉树的下一个结点# 给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。class Solution: def __init__(self): self.in_order_list = [] def in_order(self, root): if not root: return self.in_order(root.left) self.in_order_list.append(root) self.in_order(root.right) def GetNext(self, pNode): # write code here if not pNode: return None tmp = pNode root = pNode while pNode: pNode = pNode.next if pNode: root = pNode self.in_order(root) for i in range(len(self.in_order_list)): if self.in_order_list[i] == tmp: if i+1 &gt;= len(self.in_order_list): return None else: return self.in_order_list[i+1] return None############################################################################################################################### JZ28 对称的二叉树# 给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）# 解题思路：1. 层序遍历，每层分别判断是否对称# 2. 递归，将对称与否变成子树的判断# 递归class Solution: def check(self, a,b): if not a and not b: return True elif not a or not b: return False elif a.val != b.val: return False return self.check(a.left, b.right) and self.check(a.right, b.left) def isSymmetrical(self , pRoot: TreeNode) -&gt; bool: return self.check(pRoot, pRoot)# 层序class Solution: def __init__(self): self.flag = True def for_layer(self, node_list): n = len(node_list) l,r = 0,n-1 while l &lt; r: if node_list[l] != node_list[r]: self.flag = False l += 1 r -= 1 def isSymmetrical(self , pRoot: TreeNode) -&gt; bool: # write code here if not pRoot: return True queue = [pRoot] tmp = TreeNode(1001) while queue: layer = [] for i in range(len(queue)): # 注意是pop(0)而非pop(), 弹出第一个而不是最后一个 node = queue.pop(0) layer.append(node.val) # 注意对空节点的处理，否则会无限循环，这也是一般判断node.left的原因 if node.val != 1001: if node.left: queue.append(node.left) else: queue.append(tmp) if node.right: queue.append(node.right) else: queue.append(tmp) self.for_layer(layer) return self.flag############################################################################################################################### JZ78 把二叉树打印成多行# 给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回# 解题思路：层序遍历class Solution: def Print(self , pRoot: TreeNode) -&gt; List[List[int]]: # write code here if not pRoot: return queue = [pRoot] res = [] while queue: layer = [] for i in range(len(queue)): node = queue.pop(0) layer.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) res.append(layer) return res############################################################################################################################### JZ37 序列化二叉树# 请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树class Solution: def Serialize(self, root): # write code here if not root: return [] queue = [root] res = [] empty_node = TreeNode(101) while queue: for i in range(len(queue)): node = queue.pop(0) if node.val != 101: res.append(node.val) if node.left: queue.append(node.left) else: queue.append(empty_node) if node.right: queue.append(node.right) else: queue.append(empty_node) else: res.append(&#x27;#&#x27;) return res def Deserialize(self, s): # write code here if not s: return None if s[0] == &#x27;#&#x27;: return None root = TreeNode(s.pop(0)) created = [root] while created: toBeCreated = [] for node in created: left = s.pop(0) right = s.pop(0) if left != &#x27;#&#x27;: leftNode = TreeNode(left) toBeCreated.append(leftNode) node.left = leftNode if right != &#x27;#&#x27;: rightNode = TreeNode(right) toBeCreated.append(rightNode) node.right = rightNode created = toBeCreated return root############################################################################################################################### JZ84 二叉树中和为某一值的路径(三)# 给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。#1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点#2.总节点数目为n#3.保证最后返回的路径个数在整形范围内(即路径个数小于2^31-1)import sys # 这里是调整递归深度，python默认递归深度1000，太小了，有时候增加递归深度可以有奇效sys.setrecursionlimit(100000)class Solution: def __init__(self): self.path_num = 0 def from_root(self, root, sum): if not root: return # 因为不要求记录路径，只需要返回路径数，如果要记录路径则更麻烦 sum -= root.val if sum == 0: self.path_num += 1 self.from_root(root.left, sum) self.from_root(root.right, sum) def FindPath(self , root: TreeNode, sum: int) -&gt; int: # write code here if not root: return 0 # 先序遍历，选择出发点 self.from_root(root, sum) self.FindPath(root.left, sum) self.FindPath(root.right, sum) return self.path_num############################################################################################################################### JZ68 在二叉树中找到两个节点的最近公共祖先# 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。class Solution: def __init__(self): self.check1 = False self.check2 = False def check_node(self, node, val1, val2): if not node: return False if node.val == val1: self.check1 = True if node.val == val2: self.check2 = True self.check_node(node.left, val1, val2) self.check_node(node.right, val1, val2) return self.check1 and self.check2 def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -&gt; int: # write code here if not root: return None queue = [root] ancestor = None while queue: for i in range(len(queue)): node = queue.pop(0) self.check1, self.check2 = False, False res = self.check_node(node, o1, o2) if res: ancestor = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return ancestor############################################################################################################################### JZ66 构建乘积数组# 给定一个数组 A[0,1,...,n-1] ,请构建一个数组 B[0,1,...,n-1] ,其中 B 的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]# （除 A[i] 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 B[0] = A[1] * A[2] * ... * A[n-1]，# B[n-1] = A[0] * A[1] * ... * A[n-2]）, 对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。class Solution: def get_B(self, A,j): b = 1 for i in range(len(A)): if i != j: b *= A[i] return b def multiply(self , A: List[int]) -&gt; List[int]: # write code here n = len(A) if n &lt;= 1: return None B = [0]*n for i in range(n): B[i] = self.get_B(A, i) return B# 优化，也可以B[i] = left[i] * right[i]class Solution: def multiply(self, A): # write code here B = [1] *len(A) temp =1 for i in range(1,len(A)): B[i] = B[i-1] *A[i-1] for i in range(len(A)-2,-1,-1): temp *= A[i+1] B[i] *=temp return B############################################################################################################################### JZ50 第一个只出现一次的字符# 在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）class Solution: def FirstNotRepeatingChar(self , str: str) -&gt; int: # write code here repeat_char = set() chars = set() for i in str: if i in chars: repeat_char.add(i) chars.add(i) for i in range(len(str)): if str[i] not in repeat_char: return i return -1############################################################################################################################### JZ5 替换空格# 请实现一个函数，将一个字符串s中的每个空格替换成“%20”。import reclass Solution: def replaceSpace(self , s: str) -&gt; str: # write code here pattern = re.compile(r&quot;(\\s)&quot;) s = re.sub(pattern, &#x27;%20&#x27;, s) return s############################################################################################################################### JZ21 调整数组顺序使奇数位于偶数前面(一)# 输入一个长度为 n 整数数组，数组里面不含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，# 所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。class Solution: def reOrderArray(self , array: List[int]) -&gt; List[int]: # write code here res = [] for each in array: if each % 2 != 0: res.append(each) for each in array: if each % 2 == 0: res.append(each) return res############################################################################################################################### JZ39 数组中出现次数超过一半的数字# 给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。# 例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。# 解题思路：# 1. 可以先遍历一遍数组，在map中存每个元素出现的次数，然后再遍历一次数组，找出众数# 2. 可以先将数组排序，然后可能的众数肯定在数组中间，然后判断一下# 3. 如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。class Solution: def MoreThanHalfNum_Solution(self , numbers: List[int]) -&gt; int: # write code here n = len(numbers) n = n //2 dict = &#123;&#125; for i in numbers: if i in dict.keys(): dict[i] += 1 else: dict[i] = 1 for i in numbers: if dict[i] &gt; n: return i return -1############################################################################################################################### JZ83 剪绳子（进阶版）# 给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），每段绳子的长度记为 k[1],...,k[m] 。# 请问 k[1]*k[2]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。# 由于答案过大，请对 998244353 取模。# 解题思路：首先找规律，发现能凑3就凑3，实在不行就凑2，但是千万不能凑出来1(4拆成两个2)# 但是这就遇到第二个问题，运行超时，于是用快速幂运算，即二分递归import syssys.setrecursionlimit(10000)class Solution: # 快速幂运算 def fast_pow(self, cnt): if cnt == 0: return 1 if cnt == 1: return 3 part = self.fast_pow(cnt//2) if cnt % 2 == 1: # 不要忘了，取模后可以减少运算量 return 3 * part * part % 998244353 else: return part * part % 998244353 def cutRope(self , number: int) -&gt; int: # write code here if number == 2: return 1 if number == 3: return 2 cnt = number // 3 if number % 3 == 0: return self.fast_pow(cnt) % 998244353 elif number % 3 == 1: cnt -= 1 return (2 * 2 * self.fast_pow(cnt)) % 998244353 else: return 2 * self.fast_pow(cnt) % 998244353############################################################################################################################### JZ43 整数中1出现的次数（从1到n整数中1出现的次数）# 输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数class Solution: def get_count(self, n): count = 0 while n &gt;0: if n%10 == 1: count += 1 n = n // 10 return count def NumberOf1Between1AndN_Solution(self , n: int) -&gt; int: # write code here sum_count = 0 for i in range(1,n+1): count = self.get_count(i) sum_count += count return sum_count ############################################################################################################################### JZ45 把数组排成最小的数# 输入一个正整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个import functoolsclass Solution: def PrintMinNumber(self , numbers: List[int]) -&gt; str: # write code here if not numbers: return &#x27;&#x27; min_string = sorted(numbers, key=functools.cmp_to_key(self.cmp)) return &#x27;&#x27;.join(str(s) for s in min_string) def cmp(self,x,y): if str(x)+str(y) &gt; str(y)+str(x): return 1 #可理解为前大于后，就换（1），从小到大 if str(x)+str(y) == str(y)+str(x): return 0 if str(x)+str(y) &lt; str(y)+str(x): return -1# per = itertools.permutations(numbers,len(numbers))# jo = [&#x27;&#x27;.join(str(_) for _ in elem) for elem in per]# return min(jo)# return min([&#x27;&#x27;.join(str(_) for _ in elem) for elem in itertools.permutations(numbers,len(numbers))]) if numbers else &#x27;&#x27;############################################################################################################################### JZ49 丑数# 把只包含质因子2、3和5的数称作丑数（Ugly Number）。# 例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。class Solution: def GetUglyNumber_Solution(self , index: int) -&gt; int: # write code here if index &lt; 1: return 0 i,j,k = 0,0,0 res = [1] for m in range(1, index): tmp = min(res[i]*2, res[j]*3, res[k]*5) res.append(tmp) if tmp == res[i] * 2: i += 1 if tmp == res[j] *3: j += 1 if tmp == res[k] * 5: k += 1 return res[index - 1]############################################################################################################################### JZ74 和为S的连续正数序列# 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,# 他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。# 现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? # 解题思路：1，前缀和 2，滑动窗口class Solution: def FindContinuousSequence(self , sum: int) -&gt; List[List[int]]: # write code here res = [] for i in range(1, sum//2+1): tmp_sum = 0 j = i tmp_list = [] while tmp_sum &lt; sum: tmp_sum += j tmp_list.append(j) j+=1 if tmp_sum == sum: res.append(tmp_list) return res# 滑动窗口class Solution: def FindContinuousSequence(self , sum: int) -&gt; List[List[int]]: # write code here res = [] l, r = 1, 1 tmp_sum = 0 while l &lt;= sum//2: if tmp_sum &lt; sum: tmp_sum += r r += 1 elif tmp_sum &gt; sum: tmp_sum -= l l += 1 else: res.append(range(l, r)) tmp_sum -= l l += 1 return res############################################################################################################################### JZ57 和为S的两个数字# 输入一个递增排序的数组array和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，# 如果无法找出这样的数字，返回一个空数组即可。# 解题思路：双指针法class Solution: def FindNumbersWithSum(self , array: List[int], sum: int) -&gt; List[int]: # write code here i, j = 0, len(array)-1 while i &lt; j: if array[i] + array[j] == sum: return [array[i], array[j]] elif array[i] + array[j] &lt; sum: i += 1 else: j-=1 return []############################################################################################################################### JZ58 左旋转字符串# 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。# 对于一个给定的字符序列 S ，请你把其循环左移 K 位后的序列输出（保证 K 小于等于 S 的长度）class Solution: def LeftRotateString(self , str: str, n: int) -&gt; str: # write code here if not str: return &#x27;&#x27; n = n % len(str) return str[n:] + str[:n]############################################################################################################################### JZ62 孩子们的游戏(圆圈中最后剩下的数)# 每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，# 小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，# 然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0... m-1报数....这样下去....直到剩下最后一个小朋友，# 可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？# 解题思路：约瑟夫环：删除报到k的人，直到只剩下一个人# f(n,m) = (f(n-1,m)+m) %nimport syssys.setrecursionlimit(10000)class Solution: def LastRemaining_Solution(self , n: int, m: int) -&gt; int: # write code here if n &lt;= 1: return 0 return (self.LastRemaining_Solution(n-1, m) + m)%nimport syssys.setrecursionlimit(10000)class Solution: def LastRemaining_Solution(self , n: int, m: int) -&gt; int: # write code here if n &lt;= 1: return 0 # f(n,m) = (f(n-1,m)+m)%n f = 0 for i in range(2, n+1): f = (f+m)%i return f############################################################################################################################### JZ75 字符流中第一个不重复的字符# 请实现一个函数用来找出字符流中第一个只出现一次的字符class Solution: # 返回对应char def __init__(self): self.q = [] self.mq = &#123;&#125; def FirstAppearingOnce(self): # write code here while self.q: top = self.q[0] if self.mq[top] == 1: return top else: self.q.pop(0) return &quot;#&quot; def Insert(self, char): # write code here if char not in self.mq.keys(): self.q.append(char) self.mq[char] = 1 else: self.mq[char] += 1############################################################################################################################### JZ14 剪绳子# 给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），# 每段绳子的长度记为 k[1],...,k[m] 。请问 k[1]*k[2]*...*k[m] 可能的最大乘积是多少？class Solution: def cutRope(self , number: int) -&gt; int: # write code here res = 1 while number &gt; 4: number -= 3 res *= 3 if number == 4: res *= 4 elif number == 3: res *= 3 elif number == 2: res *= 2 return res############################################################################################################################### JZ81 调整数组顺序使奇数位于偶数前面(二)# 输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，# 使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，# 但是时间复杂度和空间复杂度必须如下要求。# 解题思路：双指针法class Solution: def reOrderArrayTwo(self , array: List[int]) -&gt; List[int]: # write code here i, j = 0, len(array)-1 while i &lt; j: while array[i] % 2 == 1: i += 1 while array[j] % 2 == 0: j -= 1 if i &lt; j: array[i], array[j] = array[j], array[i] i += 1 j -= 1 return array############################################################################################################################### #","categories":[],"tags":[{"name":"JZ","slug":"JZ","permalink":"https://zhengluoliudao.github.io/tags/JZ/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zhengluoliudao.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"SQL专题","slug":"SQL专题","date":"2022-01-02T09:47:49.000Z","updated":"2022-01-02T09:48:33.693Z","comments":true,"path":"2022/01/02/SQL专题/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/SQL%E4%B8%93%E9%A2%98/","excerpt":"","text":"SQL专题#1 SQL1 插入记录（一）牛客后台会记录每个用户的试卷作答记录到exam_record表，现在有两个用户的作答记录详情如下： 用户1001在2021年9月1日晚上10点11分12秒开始作答试卷9001，并在50分钟后提交，得了90分； 用户1002在2021年9月4日上午7点1分2秒开始作答试卷9002，并在10分钟后退出了平台。 试卷作答记录表exam_record中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。 该题最后会通过执行SELECT uid, exam_id, start_time, submit_time, score FROM exam_record;来对比结果 123456789insert into exam_recordVALUES (null,1001,9001,&#x27;2021-09-01 22:11:12&#x27;,&#x27;2021-09-01 22:11:12&#x27; +INTERVAL 50 minute,90),(null,1002,9002,&#x27;2021-09-04 07:01:02&#x27;,null,NULL);# 或者insert into exam_record(uid, exam_id, start_time, submit_time, score)values (1001, 9001, &#x27;2021-09-01 22:11:12&#x27;, &#x27;2021-09-01 23:01:12&#x27;, 90),(1002, 9002, &#x27;2021-09-04 07:01:02&#x27;, null, null) #2 SQL2 插入记录（二）现有一张试卷作答记录表exam_record，结构如下表，其中包含多年来的用户作答试卷记录，由于数据越来越多，维护难度越来越大，需要对数据表内容做精简，历史数据做备份。 我们已经创建了一张新表exam_record_before_2021用来备份2021年之前的试题作答记录，结构和exam_record表一致，请将2021年之前的已完成了的试题作答纪录导入到该表。 123insert into exam_record_before_2021(uid, exam_id, start_time, submit_time, score) select uid, exam_id, start_time, submit_time, score from exam_recordwhere year(start_time) &lt; 2021 and submit_time is not null #3 SQL3 插入记录（三）现在有一套ID为9003的高难度SQL试卷，时长为一个半小时，请你将 2021-01-01 00:00:00 作为发布时间插入到试题信息表examination_info（其表结构如下图），不管该ID试卷是否存在，都要插入成功，请尝试插入它。 1234# 使用replace into 而不是 insert into，因为无论存在与否，也可以先删除再插入replace into examination_info(exam_id, tag, difficulty, duration, release_time)values (9003, &#x27;SQL&#x27;, &#x27;hard&#x27;,90 ,&#x27;2021-01-01 00:00:00&#x27;) #4 SQL4 更新记录（一）请把examination_info表中tag为PYTHON的tag字段全部修改为Python。 123update examination_infoset tag = &#x27;Python&#x27;where tag = &#x27;PYTHON&#x27; #5 SQL5 更新记录（二）请把exam_record表中2021年9月1日之前开始作答的未完成记录全部改为被动完成，即：将完成时间改为’2099-01-01 00:00:00’，分数改为0。 12345update exam_record set score = 0 ,# 条件语句里才有and，其他并列成分用，分隔 submit_time = &#x27;2099-01-01 00:00:00&#x27;where start_time &lt; &#x27;2021-09-01 00:00:00&#x27; and submit_time is null #6 SQL6 删除记录（一）请删除exam_record表中作答时间小于5分钟整且分数不及格（及格线为60分）的记录； 12delete from exam_record where timestampdiff(minute, start_time, submit_time) &lt; 5 and score &lt; 60 #7 SQL7 删除记录（二）请删除exam_record表中未完成作答或作答时间小于5分钟整的记录中，开始作答时间最早的3条记录。 1234delete from exam_recordwhere timestampdiff(minute, start_time, submit_time) &lt; 5 or submit_time is NULLorder by start_timelimit 3 #8 SQL8 删除记录（三）请删除exam_record表中所有记录，并重置自增主键。 123#truncate table 在功能上，与不带where字句的delete语句相同；二者均删除表中的全部行，但truncate table 比delete速度更快，且#使用的系统和事务日志资源少。 truncate 删除表中的所有行，但表的结构及其列，约束，索引等保持不变。新行标识所用的计数值重置为该列#的种子。如果想保留标识计数值，请使用delete 。如果要删除表定义及其数据，请使用drop table 语句。truncate table exam_record #9 SQL9 创建一张新表请创建一张优质用户信息表user_info_vip，表结构和用户信息表一致。 12345678910# 注意default charset，default值，not null uniquecreate table user_info_vip( id int(11) primary key auto_increment comment &#x27;自增ID&#x27;, uid int(11) not null unique comment &#x27;用户ID&#x27;, nick_name varchar(64) comment &#x27;昵称&#x27;, achievement int(11) default 0 comment &#x27;成就值&#x27;, level int(11) comment &#x27;用户等级&#x27;, job varchar(32) comment &#x27;职业方向&#x27;, register_time datetime default current_timestamp comment &#x27;注册时间&#x27;)default charset = utf8 #10 SQL10 修改表请在用户信息表，字段level的后面增加一列最多可保存15个汉字的字段school；并将表中job列名改为profession，achievement的默认值设置为0。 123alter table user_info add school varchar(15) after level;alter table user_info change job profession varchar(10);alter table user_info modify achievement int(11) default 0; #11 SQL11 删除表现在随着数据越来越多，存储告急，请你把很久前的（2011到2014年）备份表都删掉（如果存在的话）。 1234drop table if exists exam_record_2011, exam_record_2012, exam_record_2013, exam_record_2014 #12 SQL12 创建索引现有一张试卷信息表examination_info，其中包含各种类型试卷的信息。为了对表更方便快捷地查询，需要在examination_info表创建以下索引，规则如下： 在duration列创建普通索引idx_duration、在exam_id列创建唯一性索引uniq_idx_exam_id、在tag列创建全文索引full_idx_tag。 1234567891011create index idx_duration on examination_info (duration);create unique index uniq_idx_exam_id on examination_info (exam_id);create fulltext index full_idx_tag on examination_info (tag); # 也可以用alter修改表格alter table examination_info add index idx_duration(duration);alter table examination_info add unique index uniq_idx_exam_id(exam_id); alter table examination_info add fulltext index full_idx_tag(tag); #13 SQL13 删除索引请删除examination_info表上的唯一索引uniq_idx_exam_id和全文索引full_idx_tag。 123456drop index uniq_idx_exam_id on examination_info;drop index full_idx_tag on examination_info;#或者alter table examination_info drop index uniq_idx_exam_id;alter table examination_info drop index full_idx_tag; #14 SQL14 SQL类别高难度试卷得分的截断平均值牛客的运营同学想要查看大家在SQL类别中高难度试卷的得分情况。 请你帮她从exam_record数据表中计算所有用户完成SQL类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。保留一位小数。 123456select ei.tag, ei.difficulty, round((sum(er.score) - max(er.score) - min(er.score))/(count(er.score)-2), 1)from examination_info ei join exam_record eron ei.exam_id = er.exam_idwhere ei.tag = &#x27;SQL&#x27; and ei.difficulty = &#x27;hard&#x27; and er.score is not null #15 SQL15 统计作答次数有一个试卷作答记录表exam_record，请从中统计出总作答次数total_pv、试卷已完成作答数complete_pv、已完成的试卷数complete_exam_cnt。 123456select count(id) total_pv, count(score) complete_pv, # 可以添加条件语句，用and连接count(distinct exam_id and score is not null) complete_exam_cntfrom exam_record #16 SQL16 得分不小于平均分的最低分请从试卷作答记录表中找到SQL试卷得分不小于该类试卷平均得分的用户最低得分。 123456789select min(er.score) min_score_over_avgfrom exam_record er join examination_info ei on er.exam_id = ei.exam_idwhere ei.tag = &#x27;SQL&#x27; and er.score &gt;= (select avg(score) from exam_record a join examination_info b on a.exam_id = b.exam_idwhere b.tag = &#x27;SQL&#x27;) #17 SQL17 平均活跃天数和月活人数请计算2021年每个月里试卷作答区用户平均月活跃天数avg_active_days和月度活跃人数mau 1234567891011# 注意，%Y是2021，%y是21， %M是July, %m是07, date_format可以按需求提取时间select date_format(start_time, &#x27;%Y%m&#x27;) month,# count(a,b)按照两个参数都不同的进行统计数量，不要忘了distinctround(count(distinct uid, date_format(start_time, &#x27;%Y%m%d&#x27;))/count(distinct uid), 2) avg_active_days, count(distinct uid) maufrom exam_recordwhere submit_time is not nulland year(submit_time) = 2021 # group by不要和order by弄混了group by date_format(start_time, &#x27;%Y%m&#x27;) #18 SQL18 月总刷题数和日均刷题数请从中统计出2021年每个月里用户的月总刷题数month_q_cnt 和日均刷题数avg_day_q_cnt，以及该年的总体情况 1234567select coalesce(DATE_FORMAT(submit_time, &#x27;%Y%m&#x27;), &quot;2021汇总&quot;) submit_month,count(score) month_q_cnt, round(count(score)/max(day(last_day(submit_time))), 3) avg_day_q_cntfrom practice_record where year(submit_time) = 2021group by DATE_FORMAT(submit_time, &#x27;%Y%m&#x27;)with rollup #19 SQL19 未完成试卷数大于1的有效用户请统计2021年每个未完成试卷作答数大于1的有效用户的数据（有效用户指完成试卷作答数至少为1且未完成数小于5），输出用户ID、未完成试卷作答数、完成试卷作答数、作答过的试卷tag集合，按未完成试卷数量由多到少排序。 123456789101112select uid, count(if(submit_time is null,1,null)) as incomplete_cnt, count(if(submit_time is not null,1,null)) as complete_cnt, group_concat(distinct concat_ws(&#x27;:&#x27;,date(start_time),tag) separator &#x27;;&#x27;) as detailfrom exam_record aleft join examination_info bon a.exam_id=b.exam_idwhere year(start_time)=2021group by uidhaving (count(if(submit_time is null,1,null)) between 2 and 4)and (count(if(submit_time is not null,1,null)) &gt;= 1)order by incomplete_cnt desc; #20 SQL20 月均完成试卷数不小于3的用户爱作答的类别请从表中统计出 月均完成试卷数不小于3的用户爱作答的类别及作答次数，按次数降序输出 123456789101112131415select tag, count(tag) tag_cntfrom exam_record er join examination_info eion er.exam_id = ei.exam_idwhere uid in (select uid from exam_record where submit_time is not null group by uid having count(*)/count(distinct date_format(start_time, &#x27;%Y%m&#x27;)) &gt;= 3)group by tag order by tag_cnt desc #21 SQL21 试卷发布当天作答人数和平均分请计算每张SQL类别试卷发布后，当天5级以上的用户作答的人数uv和平均分avg_score，按人数降序，相同人数的按平均分升序， 1234567891011121314select er.exam_id, count(distinct er.uid) uv, round(avg(er.score), 1) avg_scorefrom examination_info ei join exam_record er on ei.exam_id = er.exam_idwhere er.uid in (select uid from user_info where level &gt; 5) and ei.tag = &#x27;SQL&#x27;and DATE_FORMAT(ei.release_time, &#x27;%Y%m%d&#x27;) = DATE_FORMAT(er.submit_time, &#x27;%Y%m%d&#x27;)# group by即分组，之后的count等聚集操作在每组内进行，即每个group by er.exam_idorder by uv desc, avg_score #22 SQL22 作答试卷得分大于过80的人的用户等级分布统计作答SQL类别的试卷得分大于过80的人的用户等级分布，按数量降序排序 12345678910select u_i.level, count(distinct u_i.uid ) level_cnt from exam_record e_r join examination_info e_i on e_r.exam_id = e_i.exam_id join user_info u_i on e_r.uid = u_i.uid where e_i.tag = &#x27;SQL&#x27; and score &gt; 80 group by level order by level_cnt desc, level desc #23 SQL23 每个题目和每份试卷被作答的人数和次数请统计每个题目和每份试卷被作答的人数和次数，分别在试卷区和题目区按uv &amp; pv降序显示 123456789101112131415select * from(select exam_id as tid, count(distinct uid) as uv, count(*) as pvfrom exam_recordgroup by exam_idorder by uv desc, pv desc) examunionselect * from(select question_id as tid, count(distinct uid) as uv, count(*) as pvfrom practice_recordgroup by question_idorder by uv desc, pv desc) practice #24 SQL24 分别满足两个活动的人为了促进更多用户在牛客平台学习和刷题进步，我们会经常给一些既活跃又表现不错的用户发放福利。假使以前我们有两拨运营活动，分别给每次试卷得分都能到85分的人（activity1）、至少有一次用了一半时间就完成高难度试卷且分数大于80的人（activity2）发了福利券。 现在，需要你一次性将这两个活动满足的人筛选出来，交给运营同学。请写出一个SQL实现：输出2021年里，所有每次试卷得分都能到85分的人以及至少有一次用了一半时间就完成高难度试卷且分数大于80的人的id和活动号，按用户ID排序输出。 1","categories":[],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"https://zhengluoliudao.github.io/tags/DataBase/"},{"name":"SQL","slug":"SQL","permalink":"https://zhengluoliudao.github.io/tags/SQL/"}]},{"title":"linux命令","slug":"linux命令","date":"2022-01-02T09:46:55.000Z","updated":"2022-01-02T09:47:52.011Z","comments":true,"path":"2022/01/02/linux命令/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/linux%E5%91%BD%E4%BB%A4/","excerpt":"","text":"ls全称list，默认列出当前目录，所以可以列出其他目录或者路径下的文件信息或者目录信息。 pwdPrint Working Directory, 打印当前工作目录的完整路径名 touchchange file timestamps，将每个文件的访问和修改时间更新为当前时间。除非提供-c或-h，否则将不存在的FILE参数创建为空。 cat&amp;tac将FILE或标准输入连接到标准输出。 tac命令与cat命令展示内容相反（tac从最后一行输出到第一行），不能带行号输出 mkdir如果目录不存在，则创建目录 cdChange Directory，切换当前目录至指定目录 rm&amp;rmdirRemove Directory，rm -rf / mv移动目录或者文件到指定目录下，同时具有重命名的功能。 cpcopy，将source_file的内容复制到target_file echo将任何指定的操作数打印到标准输出（就是print） head&amp;tail显示每个指定文件或标准输入（如果未指定文件）的前几行或字节 more&amp;lessmore流式读取文件内容 less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件 1查看日志常用more/less，也常用head/tail wc统计文件中包含的行数，字数和字节数 date &amp; caldate根据指定的选项，打印日期和时间。 cal命令可以用来显示公历（阳历）日历 which搜索某个系统命令的位置，查看该命令所在的文件位置 whereis只能用于程序名的搜索，搜索文件名中包含该字符串的文件 nl将输出的文件内容自动的加上行号（对行号的显示设计比 cat -n丰富） ps查看进程有关信息，ps -ef | grep kill&amp;killall kill -9 pid 表示强制杀死该进程，kill -15更优雅，给了进程善后的机会 findfind /Users -name “*.log” -print 查找/user目录下所有以.log结尾的文件 find /home/midou/logs// -mtime +30 -name “*.log.gz” -exec rm -rf {} ; 删除一个月之前的日志 grep搜索任何给定的输入文件，选择一个或多个与模式匹配的行 123456$grep &#x27;20:[1-5][0-9]:&#x27; *.log #匹配当前目录下搜索log日志中，20点的日志$grep &#x27;20:[1-5][0-9]&#x27; 1.log 2.log 3.log #指定在这三个文件中查找#grep规则是支持正则表达式的$ps -ef|grep java #查找所有java进程$grep &#x27;20:[1-5][0-9]:&#x27; *.log | grep -v &#x27;20:[3-4][0-9]:&#x27; # -v反向选择，相当于过滤$grep &#x27;ab|bc&#x27; *.log #支持|语法，匹配含有ab或者bc的文本行 cut序从每个文件中剪切出每行的选定部分打印输出 123$cut -c-10 tmp.txt #cut tmp.txt文件的前10列$cut -c3-5 tmp.txt #cut tmp.txt文件的第3到5列$cut -c3- tmp.txt #cut tmp.txt文件的第3到结尾列 diff比较两个文件的不同 diff testA.txt testB.txt tar&amp;gzip用来压缩和解压文件 12345678#打包 tar -cvf 包名 文件名$tar -cvf test.tar test.txt #解包 tar -xvf 包名 $tar -xvf test.tar#压缩 tar -czvf 包名 文件名$tar -czvf test.tgz test.txt#解压 tar -xzvf 包名$tar -xzvf test.tgz du显示指定文件使用情况 12345678910#查看指定文件大小$du -h filename#展示该目录下所有文件大小，大小以可读方式展示$du -h /#展示当前目录大小$du -sh#展示当前目录下每个目录大小$du -sh ./#显示所有文件的大小，以可读方式展示$du -ah / df展示磁盘使用情况 123456789#展示当前系统磁盘使用情况，以可读的方式展示$ df -hFilesystem Size Used Avail Capacity iused ifree %iused Mounted on/dev/disk1s1 234Gi 78Gi 151Gi 35% 1376436 9223372036853399371 0% /devfs 208Ki 208Ki 0Bi 100% 720 0 100% /dev/dev/disk1s4 234Gi 4.0Gi 151Gi 3% 4 9223372036854775803 0% /private/var/vmmap -hosts 0Bi 0Bi 0Bi 100% 0 0 100% /netmap auto_home 0Bi 0Bi 0Bi 100% 0 0 100% /home/dev/disk3s1 290Mi 271Mi 17Mi 94% 2156 9223372036854773651 0% /Volumes/Sourcetrail_2019_4_102 lsof列出当前系统打开文件 123456789#显示当前系统打开的文件$lsof #查看某个文件的相关进程 lsof 文件名$ lsof /bin/bashCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEbash 9430 midou txt REG 253,1 960392 140072 /usr/bin/bash#查看某个用户打开的文件信息$lsof -u username#列出某个程序进程所打开的文件信息 ping向主机发送报文，常用于测试本机与其他机器之间的网络通信 123456789#显示当前系统打开的文件$lsof #查看某个文件的相关进程 lsof 文件名$ lsof /bin/bashCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEbash 9430 midou txt REG 253,1 960392 140072 /usr/bin/bash#查看某个用户打开的文件信息$lsof -u username#列出某个程序进程所打开的文件信息 netstat显示与端口连接相关的内容 12345678910111213141516171819202122#列出所有端口使用情况$netstat -a#显示当前UDP连接状况$netstat -nu#显示UDP端口号的使用情况$netstat -apu#显示网卡列表$netstat -i#显示网络统计信息$netstat -s#显示监听的套接口$netstat -l#显示所有已建立的有效连接$netstat -n#显示关于路由表的信息$netstat -r#列出所有 tcp 端口$netstat -at#找出程序运行的端口$netstat -ap | grep ssh#在 netstat 输出中显示 PID 和进程名称$netstat -pt ifconfig展示或配置网络设备信息 123456789101112#显示网络设备信息$ifconfig#启动关闭指定网卡$ifconfig eth0 up$ifconfig eth0 down#配置IP地址$ifconfig eth0 ip#启用和关闭ARP协议$ifconfig eth0 arp$ifconfig eth0 -arp#设置最大传输单元$ifconfig eth0 mtu 1500 hostname查看主机ip，DNS等信息 12#查看主机ip,这个命令我最推荐的一个用法就是查看主机ip，之前我一直用ifconfig$hostname -i traceroute跟踪获取从IP网络到给定主机的路由信息包 123456789101112#traceroute 一下百度，看下数据包的路由途径$ traceroute www.baidu.comtraceroute: Warning: www.baidu.com has multiple addresses; using 183.232.231.172traceroute to www.baidu.com (183.232.231.172), 64 hops max, 52 byte packets 1 192.168.0.1 (192.168.0.1) 6.059 ms 0.879 ms 0.843 ms 2 192.168.1.1 (192.168.1.1) 1.305 ms 2.232 ms 2.167 ms 3 10.104.0.1 (10.104.0.1) 5.085 ms 5.534 ms 4.466 ms 4 221.131.253.13 (221.131.253.13) 4.633 ms 11.736 ms 4.199 ms 5 117.148.181.1 (117.148.181.1) 4.544 ms * 112.11.233.49 (112.11.233.49) 13.384 ms 6 221.183.47.165 (221.183.47.165) 6.591 ms 6.643 ms 221.183.47.161 (221.183.47.161) 5.591 ms route123456789#显示当前路由$route#屏蔽一条路由$route add -net 224.0.0.0 netmask 240.0.0.0 reject#删除路由记录$route del -net 224.0.0.0 netmask 240.0.0.0#删除和添加设置默认网关$route del default gw 192.168.0.100$route add default gw 192.168.0.100 wget用于从Web非交互式下载文件 12#下载某个文件，wget 文件的地址$wget https://blog.csdn.net/qq_38646470 vmstat查看虚拟内存使用情况 报告有关进程，内存，页面调度，块IO，陷阱，磁盘和cpu活动的信息。 12345#显示虚拟内存情况$ vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 23764228 507816 36953948 0 0 3 5 0 0 1 0 98 0 0 free查看内存使用情况 显示系统中可用和可用的物理内存和交换内存的总量，以及内核使用的缓冲区和高速缓存 12345678910#显示内存使用情况$ free total used free shared buff/cache availableMem: 65808884 4582700 23754736 684 37471448 60913052$ free -h total used free shared buff/cache availableMem: 62G 4.4G 22G 684K 35G 58GSwap: 0B 0B 0B#周期性的查询内存使用信息，5s执行一次$ free -s 5 top查看正在运行的系统的动态实时视图。 第一行，任务队列信息；第二行，Tasks — 任务（进程）；第三行，cpu状态信息；第四行,内存状态；第五行，swap交换分区信息；第七行以下：各进程（任务）的状态监控 1234567891011121314151617#top$ toptop - 00:56:07 up 149 days, 14:40, 1 user, load average: 0.00, 0.02, 0.05Tasks: 254 total, 1 running, 253 sleeping, 0 stopped, 0 zombie%Cpu(s): 1.4 us, 0.3 sy, 0.0 ni, 98.3 id, 0.1 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 65808884 total, 23749772 free, 4586160 used, 37472952 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 60909608 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND24397 dongshan 20 0 17.972g 688312 13728 S 6.2 1.0 7:09.11 java 1 root 20 0 42140 3684 1476 S 0.0 0.0 23:58.88 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:05.47 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:16.06 ksoftirqd/0 5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 7 root rt 0 0 0 0 S 0.0 0.0 1:27.00 migration/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh 9 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcuob/0 sarsar（System Activity Reporter系统活动情况报告）是目前 Linux 上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、 系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://zhengluoliudao.github.io/tags/linux/"}]},{"title":"秒杀项目","slug":"面试项目","date":"2022-01-02T09:44:48.000Z","updated":"2022-01-02T09:46:28.257Z","comments":true,"path":"2022/01/02/面试项目/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"秒杀项目问题：高并发，超卖，恶意请求，链接暴露，数据库 解决方案：服务单一职责（微服务+分布式+单独数据库），秒杀链接加盐(url动态化)，Redis集群（主从同步、读写分离），Nginx（多个Tomcat负载均衡），资源静态化，按钮控制（点击前后置灰），限流，库存预热（提前将库存加载到redis，lua脚本），限流&amp;降级&amp;熔断&amp;隔离，削峰填谷（消息队列） 隔壁数仓组打算搞flink的实时数仓，美团用的OLAP引擎是doris，可以投其所好学一学，语法跟MySQL一毛一样，原理不同罢了 Redis基本数据类型：String、Hash、List、Set、SortedSet，HyperLogLog、Geo、Pub/Sub，BloomFilter，RedisSearch，Redis-ML redis为什么快： 12345完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；使用多路I/O复用模型，非阻塞IO；使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； 持久化： RDB：RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。 AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog。 对比：RDB适合冷备，AOF适合热备，RDB对性能影响比AOF小，恢复快，但是数据完整性不如AOF 高可用性：哨兵集群， 1234集群监控：负责监控 Redis master 和 slave 进程是否正常工作。消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址 主从同步：master生成RDB快照，发送给slave 过期策略：定期删除+惰性删除 内存淘汰机制： FIFO 淘汰最早数据、LRU 剔除最近最少使用、和 LFU 剔除最近使用频率最低的数据 对比MemCache和Redis： 1234Redis 采用单线程模式处理请求，避免线程上下文切换产生的代价Redis 支持持久化除了 K-V 之外，还支持多种数据格式Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务 缓存更新：失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。 缓存穿透： 12对不存在的用户，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。 缓存击穿：缓存击穿，就是某个热点数据失效时，大量针对这个数据的请求会穿透到数据源 123可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效 缓存雪崩：产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB 12使用快速失败的熔断策略，减少 DB 瞬间压力；使用主从模式和集群模式来尽量保证缓存服务的高可用。","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"https://zhengluoliudao.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"秒杀","slug":"秒杀","permalink":"https://zhengluoliudao.github.io/tags/%E7%A7%92%E6%9D%80/"}]},{"title":"腾讯面试","slug":"腾讯面试","date":"2022-01-02T09:42:18.000Z","updated":"2022-01-02T09:44:05.224Z","comments":true,"path":"2022/01/02/腾讯面试/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/","excerpt":"","text":"问题汇总 acid, 原子性 不可分割，一致性 前后一致，隔离性 不可见，持久性 一旦提交持久保存 tcp三次握手和四次挥手，为什么要四次挥手。 三次握手：syn, syn+ack, ack 四次挥手：fin, ack, fin, ack 三次握手才可以阻止历史重复连接的初始化（主要原因）。客户端需要根据syn+ack判断和服务器建立的是不是历史连接 三次握手才可以同步双方的初始序列号。同步序列号，客户端才知道下一次应该用哪个序列号 三次握手才可以避免资源浪费。服务器不知道客户端是否收到了ack，那么如果客户端发了多个syn，服务器就要建立多个连接，浪费资源 服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。 进程与线程。进程就是一次把数据加载到内存，时间片切分导致多进程，即并发。 并发是多个任务在一个处理器核上进行时间片分片；并行是多个处理器核同时运行多个任务 线程是进程当中的一条执行流程。线程之间可以并发运行且共享相同的地址空间 线程比进程不管是时间效率，还是空间效率都要高。线程创建快，终止快，切换快，数据传递快。线程是调度的基本单位，而进程则是资源拥有的基本单位。 MySQL所有的锁 s锁（共享锁）能读 x锁（互斥锁）能写 2PL IS IX SIX 多粒度锁协议 范式 第一范式 属性不可分第二范式 每个非主属性完全函数依赖于候选键第三范式 每个非主属性不传递函数依赖于候选键BCNF 任意主属性都完全函数依赖于候选键 事务隔离级别。 read uncommitted。可以看到未提交事务 read committed。只能看到已提交事务的改变，面对不可重复读的问题 可重复读。事务执行过程中会看到相同的行，mysql的默认隔离级别。面对幻读的问题，即新插入行仍能看到，MVCC解决 这个问题 可串行化。强制事务排序，使之不可能相互冲突，但是效率低 脏读，不可重复读，幻读 排序算法 http1.0和http1.1(https)和2.0的区别； tcp和udp的区别； HashMap怎样避免减少冲突 进程间通信： 消息传递：消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行通信；消息传递分为发送方和接收方 先进先出队列：先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式 管道：管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工，需要另外一个管道。 直接通信：在这种进程通信的方式中，进程与进程之间只存在一条链接，进程间要明确通信双方的命名。 间接通信：间接通信是通信双方不会直接建立连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中放置消息，并且可以从中删除消息，以此达到进程间通信的目的。 消息队列：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程之间提供全双工的通信连接。 共享内存：共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。 协程：协程运行在线程之上，在线程的基础之上通过分时复用的方式运行多个协程；协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。协程只有和异步IO结合起来才能发挥出最大的威力。 Redis： MySQL引擎：innodb和myisam的区别： InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； InnoDB是聚簇索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。 MyISAM是非聚簇索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。 InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件） linux定时执行脚本，crontab命令 消息队列：异步，削峰，解耦 实战： 一面面试问到的：共享内存，B+树，平衡二叉树和二叉查找树，进程间通信，操作系统，互斥锁没拿到cpu是等着还是休眠， 把字符串倒过来，时间空间要求极低 总结：腾讯面试在把问题问细，深挖一个简单的问题，算法上要求简单问题时间空间复杂度降到最低，重视知识的应用场景， 二面面试问到的： linux命令，定时执行，git指令fetch和pull的区别，协程，docker，go语言，前端JS，输入重定向，管道 三面问到的： python装饰器，linux free/vmstat top，异步IO，kafka，redis的内存回收机制，mysql一万条数据怎么查询，索引什么情况失效，case when 字节面试： 一面：共享内存，http遇到大量超时，智能指针 ########################################################################################### 三面面经收集3.技术三面 9.26 30min 腾讯三面一般都是部门总监，问的问题一般都是项目、架构、设计之类的。 1.自我介绍 2.之前实习为什么没留用？ 3.你怎么看待之前leader对你的评价呢？ 4.你认为你在PCG实习的这个项目中，有哪些亮点和挑战？ 5.你项目中的ES是直接拿来用的吗？（回答：不是）那你介绍下你做了哪些优化和配置的工作？ 6.用什么语言？（答：golang）golang的协程介绍下？ 7.介绍下PCG内部的那个…(我怕泄露机密，就不写出来了） 8.反问 二面：只面了30分钟，感觉面试官挺忙的 http1.0和2.0的区别； tcp和udp的区别； go中make和new的区别； 进程、线程、协程 go的接口机制？ go通道是如何实现的； 三面：三面印象中是最难的，上来就问我简历中提到了区块链，问我区块链是什么，然后抓住我做的一个项目问，问得比较细； go协程是如何实现的。 如何控制协程创建的数量？ 协程之间通信机制？ 项目中用到了几个通道，具体是如何使用的？ 你做的项目，并发量有多大。 考虑你的项目出现了问题怎么办。 mysql的数据引擎？innodb和myisam的区别？ 如何保证mysql数据并发安全？ 项目部署在哪里？有没有上线？ linux熟悉吗？都熟悉哪些操作？如何查找一个指定名称的进程？ linux如何修改配置信息？ go 的垃圾回收机制？ 了解过哪些新出的云产品服务？答了个k8s 用go还做过哪些其他项目？ go web开发的框架有哪些？ docker了解过吗？ 最近看的书？ 二面 30 min:全程聊项目，所以问题只记得几个 项目中遇到过什么困难呢？是怎么解决的呢？ 你是怎么去做算法调研的？你了解实际应用中用了哪些算法吗？ 为什么要用python？用了哪些包呢？ 讲一个项目里数据处理的流程吧。 为什么用clickhouse？你了解其他数据库吗？ 用了解不了解分布式的一些东西，我就直接说了自己不了解也没有继续往下问 2021.4.2 腾讯TEG一面 岗位被TEG-基础架构部捞成运营开发了 消息队列怎么保证消息不被重复消费，怎么保证顺序性 redis有哪些持久化的方式redis在项目中起到哪些作用介绍一下Redis分布式锁 了解过协程吗什么是用户态，什么是内核态？为什么要这么设计？ 说一下常用的http方法那么有什么场景下，在尽量遵循RFC规范下，不得不用post去代替get？ 手撕代码，ide屏幕共享：有一个会议室，0-1000是一个固定的时间段，然后给出在这个时间段内的一些会议时间，表示这个时间段占用了这个会议室（那么显然给出的占用时间之间不会发生冲突）。现在给你一个会议开始时间，和会议时长。如果这个时间段能开会，那么直接返回这个是开始时间；如果这个时间段不能开会，那么不得不调整开始时间，返回需要付出最小调整代价的开始时间（也就是左边和右边最近的时间）；如果怎么调整也无法开会，返回-1 2021.4.9 腾讯TEG二面 介绍下项目，介绍下自己的技术栈 平常怎么学习的 redis过期key的删除策略redis淘汰机制（或者操作系统中有哪些内存淘汰机制）LRU是怎么实现的redis中的k-v结构是怎么存的 消息队列怎么保证有序性和持久性 64位机器int类型是多少位？Malloc函数会分配物理内存吗？那在什么时候才会分配？了解内存泄露吗 什么时候会发生StackOverFlow HashMap讲一下 手撕：字符串转整数，尽可能考虑边界条件 怎么自己生成Integer.MAX_VALUE ########################################################################################### 二面面经收集1.自我介绍 2.算法题：LIS的序列值求解 没做出来，换了一题，lc209 长度最小的子数组 (以上就占了快四十分钟了，剩下就问了二十分钟不到，心里已经凉凉) 3.Java线程池参数以及实现与缺陷 4.HashMap怎样避免减少冲突 5.整数作为Key要怎样设计最好 6.如果单个桶的元素数量很大，Map要怎么设计来解决 7.Hash桶很多但元素少，如何快速遍历 8.原子操作的实现 9.SpringBoot和Spring的区别 10.了解go吗 11.协程 12.跳表 13.数据库的分库分表方案 14.联合索引与多个单列索引的区别 15.Java RPC 16.Linux Socket 17.职业规划 简述项目 1、无锁队列，CAS 2、http状态码？ 3、断点续传用到什么状态码？ 4、https原理？ 5、为什么用epoll？ 6、ET、LT模式区别？ 7、多进程、多线程、多协程区别以及应用场景？ 8、Nginx并发模型？ 9、Redis并发模型？ 10、Linux下查看一个进程有什么命令？ 11、10亿qq号怎么做去重最高效？ 和游戏有关的问题： 1、Steam里有多少款游戏？ 2、问我觉得主机三大平台和Steam，以后哪个发展前景更好。 3、问我WeGame和Steam商店首页功能的区别，以及我觉得为什么会有这些区别。 4、Steam有什么可以改进的地方？ 5、性格怎么样？ 6、为什么想要做产品这个岗位？ 7、除了产品之外还有什么想投的岗位。 8、城市接受调剂吗？ 9、有什么兴趣爱好。 10、有什么问题要问他（他的预期似乎是问一些和求职有关的问题，但我问的是他觉得五年内有什么新的技术会改变互联网和互联网产品） 对原神的感受，谈对原神的了解，对比腾讯王者荣耀 腾讯的游戏缺少很多细节，一些精彩的文案。比如说原神中有很多书籍，可以丰富世界观，每种材料都会有相应的描述，甚至故事，彼此串联，而例如王者里面，人物和皮肤都缺少文案以丰富内容。 用户反馈，基本上每个礼拜都会收到调查反馈，而且确实会根据玩家声音比较大的点进行改进 简单的界面，简单的操作。相比腾讯网易的游戏，游戏界面确实干净很多，非功能性的界面都不在主界面显示 游戏的自由度。最开始吸引我去玩的就是自由度，几乎可以做想做的一切，而这和王者峡谷那种低自由度的环境产生了鲜明对比；后期驱动我玩下去的是二创，尤其是B战丰富的二创确实是越来越精良，这形成了一种氛围 挖掘用户群体，宅男宅女。这些人的特质是，闷骚，不热衷社交，有点小H，愿意为喜欢的游戏氪金。可以说，原神正是为这个群体打造的，高自由度满足了小H的愿望，弱社交性弱联机性迎合了略带社恐的人，精良的画面和美术抓住眼球 音乐和美术。优秀的音乐团队，恰到好处的bgm确实有调动人心的能力；美丽的风景，社畜的心灵安慰 大话：原神目前对腾讯的游戏构成了巨大威胁 新手引导：简单点说，就是它不是通过大量文字引导你 而是通过巧妙设置地图，让你觉得应该怎么操作人物，然后记住这一模式 还有一个就是，不会一股脑把你需要掌握的灌输给你而是先让你学会一个方法，然后给你几个怪物或者场景，去实践一下，来掌握这项方法细节方面，可以说，玩家和怪物的交互做的很好怪物的攻击对玩家有反馈，同时玩家的攻击也会让怪物的动作有反馈，不会出现双方各打各的，只是血条变化这种之类的 二面 30 min: 全程聊项目，所以问题只记得几个 \\1. 项目中遇到过什么困难呢？是怎么解决的呢？ \\2. 你是怎么去做算法调研的？你了解实际应用中用了哪些算法吗？ \\3. 为什么要用python？用了哪些包呢？ \\4. 讲一个项目里数据处理的流程吧。 \\5. 为什么用clickhouse？你了解其他数据库吗？ \\6. 用了解不了解分布式的一些东西，我就直接说了自己不了解也没有继续往下问 一面（30min） \\1. 面试官先进行了自我介绍，主要工作介绍。然后讲了一下为什么捞我。问我对这个岗位的意见。 \\2. Tcp和udp的区别；使用场景 \\3. http和https，讲一下https是怎么连接的，知道对称加密和非对称加密吗？ \\4. http是怎么保证可靠性的？讲一下滑动窗口。 \\5. 三次握手过程，为什么握手三次而挥手要四次。 \\6. 数据库了解吗？讲一下事务。 \\7. 索引的底层实现，为什么用B+树。 \\8. 了解redis吗？ \\9. 进程和线程的区别 \\10. 知道哪些锁？如何避免死锁？ 11.了解epoll吗 \\12. 问了几个项目问题，大概是介绍自己的项目那些之类的，我记不清了。问一个项目的并发量是多少？ 13.场景题: 如何设计一个秒杀系统？ \\14. 你觉得mysql可以支持百万级数据吗？如果可以的话要怎么做？ 大概是这些，如果我想起来其他的回来补充。 HR面:\\1. 讲项目的详细流程，遇到了什么困难，怎么解决的\\2. 项目分工，如何进行沟通？有什么收获或者进行总结过吗？\\3. 如果工作中需要同事配合，但是这不是他的kpi怎么办\\4. 你是如何学习新技术的？其他的我想起来再来补充…… 一面：记不大清楚了 先让自我介绍，然后问了我简历上的项目 问了beego框架的一些特性 项目中用到了hash函数，为什么用256而不是md5？ 写代码：括号匹配 二面：只面了30分钟，感觉面试官挺忙的 http1.0和2.0的区别； tcp和udp的区别； go中make和new的区别； 进程、线程、协程 go的接口机制？ go通道是如何实现的； 三面：三面印象中是最难的，上来就问我简历中提到了区块链，问我区块链是什么，然后抓住我做的一个项目问，问得比较细； go协程是如何实现的。 如何控制协程创建的数量？ 协程之间通信机制？ 项目中用到了几个通道，具体是如何使用的？ 你做的项目，并发量有多大。 考虑你的项目出现了问题怎么办。 mysql的数据引擎？innodb和myisam的区别？ 如何保证mysql数据并发安全？ 项目部署在哪里？有没有上线？ linux熟悉吗？都熟悉哪些操作？如何查找一个指定名称的进程？ linux如何修改配置信息？ go 的垃圾回收机制？ 了解过哪些新出的云产品服务？答了个k8s 用go还做过哪些其他项目？ go web开发的框架有哪些？ docker了解过吗？ 最近看的书？ ########################################################################################### 一面面经收集一上来就写题，问了一个第一个算法题：1.给一个长度为偶数n的序列中，前n/2个元素里面的最大值小于等于后n/2个元素里的最小值，称为“几乎有序”，可以对序列交换任意多次，两个不同的需要i,j交换每次的代价是i-j的绝对值。求将给定序列，转化为几乎有序序列的最小代价。嗯不太会。面试官提醒了一下，说求中位数然后比较。类似快排嗯写了10分钟没写出来。面试官说换一个吧那2。Ri：代表第i行的和Ci：代表第i列的和Zi：代表主对角线的和Fi：代表副对角线的和给一个n*n的矩阵，允许交换两个数的位置，返回上述4个参数和的最大值。嗯，还是不太会。面试官：你本科软件工程的这么基础的题都不会？ 我：嗯这题比我想象中的基础多了。 面试官：你有什么要问我的么？ 然后。。。没有然后了 1.自我介绍 2.问项目 3.为什么使用redis 4.nacos的作用 5.cap理论 6.tcp三次握手和四次挥手 7.为什么要四次挥手 8.有大量的time-wait怎么办 9.java的hashmap所用数据结构 10.MySQL事务隔离级别 11.MySQL所有的锁 12.MySQL下的MVCC 13.反问 1、TCP三次握手流程？为什么需要第三次？去掉第三次会怎么样？ 2、TCP如何处理丢包？TCP如何处理重传？拥塞控制？ 3、用过哪些加密算法？介绍加密算法及其区别？ 4、如果客户端反馈了一个错误如何排查服务器代码？如果没有任何输出、但就是有问题，如何排查？ 5、你常用的linux命令是什么？怎么在linux里找到你在运行的tomcat？ 6、mysql索引原理？悲观锁乐观锁？如果查询慢怎么解决？ 7、用过缓存吗？知道哪些缓存？ 8、堆和栈的区别？java函数调用的具体过程，在堆栈中的过程？ 9、区块链底层原理？（项目相关） 10、手撕代码…… 输入一个n，为结点总数；输入一个二维数组，表示结点的连接关系。可以以任意一个为根节点，请输出使得树深度最小的根节点。 先问了有哪些思路，提了两个，错了一个，讨论了一下为什么错，然后让按照第一个思路写……没撕出来……………… 11、反问（想着八成凉了，反手质问面试官，为啥问这么多跟java不太相关的（自杀式行为.jpg）他说因为平常要用） 8.进程线程区别，以及多进程多线程的使用场景 9.mysql主从复制以及好处、工作原理和机制 10.mysql引擎，索引数据结构，为什么用b+树不用别的 11.最近在看哪方面的书，你给我讲讲 12.写2道算法题 第一道： 汉明距离 第二道： 单词倒序并且大小写互反：例如：”heLlo WolRd” 转化为 “HElLO wOLrD” 13.反问 \\1. 自我介绍 \\2. 6道算法题，要求半小时完成 1）26 进制题 2）二叉树的第三大 3）有序链表公共结点 4）青蛙跳台阶 5）最长递增序列 \\6. 进程线程区别 \\7. 线程锁有哪些 \\8. 线程锁的优缺点 \\9. 如何改进线程锁的缺点 \\10. 问项目","categories":[],"tags":[{"name":"腾讯面试","slug":"腾讯面试","permalink":"https://zhengluoliudao.github.io/tags/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"}]},{"title":"wyh面试圣经","slug":"wyh面试圣经","date":"2022-01-02T09:39:33.000Z","updated":"2022-01-02T09:40:45.668Z","comments":true,"path":"2022/01/02/wyh面试圣经/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/wyh%E9%9D%A2%E8%AF%95%E5%9C%A3%E7%BB%8F/","excerpt":"","text":"复习纲要计算机基础篇数据结构表 链表和数组 栈和队列 树 二叉树 AVL树、红黑树 B/B+树 堆（感觉不严格属于树） （都不要求能够实现，甚至不需要知道左右旋之类的，知道区别，适用场景即可） 图 遍历图的算法（DFS/BFS） 迪杰斯特拉等算法（考得很少） 算法排序 快排 堆排序 归并排序 动态规划这个只能练习几道题来掌握，感觉很灵活 分治感觉也是面试考题时毕竟容易遇到的，相对好掌握一点，也需要练练题 贪心没咋遇到过考贪心的 操作系统 CPU的轮转调度 进程和线程 Linux相关操作（查端口占用，查性能占用之类的） Linux对锁的实现等等 还有些杂七杂八的 网络（这个是重点）HTTP/HTTPS 特点（无状态，应用层协议之类的） 一次GET请求的过程（这个真的会考） cookie和session（这个也考过，我还没答上来） 二者的区别，以及HTTPS如何保证安全 其它一堆东西（我现在一下子记不起来了 TCP/UDP 二者区别和特点 TCP的拥塞控制和流量控制（常考题） TCP的三次握手四次挥手（你一定会遇到的题，建议深入了解） TCP的原理 web框架这个不会就说不会（我也不太会 JAVA篇Java特性基本语法面向对象 类、接口 继承、多态、抽象等等 Java容器（或者数据结构） List和Array HashMap、HashTable、TreeMap、ConcurrentHashMap Collection集合接口和Map接口有什么关系（所以Map不太算容器，它继承自Set HashMap是线程安全的吗？线程安全的Map都有哪些？性能最好的是哪个？（大概看看各种Map的区别，复习到这里的时候可以先问问我，可以先大致给你讲讲） HashMap的一系列问题（扩容啊，实现啊，插入啊，查询啊balabala的） Java的锁（这块儿咱们学得比较少） 什么是线程安全，如何保证 什么是死锁，产生死锁的四个条件（这个也是常考题） synchronized关键字 volatile关键字 锁实现的一般原理和synchronized 实现原理 synchronized 与 Lock 的区别（也考过几次） CAS无锁的概念、乐观锁和悲观锁 偏向锁、轻量级锁、重量级锁、自旋锁的概念（这两个比较难，不一定非要理解） Java的多线程 什么是线程 线程和进程的区别 如何在Java中实现线程（三种方法：继承Thread类、完成Runnable接口，实现Callable&lt;&gt;接口并重写call方法） Thread 类中的start() 和 run() 方法有什么区别 Vector是一个线程安全类吗？（同理，他有可能问你每一个常见容器是否安全） java线程间通讯的方法 进程间通信的方法 线程池（一个重要考点） 线程池的作用，为什么要使用线程池 如何创建一个线程池，有哪些参数（比较重要） 按线程池内部机制，当提交新任务时，有哪些异常要考虑。 线程池的拒绝策略 其它（我这块儿一直掌握不佳） 线程如何启动 Java虚拟机 JVM内存模型 GC（上面两个都是软件构造讲过的） 类加载机制（背下来就差不多了） JavaSpring（学有余力可以学）数据库（也是重点） sql语句书写（找个在线sql练习网站练一练就好） MySql的哪几种引擎（主要了解InnoDB和MyIASM） MySql的索引，什么时候用Hash索引什么时候使用B+树索引 为什么数据库采用B+树来实现 事务的性质（ACID四大性质） 事务的隔离级别（以上都是重点） MySql的锁（不需要像Java了解那么深，知道不同引擎有不同锁，效率上的区别和适用场景即可） 视图 非关系型数据库（可做了解） 设计模式（也经常考一两题） 知道哪些设计模式啊？ 单例模式的懒汉模式和饿汉模式（这个面试官蜜汁爱问） 反正23种设计模式都看看吧，没啥坏处（软件构造的助教小姐姐还在群里发了基本资料，有空可以瞅瞅） 分布式系统（一般不会就不问）","categories":[],"tags":[{"name":"WYH","slug":"WYH","permalink":"https://zhengluoliudao.github.io/tags/WYH/"}]},{"title":"数据挖掘知识点汇总","slug":"数据挖掘知识点汇总","date":"2022-01-02T09:18:36.000Z","updated":"2022-01-02T13:25:22.522Z","comments":true,"path":"2022/01/02/数据挖掘知识点汇总/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"","text":"预处理数据质量的度量：准确性，完整性，一致性，及时性，可信度，可解释性 1234567891011121314151617数据预处理的主要任务：数据清理： 对丢失数据，忽略元组或手工/自动填写 对噪声数据，binning（分类再进行数据平滑）, 回归拟合，检测噪声并去除，计算机人工联合检测 对不一致数据，函数依赖项，人工规则数据简化： 降维：PCA，奇异值分解 数字缩减：回归和对数线性模型，直方图/聚类/采样，数据立方体聚合 数据压缩：数据转换和数据离散化归一化：min-max归一化：(x-min)/(max-min)z-score归一化：x-均值/方差预处理的作用：缩减数据规模，整理数据形式；有效清理数据，增加数据分析都有效性和准确性预处理的步骤有哪些：数据抽样和过滤，数据标准化和归一化，数据清洗 12345678PCA：捕捉有最大变化量的投影。找协方差矩阵的特征向量步骤：1，归一化S（减去均值） 2，计算C=S^TS 3，计算特征值和特征向量，特征向量即是主成分 |A-λE|=0， 4，P=SU，U为特征向量的拼接 行列式计算：主对角线元素积与副对角线元素积的差计算特征值和特征向量：解|A-λE|=0得特征向量，再代入|A-λE|，求得基础解系，归一化即得到特征向量，拼接特征向量得到U投影矩阵 1SVD：A=UsigmaV 12皮尔逊相关系数：x和y的协方差除以x和y的标准差（注意都是除以n-1）Jaccard相似度：同为1/不同为0 序列数据挖掘12345GSP：先得到频繁一项集，再反复进行：生成候选，剪枝，计数，淘汰1）连接阶段：如果去掉序列模式S1的第一个项目与去掉序列模式S2的最后一个项目所得到的序列相同，则可以将S1与S2进行连接，即将S2的最后一个项目添加到S1中。2）剪切阶段：若某候选序列模式的某个子序列不是序列模式，则此候选序列不可能是序列模式，将它从候选序列模式中删除。 图挖掘12345Gspan:1、遍历所有的图，计算出所有的边和点的频度。2、将频度与最小支持度数做比较，移除不频繁的边和点。3、重新将剩下的点和边按照频度进行排序，将他们的排名号给边和点进行重新标号。4、再次计算每条边的频度，计算完后，然后初始化每条边，并且进行此边的subMining()挖掘过程。 分类1234决策树：如何确定分类属性：基尼指数，熵（最大化增益）（增益比），分类误差如何确定停止分类：所有记录属于同一类，所有记录属性值相同，没有剩余属性避免过拟合：预修剪pre-pruning（提前停止），post-pruning（可以用MDL） 1ROC：横坐标FPR，纵坐标TPR，随阈值变化 1234K近邻：k个最近的里投票 问题：距离公式，K的选择，属性值缩放归一化，维度贝叶斯分类器：最大化后验概率贝叶斯网络： 聚类12分区聚类和层次聚类聚类的类型：分离良好的，基于中心的，基于邻近的 1234567基于密度的聚类：DBSCAN算法：核心点，边界点，噪声点 在彼此Eps内的任何两个核心点都在同一个聚类中，核心点Eps内的点都在同一个聚类 部分聚类方法，时间复杂度O(n^2)，允许不准确则可以到O(n) 确定Eps和MinPts 基于网格的聚类：划分网格，计算网格密度，消除密度低于阈值的网格，连续网格形成簇 12345层次聚类：嵌套聚类凝聚：合并最接近的聚类，更新邻近矩阵，循环 聚类间距离：最小，最大，平均，质心，沃德法（平方差SSE变化量，每个值减去合并后的均值，平方再求和）分裂： cure算法（使用代表点） 1K-means：循环：选中心，根据距离分类 关联分析123456789频繁项集：Apriori算法： 剪枝：任意频繁项集的非空子集也是频繁的 FP-growth: 建立频繁一项集，剪枝删除没达到支持度的节点，按照支持度排序重排原集合（不要忘了这个） 建立FP-树 从树底E出发，建立条件模式基，祖先节点计数置为叶子节点的计数，从而挖掘出含E的频繁项集 递归挖掘频繁项集","categories":[],"tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://zhengluoliudao.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}]},{"title":"2020年高级数据库试题","slug":"hello","date":"2022-01-02T08:08:02.000Z","updated":"2022-01-02T08:18:08.393Z","comments":true,"path":"2022/01/02/hello/","link":"","permalink":"https://zhengluoliudao.github.io/2022/01/02/hello/","excerpt":"","text":"⼀、简答题（数据库语⾔，共20分） （8分）在图书管理数据库中，有如下三个关系：图书信息关系：B(B#, BNAME, AUTHOR, TYPE)，其中B#为图书编号，BNAME为书名，AUTHOR为作者，TYPE为图书类别；学⽣信息关系：S(S#, SNAME, CLASS)，其中S#为学号，SNAME为学⽣姓名，CLASS为班级号；借阅信息关系：L(S#, B#, DATE)，其中S#为借阅⼈学号，B#为被借阅图书编号，DATE为借阅⽇期。使⽤关系代数回答下列问题：a) （2分）查询借了《红楼梦》这本书的学⽣的姓名。b) （2分）查询105班的所有学⽣全都借过的图书的编号。c) （2分）查询“张三”同学借过，但是“李四“同学没有借过的书的编号。d) （2分）编写⼀个查询，说明如何根据该查询的结果验证B的关系实例是否满⾜函数依赖BNAME → B#。 1234567891011121314151617181920212223242526272829303132333435363738394041a)select SNAME from ((B join L using B#) join S using S#)where BNAME = &quot;红楼梦&quot; b) #这里有一个关键词，全都，即借阅人数等于总人数，或者不存在人没选select B# from ((B join L using B#) join S using S#) Xwhere CLASS = 105 group by B#having count(*) = (select count(*) from ((B join L using B#) join S using S#) Ywhere Y.CLASS = 105) select B# from((B join L using B#) join S using S#) Xwhere CLASS = 105 and not exists(select * from ((B join L using B#) join S using S#) Ywhere Y.CLASS = 105 and X.B# != Y.B#)c) #这里有一个关键词，借过/学过，没借过/没学过select B# from ((B join L using B#) join S using S#) Xwhere &quot;张三&quot; in (select SNAME from ((B join L using B#) join S using S#) Ywhere X.B# = Y.B#) Zand &quot;李四&quot; not in Zd) #验证函数依赖，即确定如果两本书书名相同，书号必相同，即根据书名找书号找不到两个select count(B#) from Bgroup by BNAME如果不是全为1，则函数依赖不成立，反之成立 （12分）在博客管理数据库中，有如下三个关系：⽤户信息关系：U(UID#，UNAME, UAGE, USEX)，该表包含属性UID#（⽤户ID）、UNAME（⽤户姓名）、UAGE（⽤户年龄）、USEX（⽤户性别）。博客信息关系：B(BID#，UID#，BTITLE，BCONTENT，BTIME)，该表包含属性BID#（博客编号）、UID#（作者ID），BTITLE（博客标题），BCONTENT（博客内容），BTIME（博客发布时间）。评论信息关系：C(CID#, BID#, UID#, CCONTENT，CTIME)，该表包含属性CID#（评论编号），BID#（被评论博客编号），UID#（评论者ID），CCONTENT（评论内容），CTIME（评论时间）。UID #、BID #、CID#分别为关系U、B、C的主键。使⽤SQL语⾔回答下列问题：a) （3分）删除名为“张三”的⽤户发表的所有博客。b) （3分）查询“张三”对“李四”发表的博客的评论总数。c) （3分）定义⼀个视图SumU(UID#, UNAME, Year, Count#)，其中UID#为⽤户id，UNAME为⽤户姓名，Year为年份，Count#为该⽤户该年度发表博客的总数。d)（3分）基于视图SumU，查询2019年发表博客数最多的⽤户的ID和姓名。 12345678910111213141516171819202122232425262728293031323334a)delete from Bwhere UID in (select UID from U where U.UID = B.UID and UNAME = &quot;张三&quot;)b)select count(*) from Cwhere BID in (select BID from B join U where UNAME = &quot;李四&quot;)and UID in (select BID from B join U where UNAME = &quot;张三&quot;)c)create view SumU asselect X.UID# UID#, X.UNAME UNAME, Date_FORMAT(X.BTIME, &quot;%Y&quot;) Year, count(BID#) Count# from U join B using UID# Xgroup by UID#, yeard) #关键词，最大, &gt;ALL , = MAXselect UID#, BNAMEfrom SumU Xwhere Year = 2019 and count# &gt;= all(select count# from SumU where Year = 2019) ⼆、计算与简答题（关系数据库理论，共18分）已知关系模式R(A, B, C, D, E)上的函数依赖集F为{ AC → E; B → CE; C → B; AB → CD; AE → D }，回答下列问题： （3分）求AC关于F的属性集闭包。 （3分）求R的候选键。 （4分）求F的最⼩覆盖。 （4分）将R分解为2个关系模式S(A, B, C)和T(A, B, D, E)，该分解是否是⽆损连接分解？说明理由。 （4分）将R进⾏分解⼀组3NF关系模式，使得该分解既是⽆损连接分解，⼜保持函数依赖。 121)闭包 三、论述题（共12分）结合你的数据库系统实践经历，回答下列问题： （4分）数据库的三级模式和两级映像架构对数据库系统有何重要意义？ （4分）在设计⼤型关系数据库时，遵照“概念设计→逻辑设计→物理设计”的设计过程有何好处？ （4分）数据库管理系统的缓冲区管理与操作系统的虚拟内存管理有何不同之处？ 121) 四、分析与简答题（数据库管理系统实现，共34分） （6分）使⽤可扩展hash表存储整型元素。设hash函数为h(x) = x mod 16，h(x)的结果是⼀个4位⼆进制序列，其前d位⽤于确定元素x属于哪个桶。设每个桶中⾄多包含2个元素。现将下列元素依次添加到hash表中：5, 19, 24, 26, 35, 48, 53, 61。初始时，hash表为空，且d = 1。请画出添加完上述所有元素后，最终得到的hash表。 1 （6分）关系R(a, b)和S(b, c)存储在磁盘上，分别占500和1000个磁盘块。R和S上既⽆索引，也未按属性b排序。设可⽤内存缓冲区块数为M，回答下列问题：a)（3分）如果M = 50，那么使⽤哪种连接算法执⾏R ⨝ S效率最⾼？I/O代价是多少？b)（3分）如果M = 126，那么使⽤哪种连接算法执⾏R ⨝ S效率最⾼？I/O代价是多少？ 12a)哈希，4500b)哈希 （6分）设教学管理数据库有如下3个关系模式：EMPLOYEE(ESSN#, ENAME, SALARY, DNO#)PROJECT(PNO#, PNAME)WORKS_ON(ESSN#, PNO#)DEPARTMENT(DNO#, DNAME)⽤户给出以下SQL语句：SELECT ENAMEFROM EMPLOYEE, WORKS_ON, PROJECTWHERE SALARY &lt; 3000 AND PROJECT.PNO = ‘P1’AND EMPLOYEE.ESSN# = WORKS_ON.ESSN# AND WORKS_ON.PNO# = PROJECT.PNO#;回答下列问题：a) （3分）写出该SQL语句对应的关系代数表达式，并画出该表达式对应的逻辑查询计划树。b) （3分）使⽤启发式查询优化⽅法对以上查询计划进⾏优化，并画出优化后的逻辑查询计划树。","categories":[],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"https://zhengluoliudao.github.io/tags/DataBase/"}]}],"categories":[],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"https://zhengluoliudao.github.io/tags/DataBase/"},{"name":"组合数学","slug":"组合数学","permalink":"https://zhengluoliudao.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"JZ","slug":"JZ","permalink":"https://zhengluoliudao.github.io/tags/JZ/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zhengluoliudao.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"SQL","slug":"SQL","permalink":"https://zhengluoliudao.github.io/tags/SQL/"},{"name":"linux","slug":"linux","permalink":"https://zhengluoliudao.github.io/tags/linux/"},{"name":"项目","slug":"项目","permalink":"https://zhengluoliudao.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"秒杀","slug":"秒杀","permalink":"https://zhengluoliudao.github.io/tags/%E7%A7%92%E6%9D%80/"},{"name":"腾讯面试","slug":"腾讯面试","permalink":"https://zhengluoliudao.github.io/tags/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"},{"name":"WYH","slug":"WYH","permalink":"https://zhengluoliudao.github.io/tags/WYH/"},{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://zhengluoliudao.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}]}